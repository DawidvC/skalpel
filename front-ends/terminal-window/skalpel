#!/bin/bash

###############################################################
###############################################################
##
## Copyright 2009, 2010 Steven Shiells
## Copyright 2010 Vincent Rahli
## Copyright 2011 John Pirie
##
## This file is free software: you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## This file is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Skalpel.  If not, see <http://www.gnu.org/licenses/>.
##
##
## Authors: Steven Shiells
## Date: December 2009
## Description: This is a shell script to run Skalpel, type 
##              error slicer for SML.
##
################################################################
################################################################

scriptDir=`cd $(dirname $0); pwd`

# Variable to hold the basis file to be used by the slicer
filebas="${scriptDir}/basis.sml"

# Variable to hold the file to slice
filein="\"\""

# Variables for the HTML output from the slicer
filehtml="\"\""
htmldir=""

# Variables for the XML output from the slicer
filexml="\"\""
xmldir=""

# Variables for the SML output from the slicer
filesml="\"\""
smldir=""

# Variables for the Emacs Lisp output from the slicer
filelisp="\"\""
lispdir=""

# Variables for the perl output from the slicer
fileperl="\"\""
perldir=""
perlset=0

# Variable to keep track of the basis option.
# Default = 1
baseop=1

showbas=0

# Default time limit
tlim=5000

# Variable to keep track of whether or not the user wishes to
# view the slices in the terminal window.
# 1 = yes, 0 = no, 2 = interactively, default = 1
displayOption=1

# Command to run Sklapel
slicerCommand="${scriptDir}/skalpel-bin"

if [ ! -f $slicerCommand ] 
then
    echo "The slicer back-end binary cannot be found!"
    echo "It should have the name 'skalpel-bin' and sit in the same directory as this script."
    exit
fi

# Command to convert .pl files to .sh files
perlToShell="${scriptDir}/skalpel-perl-to-bash"

# Variable to keep track of whether or not the user requested slices
info=0

# Tempory directory
tmpdir="/tmp"

# Trap ctrl-c and call ctrl_c()
trap ctrl_c INT

# Catch ctrl-c, tidy things up
function ctrl_c() {
    tidy_up
}


########################################################
## Prints the help messages associtated with the script
########################################################
function show_help {
    # Print the information about how to use the script
    # and the options that teh script can be run with
    echo "Usage: skalpel [OPTIONS] [INPUT FILE]"
    echo -e "Runs Skalpel on [INPUT FILE].\n"
    echo -e "  -b | --basis <option>\t\tselects the basis option:"
    echo -e "\t\t\tValid options are:"
    echo -e "\t\t\t0 - no basis"
    echo -e "\t\t\t1 - uses a built in subset version of the Standard ML Basis Library"
    echo -e "\t\t\t2 - uses a file as the basis.  This basis is the Standard ML Basis Library plus some of the SML/NJ Library."
    echo -e "  -bo | if set to 1, shows basis slice when encountering overloading errors. If set to 0, hides it."
    echo -e "  -e | --emacslisp <file>\toutputs the type error slices in Emacs Lisp format to <file>"
    echo -e "  -p | --perl <file>\t\toutputs the type error slices in Perl format to <file>"
    echo -e "  -s | --sml <file>\t\toutputs the type error slices in SML format to <file>"
    echo -e "  -x | --xml <file>\t\toutputs the type error slices in xml format to <file>"
    echo -e "  -w | --html <file>\t\toutputs the type error slices in html format to <file>"
    echo -e "  -t | --time <time>\t\t**sets the time limit Skalpel runs for"
    echo -e "  -i | --interactive\t\tAllows the user to cycle through the slices"
    echo -e "  -n | --no-display\tdoes not display the type error slices in the terminal"
    echo -e "  -l | --legend\t\tdisplays the legend which explains the highlighting"
    echo -e "  -h | --help\t\tdisplays this help text"
    echo
    echo "Reports bugs to <rahli@macs.hw.ac.uk> or <jbw@macs.hw.ac.uk>."
}

#######################################################
## Creates the output to display in the terminal window
#######################################################
function format_output {

    length=${#fileperl}-3
    # Wait until either a slice is found or the slicer finishes
    while [ ! -f ${perldir}/${fileperl:0:$length}-1.pl ] && [ ! -f ${perldir}/${fileperl:0:$length}-finished.pl ]
    do
	# wait
	sleep 0.5
    done
    # Create the .sh files from the appropriate .pl files
    ${perlToShell} ${filein} ${perldir}/${fileperl}
    fileshell=${fileperl:0:$length}*.sh
    # Change the permissions of the files to allow them to be executed
    chmod u+x ${perldir}/${fileshell}
}

##################################
## Tidies things up before exiting
##################################
function tidy_up {

    # If the user wants perl files just delete the .sh files
    if [ ${perlset} -eq 1 ]
    then
	rm ${perldir}/${shellbase}-*.sh
    else
	# If the user does not want perl files delete the .sh files
	# as well as the .pl files used to create the .sh files
	rm -r ${perldir}
    fi
    # Reset the terminal to original settings
    echo -e "\e[0m"
    # Exit
    exit 0
}

#############################################
## Displays the slices in the terminal window
#############################################
function display_slices {

    # Find the base name of the shell files
    fileshell=${fileperl##*/}
    shellbase=${fileshell%%.*}

    # Messages to display to user
    slicerstatus="Slicing continuing..."

    # Variable to keep track of the current slice
    count=1

    # Check to see if there are if the slicer has finished
    finishedfile="${perldir}/${shellbase}-finished.pl"

    # While the slicer has not finished
    while [ ! -f ${finishedfile} ]
    do
	# Set the next slice that is to be displayed
	nextfile="${perldir}/${shellbase}-${count}.pl"

	# If the next file is ready to display
	if [ -f ${nextfile} ]
	then

	    # Format the output to ensure that the
	    # slice can be displayed in the terminal
	    format_output

	    echo "Displaying slice ${count}"

            # Display the next slice
	    ${perldir}/${shellbase}-${count}.sh

	    # Increment the count variable to be the
	    # next slice
	    count=$[${count}+1]

	    # Print the status of the slicer
	    echo ${slicerstatus}
	fi
    done


    # Find the number of files containing slices
    nofiles=`find ${perldir} -maxdepth 1 -name "${shellbase}*.sh" | wc -l`
    # Decrease 1 to account for <file>-finished.sh
    nofiles=$[${nofiles}-1]

    # Check to see if all of the slices have been printed
    if [ ${count} -le ${nofiles} ]
    then

	# Format the output to ensure that the
	# slice can be displayed in the terminal
	format_output

	# Print all of the slices that have not been printed
	while [ ${count} -le ${nofiles} ]
	do
	
	    echo "Displaying slice ${count}"

            # Display the next slice
	    ${perldir}/${shellbase}-${count}.sh

	    # Increment the count variable to be the
	    # next slice
	    count=$[${count}+1]

	    # Print the status of the slicer
	    echo ${slicerstatus}
	done
    fi

    echo "Slicing finished."

    # Tidy things up
    tidy_up

}

#############################################
## Displays the slices in the terminal window
#############################################
function display_slices_interactive {

    # Find the base name of the shell files
    fileshell=${fileperl##*/}
    shellbase=${fileshell%%.*}

    # Messages to display to user
    slicerstatus="Slicing continuing..."
    options="Enter\n\t\"q\" to quit,\n\t\"n\" or <ENTER> to view the next slice,\n\t\"p\" to view the previous slice, or\n\t\"l\" to view the legend."

    # Find the number of files containing slices
    nofiles=`find ${perldir} -maxdepth 1 -name "${shellbase}*.sh" | wc -l`
    # Decrease 1 to account for <file>-finished.sh
    nofiles=$[${nofiles}-1]

    # Variable to keep track of the current slice
    count=1

    # Display the first slice
    echo "Displaying slice $count of $nofiles."
    ${perldir}/${shellbase}-${count}.sh
    echo "Displaying slice $count of $nofiles."

    # If there is more than one slice allow the user to cycle through all of the slices
    if [ ${nofiles} -gt 1 ]
    then

	# Repeat until the user quits
	while [ 1 ]
	do
	    
	    # Check to see if there are if the slicer has finished
	    finishedfile="${perldir}/${shellbase}-finished.pl"
	    if [ ! -f ${finishedfile} ]
	    then
                # Find the number of files containing slices
		nofiles=`find ${perldir} -maxdepth 1 -name "${shellbase}*.sh" | wc -l`
                # Decrease 1 to account for <file>-finished.sh
		nofiles=$[${nofiles}-1]
		format_output
	    else
		# Change the slicer status
		slicerstatus="Slicing Complete."
	    fi
	    # Print the slicer's status
	    echo ${slicerstatus}
       	    # Prompt the user to enter a command
	    echo -e ${options}
	    # Get the users option
	    echo -n "> "
	    read option
	    case ${option} in
		"q")
		    break;
		    ;;
		"n" | "") 
                    # Increment the variable keeping track of the current slice
 		    count=$[${count}+1]
 		    # If count is greater than the number of slices go back to the first slice
 		    if [ ${count} -gt ${nofiles} ]
 		    then
 			count=1
 		    fi
 		    # Display the next slice
 		    echo "Displaying slice $count of $nofiles."
 		    ${perldir}/${shellbase}-${count}.sh
 		    echo "Displaying slice $count of $nofiles."
		    ;;
		"p") 
                    # Increment the variable keeping track of the current slice
 		    count=$[${count}-1]
 		    # If count is greater than the number of slices go back to the first slice
 		    if [ ${count} -lt 1 ]
 		    then
 			count=${nofiles}
 		    fi
 		    # Display the next slice
 		    echo "Displaying slice $count of $nofiles."
 		    ${perldir}/${shellbase}-${count}.sh
 		    echo "Displaying slice $count of $nofiles."
		    ;;
		"l")
		    # Display the legend
		    ${scriptDir}/skalpel-legend
		    ;;
		*)
 		    # Otherwise the user entered an incorrect value
 		    echo "Invalid option:"
		    ;;
	    esac
	done

    fi

    # Tidy things up
    tidy_up

}


######################################################
## Function to check to see if any of the output files 
## the user specifies already exists
######################################################
function check_file {
    # check to see if the directory exists
    if [ -d $1 ]
    then
	tmp=$1${2%%.*}"-1."${2#*.}
        # check to see if the file exists
	if [ -f ${tmp} ]
	then
	    # The filename entered by the user already exists, ask the user if they would like to replace the file.
	    # The user has 3 chances to respond with a valid response. If they do not do so, do not replace the file
	    # and inform the user that the file will not be replaced.
	    counter=1
	    while [ ${counter} -le 3 ]
	    do
		# Get the users response
		echo "The file \"$2\" already exists, would you like to;"
		echo "choose a different name: enter \"2\"."
		echo "replace existing file: enter \"1\"."
		echo "neither: enter \"0\"."
		echo -n "> "
		read replace

		case $replace in
		    "2")
			echo "Please enter the name of the file to use instead of \"$2\"."
			echo -n "> "
			read newname
			newnamedir=${newname%/*}
                        # Get the filename specified by the user
			filenewname=${newname##*/}
	                # If the filename and the directory are the same
	                # i.e. the file is in the current directory
			if [ ${newnamedir} == ${filenewname} ]
			then
		        # set the directory to be the current directory
			    newnamedir="./"
			fi
			check_file ${newnamedir} ${filenewname}
                        # If the check fails set the paramater for the slicer to be empty
			if [ $? -eq 0 ]
			then
			    newnamedir=""
			    filenewname="\"\""
			fi
			return 2			
			;;
		    "1")
			# The user wishes to remove the files so
         		## remove all of the files
			removebase=${2%%.*}
			removeext=${2#*.}
			rm $1${removebase}-*.${removeext}
			counter=4
			# return 1 - i.e. everything is ok
			return 1
			;;
		    "0")
			echo "The output file \"$2\" will not be produced by Skalpel."
			counter=4
			# return 0 - the $1/$2 will not be used
			return 0
			;;
		    *)
			# If the user does not enter either "yes" or "no"
			# inform them that they entered an incorrect option
			if [ ${counter} -eq 3 ]
			then
			    echo "last attempt"
			    counter=4
			else
			    echo "You entered an incorrect option."
			    counter=$[${counter} + 1]
			fi
			;;
		esac
	    done
	    echo "The output file \"$2\" will not be produced by Skalpel."
	    # return 0 - the $1/$2 will not be used
	    return 0
	else
            # return 1 -  everything is fine
	    return 1
	fi
    else
	# return 0 - the $1/$2 will not be used
	echo "The directory $1 does not exist!"
	return 0
    fi
}

################################################
## Gets the options that the script was run with
################################################
while [ "$#" -gt 0 ]
do
    case $1 in
	-b | --basis)
	    # Set the basisop to ${2}
	    # make sure ${2} is an integer
	    if [ $(echo "${2}" | grep -E "^[0-9]+$") ]
	    then
		# make sure ${2} is in the valid range
		if ! [ ${2} -ge 0 ] || ! [ ${2} -le 2 ]
		then
		    # ${2} is not in the valid range so inform the user
		    echo ${2} is an invalid value. Range is [0-2].
		    echo The default value will be used.
		else
		    # ${2} is in valid range
		    baseop=${2}
		fi
	    else
		# ${2} is not an integer, inform the user
		echo ${2} is not a valid integer.
		echo The default value will be used.
	    fi
	    shift
	    shift
	    ;;
	-e | --emacslisp)
	    # The user would like the slices in Emacs Lisp format
	    # Get the directroy of the file specified by the user
	    lispdir=${2%/*}
	    # Get the filename specified by the user
	    filelisp=${2##*/}
	    # If the filename and the directory are the same
	    # i.e. the file is in the current directory
	    if [ ${lispdir} == ${filelisp} ]
	    then
		# set the directory to be the current directory
		lispdir="./"
	    fi
	    # Perform a check on the files
	    check_file ${lispdir} ${filelisp}
	    # If the check fails set the paramater for the slicer to be empty
	    res=$?
	    if [ ${res} -eq 0 ]
	    then
		lispdir=""
		filelisp="\"\""
	    else
		# If the user had to rename the file
		if [ ${res} -eq 2 ]
		then
		    # Get the new name of the file
		    lispdir=${newnamedir}
		    filelisp=${filenewname}
		fi
	    fi
	    shift
	    shift
	    ;;
	-p | --perl)
	    # The user would like the slices in Perl format
	    # Get the directroy of the file specified by the user
	    perldir=${2%/*}
	    # Get the filename specified by the user
	    fileperl=${2##*/}
	    # If the filename and the directory are the same
	    # i.e. the file is in the current directory
	    if [ ${perldir} == ${fileperl} ]
	    then
		# set the directory to be the current directory
		perldir="./"
	    fi
	    # Perform a check on the files
	    check_file ${perldir} ${fileperl}
	    # If the check fails set the paramater for the slicer to be empty
	    res=$?
	    if [ ${res} -eq 0 ]
	    then
		perldir=""
		fileperl="\"\""
	    else
		# If the user had to rename the file
		if [ ${res} -eq 2 ]
		then
		    # Get the new name of the file
		    perldir=${newnamedir}
		    fileperl=${filenewname}
		fi
		# If everything is ok set "perlset" to 1
		# This is used to indicate that we can use the .pl
		# files specified by the user for producing the .sh
		# files which contain the slices which are displayed
		# in the terminal window
		perlset=1
	    fi
	    shift
	    shift
	    ;;
	-s | --sml)
	    # The user would like the slices in SML format
	    # Get the directroy of the file specified by the user
	    smldir=${2%/*}
	    # Get the filename specified by the user
	    filesml=${2##*/}
	    # If the filename and the directory are the same
	    # i.e. the file is in the current directory
	    if [ ${smldir} == ${filesml} ]
	    then
		# set the directory to be the current directory
		smldir="./"
	    fi
	    # Perform a check on the files
	    check_file ${smldir} ${filesml}
	    # If the check fails set the paramater for the slicer to be empty
	    res=$?
	    if [ ${res} -eq 0 ]
	    then
		smldir=""
		filesml="\"\""
	    else
		# If the user had to rename the file
		if [ ${res} -eq 2 ]
		then
		    # Get the new name of the file
		    smldir=${newnamedir}
		    filesml=${filenewname}
		fi
	    fi
	    shift
	    shift
	    ;;
	-x | --xml)
	    # The user would like the slices in XML format
	    # Get the directroy of the file specified by the user
	    xmldir=${2%/*}
	    # Get the filename specified by the user
	    filexml=${2##*/}
	    # If the filename and the directory are the same
	    # i.e. the file is in the current directory
	    if [ ${xmldir} == ${filexml} ]
	    then
		# set the directory to be the current directory
		xmldir="./"
	    fi
	    # Perform a check on the files
	    check_file ${xmldir} ${filexml}
	    # If the check fails set the paramater for the slicer to be empty
	    res=$?
	    if [ ${res} -eq 0 ]
	    then
		xmldir=""
		filexml="\"\""
	    else
		# If the user had to rename the file
		if [ ${res} -eq 2 ]
		then
		    # Get the new name of the file
		    xmldir=${newnamedir}
		    filexml=${filenewname}
		fi
	    fi
	    shift
	    shift
	    ;;
	-w | --html)
	    # The user would like the slices in HTML format
	    # Get the directroy of the file specified by the user
	    htmldir=${2%/*}
	    # Get the filename specified by the user
	    filehtml=${2##*/}
	    # If the filename and the directory are the same
	    # i.e. the file is in the current directory
	    if [ ${htmldir} == ${filehtml} ]
	    then
		# set the directory to be the current directory
		htmldir="./"
	    fi
	    # Perform a check on the files
	    check_file ${htmldir} ${filehtml}
	    # If the check fails set the paramater for the slicer to be empty
	    res=$?
	    if [ ${res} -eq 0 ]
	    then
		htmldir=""
		filehtml="\"\""
	    else
		# If the user had to rename the file
		if [ ${res} -eq 2 ]
		then
		    # Get the new name of the file
		    htmldir=${newnamedir}
		    filehtml=${filenewname}
		fi
	    fi
	    shift
	    shift
	    ;;
	-t | --time)
	    # The user wishes to change the time the slicer runs** for
	    # Make sure the value entered by the user is a number
	    if [ $(echo "${2}" | grep -E "^[0-9]+$") ]
	    then
		tlim=${2}
	    else
		# The value entered by the user was not a number
		# Inform the user
		echo ${2} is not a valid integer.
		echo The default value will be used.
	    fi
	    shift
	    shift
	    ;;
	-i | --interactive)
	    # The user wishes to view the slices interactively
	    displayOption=2
	    shift
	    ;;
	-bo)
	    # Make sure the value entered by the user is a number
	    if [ $(echo "${2}" | grep -E "^[0-9]+$") ]
	    then
		showbas=${2}
	    else
		# The value entered by the user was not a number
		# Inform the user
		echo ${2} is not a valid integer.
		echo The default value will be used.
	    fi
	    shift
	    shift
	    ;;
	-l | --legend)
	    # Show legend
	    ${scriptDir}/skalpel-legend
	    info=1
	    shift
	    ;;
	-h | --help)
	    # Show help
	    show_help
	    info=1
	    shift
	    ;;
	-n | --no-display)
	    # The user does not wish to view the slices in the terminal window
	    displayOption=0
	    shift
	    ;;
	-v | --version)
	    echo "Version: 0.4"
	    info=1
	    shift
	    ;;
	# file to slice
	*)
	    filein=${1}
	    shift
	    ;;
    esac
done

# If an input file  has been entered
if [ ${filein} != "\"\"" ]
then
    
    # if the file does not exist, tell the user about it and exit
    if [ ! -f ${filein} ]
    then
	echo "File to slice does not exist!"
	exit 1
    fi
    
    # If the users wishes to display the slices in the terminal...
    if [ ${displayOption} -eq 1 ] || [ ${displayOption} -eq 2 ]
    then
	# If the user has not specified a perl file
	if [ ${fileperl} == "\"\"" ]
	then
	    # create a new folder to contain the perl and .sh files
	    # and set the appropriate variables so that the necessary
	    # files are produced
	    filein_base=`basename ${filein}`
	    perldir="${tmpdir}/${filein_base}-perl-slices"
	    # shelldir does not seem to be used
	    #shelldir=${perldir}
	    mkdir ${perldir}
	    fileperl="output.pl"
	fi
    fi

    ## Make sure the user has entered a file to slice and that the file exists
    if [ -f ${filein} ]
    then
	# Format the command to run the slicer with that appropriate arguments
	runSlicerCommand="$slicerCommand"
	if [ ${filebas} != "\"\"" ]
	then
	    runSlicerCommand="$runSlicerCommand -b 2 $filebas"
	else
	    runSlicerCommand="$runSlicerCommand -b $baseop"
	fi
	if [ ${filehtml} != "\"\"" ]
	then
	    runSlicerCommand="$runSlicerCommand -h $htmldir/$filehtml"
	fi
	if [ ${fileperl} != "\"\"" ]
	then
	    runSlicerCommand="$runSlicerCommand -p $perldir/$fileperl"
	fi
	if [ ${filexml} != "\"\"" ]
	then
	    runSlicerCommand="$runSlicerCommand -x $xmldir/$filexml"
	fi
	if [ ${filesml} != "\"\"" ]
	then
	    runSlicerCommand="$runSlicerCommand -s $smldir/$filesml"
	fi
	if [ ${filelisp} != "\"\"" ]
	then
	    runSlicerCommand="$runSlicerCommand -l $lispdir/$filelisp"
	fi
	runSlicerCommand=$runSlicerCommand" -t $tlim -bo $showbas "$filein
	# echo "runSlicerCommand: $runSlicerCommand"
    fi

    # Run the slicer command
    ${runSlicerCommand} >/dev/null &
    echo "Slicing..."

    # If the user wishes to view the slices in the terminal
    case ${displayOption} in
	1)
            # Format the output
	    format_output
	    # Display the slices
	    display_slices
	    ;;
	2)
	    # Format the output
	    format_output
	    # Display the slices (interactive)
	    display_slices_interactive
	    ;;
    esac
else
    # The user did not enter a input file
    # Check to see if the user ran the command with the
    # -h or --help options, if they did not inform the 
    # user that they did not use the command correctly
    if [ ${info} -eq 0 ]
    then
	echo "Invalid usage!"
	echo "use the \"-h\" or \"--help\" options for details on how to use this command."
    fi
fi
