* WARNINGS

When I'm doing unioning of labels, say when I'm doing something with
EQUALITY_TYPE_DEPENDNCIES, I don't touch the other arguments of that
datatype constructor (the deps, and the ids values). This may cause
problems later, be aware that there may be work that needs to be done
here.

As soon as a chance is available, maybe print out these values to see
what they contain, so that I can figure out how important it is to
take care of these values.

Actually, now I think about it, isn't deps a second set of labels?
Perhaps I can use this to track endpoints properly, as at the moment
equality type errors are only defined to have one endpoint, and it
should do something like a type constructor clash where there can be
multiple.

---
Changed the type constraint that's initialised in SconReal to have a
NOT_EQUALITY_TYPE attachment, instead of UNKNOWN. But should this be a
warning, is this not the behavior that we actually want? Think about
this.
---

* TODOs
** Test framework [20%]
*** DONE (2012-06-29-12:59) Test framework fetching and compiling latest binary

  I *must* update this aspect to the test framework soon, ideally
  today. I see this is the currently most important aspect which is
  missing with respect to testing, as I often don't have time to do
  this manually (though I am running the binary through the tests we
  have and diffing the output myself to make sure everything hasn't
  exploded).

*** TODO (2012-06-29-12:59) Test framework detecting diffs from previous runs

  When sending e-mails, the test framework is showing differences
  between the tests today and the tests the previous day, so if I don't
  read the results from the test framework on any given day, when I read
  it the next day I won't see this information.

  We should diff the results against a master copy, which can be
  updated manually when we're satisfied things are working probably,
  or better in some way.

*** TODO (2012-07-02-16:45) Daily package building

Packages should be built daily by the test framework, and a report
should be generated whether it was possible to build the package or
not. As the test framework runs on a red hat system it is not possible
to generate say the debian packages, but we are still able to generate
quite a few of them.

*** TODO (2012-07-02-16:46) Daily package testing

The packages that are built should also be installed and tested, and
the results of all of this should end up in the e-mail that gets sent
out in the morning. Wouldn't it be nice just to decide we were going
to release one day and just do it? :-)

*** TODO (2012-07-02-16:48) Test Emacs front end works

We should test also the Emacs front end. It would somehow need to be
started with a Standard ML source file open, have the type error slice
run on that file, and check that Emacs is highlighting things inside
the file, and that the process terminates.

** Equality types implementation [20%]
*** TODO (2012-06-28-16:00) Generating equality constraints for tuples

    The case involving tuples doesn't work yet, I'm going to need to
    think of a way to handle code like this: (1, 1.0) = (2, 2.0). The
    equality type variable which represents the tuple should be
    constrained to be equal to.... something. Not sure how this is
    going to work yet, I'll need to have a think about this.

*** TODO (2012-06-29-21:19) Detection of equality type error where 'eqtype' is in a signature

    In the case where we have 'eqtype x' in a signature (instead of
    what could be 'type x') an equality status constraint of
    EQUALITY_TYPE should be generated for x (obviously). Then if the
    user is to do something like 'val y : x = 5.0' then an equality
    type error should be output by Skalpel, the EQUALITY_TYPE status
    of x clashing with the NOT_EQUALITY_TYPE status of the 5.0.

*** TODO (2012-06-29-21:36) Detection of equality type error where ''a is involved in a signature

    If we have a function signature definition such as "val f : ''a ->
    ''a" we should detect an equality type error if something that
    isn't an equality type is given as an argument.

    It may be the case that this already works, which would indeed be
    lovely, but the world often isn't that kind. Check this out, it
    should only be the constraint generation phase that needs to be
    changed, and not the constraint solving, though I'm not absolutely
    certain of that.

*** TODO (2012-06-29-21:46) Add in equality type status constraints for types other than real

    Currently the NOT_EQUALITY_TYPE status is only generated for the
    real type. This status should be inserted in the constraint
    generation stage for other types (in functions and exceptions for
    example).

*** DONE (2012-06-27-01:33) Seeing a type variable being constrained to be the same as a status

  During unification we have the case of equality type variables being
  constrained to equality type statuses. This happens in the function:

  fsimplify ((E.EQUALITY_TYPE_CONSTRAINT ((equalityTypeVar as T.EQUALITY_TYPE_VAR eqtv, equalityTypeStatus as T.EQUALITY_TYPE_STATUS status), ls, deps, ids)):: cs') l = |"

  If we look up equalityTypeVar in the unification state and it doesn't
  exist, then the process is straight forward, we just add it to the
  unification state, with the constraint of its equality type status.

  In the event that the equalityTypeVar does actually already appear in
  the state then we create a new constraint of the equality type
  variable from the dependancy that was existing in the state and the
  equality type status, and then we go off and solve it.

  There are two things to still do here. Firstly, the equality type
  status should probably go in the state, replacing the dependancy that
  was there (though we will still need to create the new constraint and
  solve it, to check there aren't any equality type errors), and
  secondly when creating this constraint the labels are joined together
  (shown below with labs@ls), but the deps and the ids remain the
  same. There is something called deps in the dependancy that we see
  already existing in the state, should they be unioned too?
  Possibly. Something to look into.

  Relevant code excerpt:

  \| SOME (T.EQUALITY_TYPE_DEPENDANCY (eqTypeVarDep, labs, stts, deps) =>
  let
  (* jpirie: what about stts and deps? Should these be combined somehow? *)
  val c = E.EQUALITY_TYPE_CONSTRAINT ((T.consEQUALITY_TYPE_VAR eqTypeVarDep, T.EQUALITY_TYPE_STATUS status), labs@ls, deps, ids)
  (* jpirie: what about putting the new status in the map? *)
  in
  fsimplify (c::cs') l
  end

** First year report [75%]
*** DONE (2012-06-29-14:47) Overview [100%]
**** DONE (2012-06-29-14:49) Moving sections around

There's quite a lot of information in here, maybe this just isn't
really an overview any more. Can some of this information be moved to
other sections of the document? It's a bit all over the place isn't it?

**** DONE (2012-07-03-09:31) A simple example

Some of the text under the simple example heading is a bit messy, this
should really be cleaned up. It would be nice also to get some LaTeX
code which will display highlighting like it does in the Emacs user
interface, which would save me some space instead of including lots of
screenshots. This isn't really a problem for this document but it's
something that I will need to sort out for the thesis document.

*** TODO (2012-06-29-14:47) Literature review [28%]
**** DONE (2012-06-29-15:39) Haack and Wells

     There's plenty to talk about with respect to this paper, look at
     what I've got there again and clean it up.

**** DONE (2012-06-29-15:35) Variable name completion paper

     A literature review on this has still to be written up

**** TODO (2012-06-29-15:41) An efficient unification algorithm

     That's WAY too much detail, surely. I know this information came
     from a previous report that I'd written, so perhaps I included
     that verbatim. Nevertheless I need to work out what I can cut out
     of this explanation and then add some explanation in about how
     the ideas of this paper could be implemented to improve the way
     that Skalpel handles certain things.

**** TODO (2012-06-29-15:43) Higher order unification and macthing

     Again, there is probably too much information in here. Some of
     this information can come out most likely. Remember, it's great
     if I can put in there how ideas from the literature can improve
     Skalpel.

**** TODO (2012-07-12-13:24) Listening to program slices
**** TODO (2012-07-12-13:24) Seminal paper
*** DONE (2012-06-29-15:55) Review of other implementations

    A section with this kind of heading is something else that should
    probably go in this review. Why not start with looking at the
    implementation of Goo and Sasano, who wrote the paper about
    completing variable names for implicitly typed languages? Could be
    a nice start. It will be time consuming to look into other
    implementations so perhaps just a couple is the best thing to do
    here.

*** DONE (2012-06-29-14:47) First Year Work [100%]
**** DONE (2012-07-04-14:57) Analysis engine cleaning
**** DONE (2012-06-29-15:05) Equality types text

     The text about equality types needs to be updated and cleaned up
     to the point where I am at the moment. Ideally, the information
     that I'm putting in there should just be an improvement on the
     work that I was talking about in the research log entries.

     I thought about extending the representation that we have in the
     paper to put the work that's going on with equality types, but
     would that be a world of hurt? The amount of definitions I would
     need to put into this document would be high (although, then it
     would be something that we could use to update the paper and
     ultimately something that would stay around to be put in my
     thesis? Might need to ask Joe about that. Hmm.)

**** DONE (2012-07-04-14:57) Automated testing
**** DONE (2012-07-04-14:58) Neutral language representation of date
**** DONE (2012-07-04-14:58) Public repository
*** DONE (2012-06-29-14:47) Future Targets [100%]
**** DONE (2012-06-29-15:12) Equality types future text

     I expect not to finish equality types before whatever time I am
     asked to submit this document. I need to reach a point where I'm
     going to decide to stop (is that now? Next week?) and write text
     that I then do not change before handing the document in.

     So this text needs to updated with the list of things that we
     don't yet handle (which should probably also be present in this
     document by the way!) and discuss what might be needed to make
     that happen. It might be best not to talk to technically about
     what specific changes I'm going to make, as anybody not very
     familiar with the source code won't stand any real chance of
     getting an acceptable level of understanding from that? Think
     about this.

**** DONE (2012-06-29-15:16) Sharing future text

I'm not working on the sharing feature at the moment, and I won't be
before handing in this report. Clean this text up so that it covers
the idea of sharing, and then leave it.

**** DONE (2012-06-29-15:18) Other languages future text
     The idea of supporting other languages is something that we have
     been thinking about for a while, but we're not at the point that
     we can go off and do this yet. There are many considerations to
     be made. In this section give an overview of the challenges that
     we'd face and the kind of changes that Skalpel would need to go
     through to do this.

*** DONE (2012-06-29-14:47) Conclusion [100%]
**** DONE (2012-06-29-15:20) Time estimates

It would be nice to give time estimates (in fact, this may be required) of
how long I estimate each thing I need to do next will take me (it will
be ultimately wildly inaccurate irrespective of how long I spend
thinking about it but it's the kind of thing that should go in the
report anyway).

I guess if I'm going to do this then some sort of Gantt chart is
probably in order.

*** TODO (2012-06-29-14:48) Referencing

General referencing needs to be done for the document.

I haven't put anywhere in the document yet text describing that
it was Vincent that has written most of the implementation for Skalpel
so far. That would be good to put in, and there should be references
made to his thesis, there is a good amount of information in there.

*** DONE (2012-07-03-11:35) Other [100%]
**** DONE (2012-07-02-11:54) Indentation for lstlisting

At the moment the indentation that lstlisting uses is way off to the
left. This should not be the case, as it looks quite odd with the text
indented above it. Perhaps force indentation with \indent? Not
sure. Look into this.

** Other
*** TODO (2012-06-29-13:04) Get access to paper sources from Vincent

  He's currently working on this. The plan at the moment is to commit
  the paper to the Skalpel repository, so when he has some free time
  that should pop up in this repository.

*** TODO (2012-07-02-16:37) Add titles to research log entries

If a future developer reads this and is looking for some extra
information that for some reason doesn't exist anywhere else (though
this should never be the case for technical information), and this
file actually gets used for the rest of my PhD, they might actually
need to read some of these research entries where I throw in musings
on various bits of information. If they don't have titles, the reader
will die of boredom as I witter endlessly about things that they don't
want to hear about, so it might be a good idea to tag them with
'implementation: equality types' or 'first year report' or
something. Something to think about in any case.

* Research logs
** 2012-06-26

When we see an equality type variable (''a) we generated this:

val c   = E.initEqualityTypeConstraint (T.consEQUALITY_TYPE_VAR eqTypeVar) (T.EQUALITY_TYPE_STATUS(T.EQUALITY_TYPE)) lab

We still get the equality type error when this is constrained to be
NOT_EQUALITY_TYPE instead of EQUALITY_TYPE. Is the equality type error
actually really coming from here? If not, that explains the problem
with the missing label, because that's not where the equality type
error is coming from! I need to find the location where the equality
type error is coming from, and fix that (because it's likely wrong),
then we should get the label that's missing.

** 2012-06-27

The error was not coming from the equality type variable, and rather
from a constraint EQUALITY_TYPE value that I had in for testing
purposes. This has to be updated. This is the reason that I have
started this research log, because when making quick changes for
debugging reasons, it's hell on earth to remember which changes in
which files I've actually made to temporarily aid debugging. It is
important to remember this information as it leads to problems later
on.

The problem currently is between the binder and the accessor. When we
are solving the accessor, we look up the binder, but we do not get all
the information that we need. We get most of it, but not all.

When we look up the binder we get something like this:

bind = TYPE_DEPENDANCY(TYPE_CONSTRUCTOR((n1,DECLARATION_CONS(0),l40154),ROW_CONSTRUCTION([FIELD_CONSTRUCTION((1,l40154):TYPE_DEPENDANCY(TYPE_VAR(t31850,-,POLY,UNKNOWN),[40157],[],[]),l40154),FIELD_CONSTRUCTION((2,l40154):TYPE_DEPENDANCY(
TYPE_CONSTRUCTOR(TYPENAME_DEPENDANCY((n242,DECLARATION_CONS(1692),l40144),[40143,40144],[],[]),ROW_DEPENDANCY(ROW_CONSTRUCTION([FIELD_CONSTRUCTION((1,l40145):TYPE_VAR(t31854,-,POLY,UNKNOWN),l40145)],-,l40145),[40143,40144,40145],[],[]),l
40143,UNKNOWN),[40143],[],[]),l40154)],-,l40154),l40154,UNKNOWN),[40154,40155,40156],[],[])

We see in the last part of the TYPE_CONSTRUCTOR tuple we have an
UNKNOWN. Perhaps the solution would be to make this an
EQUALITY_TYPE_DEPENDANCY with an equality type variable which comes
from the datatype declaration. Then we would be able to use that when
generating constraints at the point that we solve the accessor.

Perhaps we should really have a different binder altogether for
equality types, and when we solve the accessor we get an equality type
dependancy with the equality type variable inside. It's rather
convenient the way it is though.

(2012-06-27-15:10)

Added warning in the warnings section as am constraining constyarrow
to always be an EQUALITY_TYPE. I think it's this construction that
will change the last value in the tuple from UNKNOWN to
EQUALITY_TYPE. If this is the case then I can look at where
constyarrow is being constructed and locate where the equality type
variable should go in.

(2012-06-27-15:17)

It is indeed the case that this is what causes the last part of the
tuple to change. Going to look through and find out which constyarrow
construction is generating this new EQUALITY_TYPE tuple value in the
constraint generator, when I find that I should hopefully be able to
switch it to an EQUALITY_TYPE_VAR with a variable from the datatype
definition and we should get the right error.

(2012-06-27-15:28)

There is now a a constyarrow'Eq (these names in Ty.sml really need
changing) which forces an EQUALITY_TYPE_STATUS given as a parameter
when generating a type arrow constraint, and constyarrow' has been
reverted to its normal state.

(2012-06-27-16:09)

There were some places in the code where we were checking the equality
type status that was in the TYPE_CONSTRUCTOR datatype constructor and
checking if it was the same as another TYPE_CONSTRUCTOR's value. This
code will need to be rewritten to handle this, for the moment
detection of this old kind of error is commented out. Some eq-test
files which I have will now not detect errors, so I'll have to go back
and make some of them work.

(2012-06-27-16:34)

So now the equality type variable from the datatype definition is
available when we solve the equality type accessor, but an error is
still not detected. The link that is missing is when solving two
equality type variables. There is enough information in the state now
for Skalpel to figure out that there is an equality type error, but
the code which solves the constraint of two equality type variables
will need to be extended.

(2012-06-27-16:38)

I think it's the case when solving two equality type variables that
we're not sure what to do when both of them already exist in the
map...

** 2012-06-28

(2012-06-28-00:38)

It's not actually the case the analysis engine is stuck because an
equality type variable is being mapped to two things. Here's what
happens in a run of eq-test14.sml, which looks like this:

datatype ''a mydt = firstCons of int | secondCons of ''a;
secondCons(5.0)

We generate equality type variables for anything which can later turn
out to be an equality type error, and in the constraint generation
stage we constraint equality type variables to be equal to other
equality type variables. In some places we generate equality type
status values (EQUALITY_TYPE, NOT_EQUALITY_TYPE, or UNKNOWN), which
equality type variables are then constrained to be.

So in the shown code example, the constraint solver does the following
solving with respect to equality types:

(EQUALITY_TYPES) Unification.sml: solving an equality type constraint of EQUALITY_TYPE_VAR(eqtv17709) and EQUALITY_TYPE_VAR(eqtv17708). Labels = [40150]
(EQUALITY_TYPES) Unification.sml: solving an equality type constraint of EQUALITY_TYPE_VAR(eqtv17713) and EQUALITY_TYPE_VAR(eqtv17712). Labels = [40154]
(EQUALITY_TYPES) Unification.sml: solving an equality type constraint of EQUALITY_TYPE_VAR(eqtv17712) and EQUALITY_TYPE_VAR(eqtv17711). Labels = [40157]
(EQUALITY_TYPES) Unification.sml: solving an equality type constraint of EQUALITY_TYPE_VAR(eqtv17711) and EQUALITY_TYPE_STATUS(EQUALITY_TYPE). Labels = [40158]
(EQUALITY_TYPES) Unification.sml: solving an equality type constraint of EQUALITY_TYPE_VAR(eqtv17712) and EQUALITY_TYPE_STATUS(EQUALITY_TYPE). Labels = [40157,40158]
(EQUALITY_TYPES) Unification.sml: solving an equality type constraint of EQUALITY_TYPE_VAR(eqtv17713) and EQUALITY_TYPE_STATUS(EQUALITY_TYPE). Labels = [40154,40157,40158]
(EQUALITY_TYPES) Unification.sml: solving an equality type constraint of EQUALITY_TYPE_VAR(eqtv17718) and EQUALITY_TYPE_VAR(eqtv17717). Labels = [40160]
(EQUALITY_TYPES) Unification.sml: solving an equality type constraint of EQUALITY_TYPE_VAR(eqtv17714) and EQUALITY_TYPE_VAR(eqtv17718). Labels = [40160]

These are the constraints that we need to solve which were generated
from the first line of the code. When we constrain equality type
variables to be the same as other equality type variables, this is
stored in the internal state as an EQUALITY_TYPE_DEPENDANCY, which can
take as the first argument of its tuple an equality type variable, the
other arguments being label information, and some other arguments. The
reason we store these in the state as a dependancy and not directly as
an equality type variable is so that we can put label information
along side this information which provide program points WHY an
equality type variable is constrained to another equality type
variable.

So we have 17709 constrained to 17708, 17713 constrained to 17712,
17712 constrained to 17711, and 17711 constrained to
EQUALITY_TYPE. Aha! If that's the case then both 17712 and 17713 are
constrained to be equality types also! So when we see an equality type
variable being constrained to an equality type status, we look in the
state to see if that equality type variable is dependant on other type
variables. When we see this constraint:

(EQUALITY_TYPES) Unification.sml: solving an equality type constraint of EQUALITY_TYPE_VAR(eqtv17711) and EQUALITY_TYPE_STATUS(EQUALITY_TYPE). Labels = [40158]

We look up the state to see if other equality type variables are
dependancy on equality type variable 17711 and sure enough we see that
there are, 17712. We then generate a constraint that 17712 have the
same equality type status that 17711 is currently being constrained
to, and go to solve that along with the rest of the other
constraints. This works its way back up the equality type variable
constraints until it reaches the point where we discover that two type
variables are constrained to be the same, but both are mapped to
dependancies on differing EQUALITY_TYPE_STATUS values, at which point
we generate an equality type error, or we reach the point where we
encounter the point where we have an equality type variable which
isn't mapped to anything (as is the case with 17713 in the constraint
solving process above).

Alright so here things get a little bit more complicated, in the first
line of the code we generate a binder so that we able to reference
things in the first line of the code (the datatype constructor names
for example, in other lines of the code). When we reference datatype
constructor names for example, as indeed we do in line two of the
code, we have to solve the accessor. Here's what that looks like.

(EQUALITY_TYPES) Unification.sml: solving an equality type accessor. Labels = [40161]
sem = EQUALITY_TYPE_VAR(eqtv17714)
id = 1695
bind = TYPE_DEPENDANCY(TYPE_CONSTRUCTOR((n1,DECLARATION_CONS(0),l40154),ROW_CONSTRUCTION([FIELD_CONSTRUCTION((1,l40154):TYPE_DEPENDANCY(TYPE_VAR(t31850,-,POLY,UNKNOWN),[40157],[],[]),l40154),FIELD_CONSTRUCTION((2,l40154):TYPE_DEPENDANCY(
TYPE_CONSTRUCTOR(TYPENAME_DEPENDANCY((n242,DECLARATION_CONS(1692),l40144),[40143,40144],[],[]),ROW_DEPENDANCY(ROW_CONSTRUCTION([FIELD_CONSTRUCTION((1,l40145):TYPE_VAR(t31854,-,POLY,UNKNOWN),l40145)],-,l40145),[40143,40144,40145],[],[]),l
40143,EQUALITY_TYPE_STATUS(UNKNOWN)),[40143],[],[]),l40154)],-,l40154),l40154,EQUALITY_TYPE_VAR(eqtv17713)),[40154,40155,40156],[],[])

In the last argument of the top level TYPE_CONSTRUCTOR datatype
constructor instantiation we see that there is some equality type
information available: EQUALITY_TYPE_VAR(eqtv17713). This is providing
us with an equality type variable from the first line which we can use
to generate constraints with. So when we see as follows:

(EQUALITY_TYPES) Unification.sml: solving an equality type constraint of EQUALITY_TYPE_VAR(eqtv17714) and EQUALITY_TYPE_VAR(eqtv17713). Labels = [40154,40155,40156,40161]

So here we have two numbers- 17714 and 17713. 17713 has already been
described, it comes from the first line of the code (specifically, the
ConBindOf function of Analyze,sml, where we generate the constraints
for new datatype constructors. The 17714 number comes from the
f_longidexp function of Analyze.sml, which is the point at which we
generate the equality type accessor constraint. While generating this
equality type accessor constraint, we feed this number in, and so we
end up with the equality type variable 17714 being constrained to be
the same number as 17713. We go on to solve the following further
constraints.

(EQUALITY_TYPES) Unification.sml: solving an equality type constraint of EQUALITY_TYPE_VAR(eqtv17717) and EQUALITY_TYPE_VAR(eqtv17716). Labels = [40162]
(EQUALITY_TYPES) Unification.sml: solving an equality type constraint of EQUALITY_TYPE_VAR(eqtv17716) and EQUALITY_TYPE_VAR(eqtv17715). Labels = [40163]
(EQUALITY_TYPES) Unification.sml: solving an equality type constraint of EQUALITY_TYPE_VAR(eqtv17715) and EQUALITY_TYPE_STATUS(NOT_EQUALITY_TYPE). Labels = [40164]
(EQUALITY_TYPES) Unification.sml: solving an equality type constraint of EQUALITY_TYPE_VAR(eqtv17716) and EQUALITY_TYPE_STATUS(NOT_EQUALITY_TYPE). Labels = [40163,40164]
(EQUALITY_TYPES) Unification.sml: solving an equality type constraint of EQUALITY_TYPE_VAR(eqtv17717) and EQUALITY_TYPE_STATUS(NOT_EQUALITY_TYPE). Labels = [40162,40163,40164]
(EQUALITY_TYPES) Unification.sml: solving an equality type constraint of EQUALITY_TYPE_VAR(eqtv17718) and EQUALITY_TYPE_STATUS(NOT_EQUALITY_TYPE). Labels = [40160,40162,40163,40164]
(EQUALITY_TYPES) Unification.sml: solving an equality type constraint of EQUALITY_TYPE_VAR(eqtv17714) and EQUALITY_TYPE_STATUS(NOT_EQUALITY_TYPE). Labels = [40160,40162,40163,40164]

So something isn't working here. We know that 17714 is of status
NOT_EQUALITY_TYPE, and that 17714 is constrained to 17713, and that
17713 is constrained to be of status EQUALITY_TYPE. The analysis
engine needs to be able to see this and detect this type error.

The problem is likely to do with the state. Part of the problem is
that it's difficult to know exactly why this problem is happening, and
this can be solved by acting on the earlier todo note on
2012-06-27. When we are checking that there are any status values that
clash, the type variables that we are solving along the way that we
set to be equal to equality type status values *should get this new
equality type status added to the map against it*. At the moment, we
just check that it's alright for the moment, and then we move on to
solve the rest of the constraints.

(2012-06-28-10:43)

Alright, whenever I see two equality type variables being constrained
to be equal to each other, but the one on the right hand side is
already in the map has an equality type status, I'm going to make it
the case that the left hand side is updated in the map to be also
constrained to be that status, where it is not mapped to a status
already. If it is mapped to a status already, then I need to check
whether there is a clash between the status values.

(2012-06-28-12:50)

AHHH that's got things going, we're getting equality type errors now
for the code fragment:

datatype ''a mydt = firstCons of int | secondCons of ''a;
secondCons(5.0)

Excellent. I'm going to go back and fix up some of the other equality
type error tests which have broken now, then maybe write up some more
details on how the equality type errors are detected in a given piece
of code if necessary.

(2012-06-28-13:18)

In the simple case of 5.0 = 5.0, the equality type error has now been
put back that was broken. This took me all of 60 seconds. It's much
easier to do things now there's a system in place (huzzah!).

(2012-06-28-15:52)

The case involving tuples doesn't work yet, I'm going to need to think
of a way to handle code like this: (1, 1.0) = (2, 2.0). The equality
type variable which represents the tuple should be constrained to be
equal to.... something. Not sure how this is going to work yet, I'll
need to have a think about this.

(2012-06-28-17:20)

Just got the analysis engine compiling again. I'm currently fixing up
the basic example:

val x = 1.0;
val y = 2.0;
x = y

The problem with this is that when we generate the NOT_EQUALITY_TYPE
status for 1.0, that information is not going into the binder when we
bind x, so subsequently when we solve the accessor in the third line
and constrain that to be an EQUALITY_TYPE, no error is discovered
because we by default get an UNKNOWN status put into the binder.

I have changed parts of the analysis engine so that equality type
variables are now propagated around more parts of the system, but I
still have to track down where this binder is situated, and put the
equality type variable representing 1.0 into that binder.

(2012-06-28-17:31)

I should really start using branches when working on this stuff. The
code broke and I want to commit it to the repository, but I don't want
to do that if the analysis engine doesn't compile (and I *will not* be
able to do that soon anyway, once I update the test framework, as if
the analysis engine cannot be compiled then the daily test e-mails
will fail, which is a situation I really want to avoid).

On the other hand it has kept me in the office another half hour to
fix the problem, so not all bad.

Skalpel has been *EXTREMELY* useful in the detection of type errors
today, in particular arity clash between functions. I was at the point
where I was about to remove all my changes and start again, because
the type error messages I was getting from the compiler were just
useless, and pointing me to silly places. Skalpel definitely saved me
probably 30-60 minutes in this case, an excellent win!

Irritating points though, when I see an arity clash, I want to see all
of the places where there are different arity. Skalpel highlights them
of course, but I have to scroll up and down the file looking for
them. It would be nice to have a button that executed the function
'jump to next bit in the file that has highlighting for the currently
selected slice'. This would be most helpful.

I have found that executing Skalpel on single files to be very
useful. What would also be nice is a 'Work on this file only' button,
where Skalpel runs on a file but suppresses any errors about undefined
identifiers.

Feels good that Skalpel definitely saved me time today. I'd MUCH
rather spend the time writing about that event here, than spent my
time stuck in a whirlwind of type errors. I'll maybe work on the first
year report this evening, it would be good to continue with that.

** 2012-06-29

(2012-06-29-12:55)

Trying to stay away from developing equality types today and stick to
the first year report, but I'm writing down while I remember it that
equality type errors should have two endpoints not one. I guess we'll
need some kind of endpoint label information in the label sets that
are generated. We already generate errors that have multiple endpoints
though I can't remember exactly how this works, I should be able to
use the same mechanism for equality type error endpoints as type
constructor clashes...

Adding this as a TODO item also.

(2012-06-29-13:12)

Just found the org-mode guide I had filed away. Will fix this document
up to make use of some of the nice org features.

** 2012-07-01

(2012-07-01-22:12)

I've updated the test framework. Now the repository will actually be
updated, a fresh binary will be generated from the new sources and the
tests will be ran on this new binary.

The compilation log has been added to the daily e-mail, so if
compilation fails we should see this in the e-mail.

Note that from this point, any source code that is pushed to the
master branch *should compile*. This has not always been the case in
the past but now it is necessary (and what should happen anyway, in
case others wish to clone the repository). Any developmental work
should be done on a branch, and then merged into the master branch
when it compiles again (it doesn't necessarily need to be stable, but
it should compile and shouldn't break lots of previous tests.

I'll try to be sure and look at the test framework output tomorrow
carefully, looking for bugs (for example, an empty e-mail or some big
error message). Hopefully I won't get some distraction that carts me
off in another direction, but I'll have the test framework e-mail to
remind me anyway.

Note that the test framework should still diff results against a
master, and not against the previous day. This is a change which still
needs to be made, and should go higher up on the priority list.

The literature review for the paper on variable name completion is
deemed to be finished, but perhaps I should talk more specifically
about their type inference algorithm? Does the reader really care?
Maybe I want to look at their algorithm in much more depth as part of
the review of other implementations (preferably in another section)?
Think about this.

** 2012-07-02

(2012-07-02-10:48)

The reports from the test framework this morning are a bit strange,
the compilation output only lists the actions of MLLex. Perhaps this
is the only thing coming to stdout (the contents of which are added to
the e-mail). Are the warnings on compilation printed to stderr because
it would be good to have these too. Fiddling around with the first
year report so don't have time to look at this at the moment, I'll
have to come back to it.

(2012-07-02-11:56)

It might be nice to have syntax highlighting in the code that's being
used in the lstlisting environment but currently that is not the
case. Is that something which I should have? It is certainly the case
anyway that I'm going to need some LaTeX code which will highlight the
background and foreground of text in all the ways that the Skalpel
output does, but I should be able to get that from the paper perhaps
when Vincent commits the sources. Something to think about anyway.

In a different note, the indentation for lstlisting is mucked
up. Added a TODO item to fix that, it looks rather bizarre. Probably
just a parameter needs to be added to the figure environment or
something.

(2012-07-02-12:54)

There are new examples of things which aren't working with equality
types that I've discussed in the future work section. I have chosen
these examples because they are unlikely to be completed by the time
this report actually needs to be read by someone sometime soon. Do
these features last (detecting equality type errors in datatype
declaration where one constructor in the declaration can never be
compared for equality (eg int -> int), and eqtype in a signature
definiton) so that this text is technically accurate for as long as
possible. There should be other things to fix up with respect to
equality types if I have the time before this gets handed in anyway,
so I'll just work on the other things.

I'm going to continue on with the future work section I think and
finish that off, so that an entire section can be marked as complete
and I can move on, or review it as a whole with Joe and find things to
change.

(2012-07-02-16:26)

Hmm, not sure whether to talk about some of this material from the
Haack and Wells paper or not, namely things like how constraints are
assigned to program points and how minimized errors are found. If I
include the proper definitions then the document may increase in size
as it'll need to cover everything relevant, but I think I'm going to
have to include at least the definitions for labels and perhaps some
parts of the constraint system to describe how equality types are
implemented properly anyway. It would also allow me to talk at more
depth about the similarities between this paper and the implementation
of Skalpel, some years on now. Many of the definitions described in
the paper are still true, even some of the things about how the
unification algorithm and minimization algorithm work. I'll think
about that.

Perhaps it would be better not to discuss these details here, but just
to launch into a big discussion when talking about how equality types
are implemented, and describe everything there that is necessary. It
would be a bit strange to have text about how minimal slices are
found under a section title about equality types though. Perhaps
instead this information should go in a new chapter called
'Background' or something, where I could explain how everything works,
and that would allow me to talk about some of the technical aspects of
the Haack and Wells paper in the later literature review chapter, by
which time I'll have already have all the definitions I need.

(2012-07-02-16:58)

Alright, what I think I'm going to do with the overview is to move
section 1.3, the other approaches to type error slicing, to some other
chapter which looks at how other systems operate, and then clean the
overview up and keep it how it is.

Then perhaps after the overview would come a background section where
I can define how the current system works? Then perhaps extend that in
the first year work section with information about how the equality
types constraint generation and unification work?

While I think about it, it would give me an opportunity to look at the
symbols from the paper and would make me think about them some more,
as I'd have to extend it a little for equality types. It would perhaps
allow me to clean up the paper too, which I'm supposed to be doing at
some very much undefined time, and the paper would eventually be
updated to include work done on equality types anyway. I'll think some
more about this anyway.

** 2012-07-03

(2012-07-03-11:28)

The overview for the first year report is marked done, I'll maybe look
at bits of that with Joe in the next meeting. I still have a manual
page break on page 3 of the document, there's warning to this effect
but it would be good to sort that out. Referencing still needs to be
done also for the document, I guess I'll do that at the end after I've
finished writing the body of the text.

Vincent still hasn't been mentioned in this text, the work that he
did should be pointed out explicitly. A reference to his thesis will
also be needed. I'll add this to the TODO.

(2012-07-03-22:51)

Good lord, the Goto and Sasano implementation actually worked straight
away, kudos to them for having a system I can set up and get working
in under two minutes. It is indeed implemented entirely in Emacs lisp
though, and I guess the comments in what seems to be Japanese aren't
going to give me too much help on the matter.

The method that they have for allowing users to choose different
selections is very intuitive, though I don't think we can use this
mechanism to our advantage at this current time in Skalpel.

(2012-07-03-23:43)

Their tokenizer suffers from the magic numbers bad smell, I should
check we don't have the same smells in our grm file.

(2012-07-03-23:55)

I can see why they don't support much of the SML feature set, they're
in for a fair bit of engineering trouble if the implementation keeps
heading this way. I assume that they aren't actually wanting to end up
supporting all of the sml programming language in this way, it would
be pretty insane.

subst1, subst2, subst3, subst4?? AAAAHHH *flashbacks*. The code looks
to be pretty well written on the whole though, it's a bracket-fest but
that's to be expected. This car/cdr/caar/cdar stuff is driving me
batty, whoever chose those as names must surely be a masochist.

The 'unify' function in lambda-unification.sml is essentially their
constraint solver. Skimming over it, looks like they have cases for if
the left hand side and the right hand side are arrow types, if the
left hand side is a basic type and the right hand side is an arrow
type, and the same the other way around. I'll need to read over parts
of the paper again and try and match up what they have in the paper
with what the have in the implementation, which hopefully will not be
greatly difficult. I guess it'll depend whether what they have in
their paper accurately reflects their implementation...

** 2012-07-04

(2012-07-04-09:41)

Does this implementation by Goto and Sasano have both the W and V type
inference algorithms? They have something here for the W algorithm but
I'm not sure this algorithm would stand up on its own, perhaps it's
there solely to be used with the V algorithm. Trying to figure that
one out...

(2012-07-04-11:44)

Ok, it looks like they have implementations of both the W and V
algorithms. During the V algorithm they seem to run the W algorithm
when it comes to function applications:

;;function application
((appExpD-p expD)
 (let* ((result-for-m (type-inference-w env (appExpD-fun expD)))
 (result-set-for-d (lambda-type-inference-v 
      (apply-subst-to-env env (w-result-subst result-for-m))
      (appExpD-argD expD)))
 (result-set (map-set
'(lambda (x) 
   ;;When unification fails, the function unify throws an error with nil, which becomes the value of this catch expression.
   (catch 'error 
     (let* 
	 ((new-tyVar (varTy (freshTyVar)))
	  (S3 (unify (singleton-set (cons
				     (apply-subst-to-type (w-result-type result-for-m) (v-result-subst x))
				     (arrowTy (v-result-type x) new-tyVar))))))
       (v-result
	(union-subst S3 (union-subst (v-result-subst x) (w-result-subst result-for-m)))
	(apply-subst-to-type new-tyVar S3)
	(v-result-c x)))))
result-set-for-d)))
   (set-compact result-set))) ;;remove nil

That's alright. I suppose they don't need much more than the W
algorithm anyway, if there's a type error you aren't going to want to
include it in the suggestions list are you (well, we might want to do
that, but maybe highlight that suggestion in red or something and when
you hover over it get the slices showing why that choice would make
the code untypable, who knows).

** 2012-07-06

(2012-07-06-10:21)

Reading these papers is turning me into a zombie, going start doing
some more of the equality types implementation, then write up text
about that in the first year report afterwards.

(2012-07-06-12:16)

Have added a warning in to the warnings section, working on fixing a
test that broke. Note that in Ty.sml the constyarrow' equality type
status is fixed to be NOT_EQAULITY_TYPE.

(2012-07-06-12:28)

Warning removed. New warning added for fixing reals to be of
NOT_EQUALITY_TYPE status when creating the type constraint.

(2012-07-06-14:53)

This is causing the constraint solver to crash, likely because of the
previous warning about reals constrained to be NOT_EQUALITY_TYPE in
the last parameter of the type constraint initialization. I didn't
design this part of the constraint solver to accept this, and rightly
so, this should be an equality type dependancy if I remember correctly
(the other log entries and code seem to indicate that this is the case
also).

I'll make this a dependancy on the equality type variable that is
created in the SconReal function during constraint generation... that
should do the trick right?

Note that the endpoints still have to be fixed up. It might be nice
to finish up fixing the tests that I have to a good point, then start
looking at getting the endpoints right. Then after this is done I can
commit the equality type tests I have to the test database and get
them running daily for breakages.

This might be a nice point to extend the test framework a bit so that
the equality type tests sit in an equality-types/ folder inside the
suite of tests, rather than them being given the next point in the
enumeration sequence, which doesn't tell us much of anything.

Perhaps something like

equality-types/01-just-real-numbers.sml
equality-types/02-reals-inside-tuple.sml
equality-types/03-two-reals-with-variales.sml
equality-types/03-one-real-variable-self-test.sml
equality-types/04-real-and-variable-in-let.sml

or something, ideally clearer if possible and can be done without a
stupidly long file name. Just think about it. Oh, at the same time do
get the test framework working off a master file instead of the one
yesterday, and don't generate log files for tests which are the same
as the master. Much less test files in the repository that way. Some
kind of confirmation that the test suite ran though would be handy.

(2012-07-06-15:25)

I'm changing the TYPE_VAR constructor to take something of
equalityType in the last element of its tuple rather than an
equalityTypeStatus, be aware that this is going to affect compilation
pretty hard...

(2012-07-06-15:35)

Forcing the stripEqualityStatus (TYPE_VAR [...]) case to return an
empty list as its first element, this used to be eq. Adding a warning,
this should let me figure out where the errors are much more quickly.

** 2012-07-09

(2012-07-09-08:16)

Going to continue on with equality types for at least part of today,
then I'll have to work on the first year report. Most of this should
be at some sort of standard but the literature review still needs
work. Need to get the date when this is actually needed to be
completed, so I can get it out of the way and get on with finishing
equality types and move on.

(2012-07-09-10:05)

Is stripEqualityStatus actually needed in Ty.sml? We seem to use it in
the Env.sml file and in Unification, but I'm not totally convinced
that we actually need that any more...

(2012-07-09-10:40)

Actually, we don't use stripEqualityStatus in Env.sml, we have a
function which will indirectly use it though, but that function itself
is actually never called.

I'm going to try and remove this, if all hell breaks loose then I'll
put it back :o). I'm pretty sure this is something left over from a
previous way that equality types were represented

(2012-07-09-11:24)

I think the removal of stripEqualityStatusFromConstraints in Env.sml
went alright, that was one of the dependancies on stripEqualityStatus
in Ty.sml. There are two other calls to this function if I remember
correctly in the unification algorithm, if they aren't needed either,
or are in places where I am fixing the old code, then I can remove
this section of code.

This is important as it is this location where quite a few of the
compilation errors are coming from.

(2012-07-09-12:22)

stripEqualityStatus is actually used when solving equality type
accessors, I'm going to fix up that bit of the code for now, but it
might be an idea to think about moving it into the unification
algorithm if it's not needed anywhere else.

(2012-07-09-12:59)

I'm removing all the old equality type checks that we used to do (eg
in the case of TYPE_VAR and TYPE_VAR check that the eq properties were
the same, as we should now be checking all this information with
equality type variables (each constraint to a status).

(2012-07-09-14:43)

I'm suffering this problem again where the unification algorithm says
"Yes, I see the error!" then runs itself again, doesn't find the error
the second time around, realise that it should, and dies.

I'm still not quite sure what causes this problem, I thought it was
when there was a label missing but I don't think that's the case any
longer....

(2012-07-09-15:04)

It occurs to me that this problem with the repeated unification run
problem may indicate a problem with the unification algorithm, and
that it is *not* a problem with the constraint generation
algorithm. I'm not sure if this is definitely the case, maybe the
problem may still lie with the constraint generation algorithm, but if
it detected the equality type error once, then the constraints
generated are actually correct surely? It's what we take out for the
repeated runs that's wrong?

(2012-07-09-17:38)

Just had a thought, the second set of labels that I was talking about
in the warnings... is this the set of labels that I always found to be
empty about a year ago? It wasn't confirmed to be always empty but
that was what was suspected, look into confirming this. Perhaps run
the entire test database with debug output then see if any of the deps
have values? Note: A script will be needed to do that, the volume of
the output is far too large to be done by hand.

(2012-07-09-23:44)

Still on this problem with the unification algorithm falling over on
the second run. The problem is that I don't know what the real error
is for certain. The initial error was 'The error should be an error'
which I've changed to the current understanding which I've got now.

** 2012-07-10

(2012-07-10-00:08)

It looks like the labels are correct, so why is this failing on the
next run? It looks to me like for some reason the accessors are being
solved incorrectly on the next run, when we look up the binder we
don't get the same binding the second time around.

(2012-07-10-00:57)

Got it, it was indeed a missing labels problem, there were labels that
were available from the TYPE_DEPENDANCY constructor but were not being
included, so I just unioned those labels with the labels that we had
already and the unification algorithm seemed perfectly happy to
continue.

I'm going to change the error that the unification spits out so that
it recommends that the developer look into missing labels, while I'm
not certain that this is always the case this is what I suspected
initially, and what it has turned out to be so it's a pretty good
guess.

Straight back to the first year report tomorrow, I think I'll try to
write up how current things work with respect to equality types, at
least in some shape or form, and try and write the conclusion which
should just leave me with the literature review to do before I can put
it aside until I speak to Joe.

Fairouz has offered to read some of the first year report, might be an
idea to do this as another pair of eyes can't possibly hurt. I might
do this tomorrow if I think it looks alright.

(2012-07-10-01:06)

Alright I've updated the error message that comes out in the
minimisation algorithm to give a hint to the developer that the
problem may be in the propagation of labels in the unification
algorithm. Hopefully this will help someone else, I'm sure I'll need
to know it again.

Committing this to the repository, this work wasn't done on a branch
but it really should have been. It would be good to start using
branches for the work that I'm doing and then pushing the unstable
changes to those branches, then the latest changes get backed up in
the repository but the main branch will still compile fine for
everyone.

(2012-07-10-12:20)

It's worth pointing out that the bug joe pointed out around line 3 in
the code:

val x = 1.0;
val y = 2.0;
if x = y
[...]

where the spaces in 'x = y' were not getting highlighted is now
fixed. This must have come from the newer way that things are
represented. I like it when bugs get fixed for free. I'll update the
screenshot that's going in the first year report.

(2012-07-10-14:20)

I'm not sure how to describe the way that equality types that have
been implemented. I don't know if I really want to drag in all the
definitions from the paper and do a full explanation with that. I
think I might just explain an overview of how it works without talking
about how the binders have been extended to hold equality type status
values, accessor solving has been extended to solve these equality
type status values, etc.

(2012-07-10-16:26)

The overview has been updated to describe the analysis engine even
though it was already marked completed. I'm going to use this
definition in the first year work section, breaking off to describe
the whole analysis engine there seemed to be a little out of place.

(2012-07-10-18:48)

Alright I've put in some text about the work that's been done on
equality types. I'm marking that section as 'DONE' and moving on to
the literature review / review of other type systems. I would ideally
like to finish one of these sections today but they are things that I
could spend months working on, so I'll just try to draw a line at a
sensible place.

I've started placing figures HERE. Not 'here' [h] but HERE [H] using:

\usepackage{float}
\restylefloat{figure}

in the preamble. Seems to stop latex doing completely silly things
like filling the rest of the page with text then placing the figure on
the next page when that is very much not desired.

(2012-07-10-23:00)

I've finished off some text for the conclusion now as well, but I
still need to think about some dates for a timetable. I guess I'll
just take two years from now as a thesis submission date, an equality
types completion date, sharing completion date, and fill in the
blanks. It's quite hard to guess this kind of thing but I guess it's
to think more about what's ahead than create anything which is accurate.

** 2012-07-11

(2012-07-11-13:46)

I've figured down some rough dates for things to be completed by
for the first year report, the text has been updated accordingly.

** 2012-07-12

(2012-07-12-01:59)

I'm trying to get this implementation for Seminal working so I can
talk a little bit about it in the first year report, I'm using
compiler sources from about 6 years ago so I expect there'll be a bit
of trouble on the way along.

Note that in the sources for the ocamlc compiler configuration script,
if you want to install to a certain prefix then you have to go in to
the script and add that in manually, the --prefix parameter is not
supported (well actually it looks like there is some kind of attempt
made there to support this, but I'm not going to start trying to fix
it at this, I just hacked it to make it work for what I need it to do
right now).

(2012-07-12-02:13)

Hm I seem to have constructed an example where Seminal suggests that a
function be changed so that it throws away its second argument so that
it won't cause a type error. I guess that's valid, but isn't it a
little unlikely that it's what the user actually wished to do?

I think I'll put this example in the first year report.

(2012-07-12-11:03)

Oh I forgot that the comments for this lambda-mode were in
Japanese. Curses! Plan is to clean the other-implementations.tex text
up, maybe add something to the text about lambda mode, then send bits
of text out to be proof read. Must e-mail Joe and ask when he wants
this report at some point today too, it can really be finished off at
any time.

Perhaps I should just get it to a finished state today and send that
out, then if Joe doesn't want it yet then I can just keep extending
the text, the literature review and so on, until he does want it. That
might be best actually, it would be good to get back on to the
implementation and keep pushing on with equality types. Hm.

I guess I should make some viva slides too, that sounds like the kind
of thing that might be necessary. Should be straight forward to do,
maybe I should get that done tomorrow if I get the report finished off
and sent out today...

(2012-07-12-12:54)

I've added some more comments to the text that existed which reviewed
λ-mode. I'm going to mark that as 'DONE' for now, so I can move on to
the literature review and get that cleaned up. Hopefully I'll be able
to look over everything at the end of the day.

Fairouz asked to look at some of the text, so I've sent her what I've
got at the moment. Hopefully she'll be able to look over the overview
if she has time.

Going to work on the literature review for the rest of the day and get
that text cleaned up, it needs much more love than it's currently had...

* Next meeting with Joe

- Emacs interface calling compiler binary alongside Skalpel?
- (switch-buffer) defadvice to not create new buffer?
- ask about any news on viva date, must be sometime soon?
- resits for foundations 2 and formal spec?
- dates on David Corne's website for first year report valid?
- Asking the user to submit automatically sml code for skalpel database?
