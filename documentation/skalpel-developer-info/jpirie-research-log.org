* WARNINGS

When I'm doing unioning of labels, say when I'm doing something with
EQUALITY_TYPE_DEPENDNCIES, I don't touch the other arguments of that
datatype constructor (the deps, and the ids values). This may cause
problems later, be aware that there may be work that needs to be done
here.

As soon as a chance is available, maybe print out these values to see
what they contain, so that I can figure out how important it is to
take care of these values.

Actually, now I think about it, isn't deps a second set of labels?
Perhaps I can use this to track endpoints properly, as at the moment
equality type errors are only defined to have one endpoint, and it
should do something like a type constructor clash where there can be
multiple.

* TODOs
** Test framework [20%]
*** DONE (2012-06-29-12:59) Test framework fetching and compiling latest binary

  I *must* update this aspect to the test framework soon, ideally
  today. I see this is the currently most important aspect which is
  missing with respect to testing, as I often don't have time to do
  this manually (though I am running the binary through the tests we
  have and diffing the output myself to make sure everything hasn't
  exploded).

*** TODO (2012-06-29-12:59) Test framework detecting diffs from previous runs

  When sending e-mails, the test framework is showing differences
  between the tests today and the tests the previous day, so if I don't
  read the results from the test framework on any given day, when I read
  it the next day I won't see this information.

  We should diff the results against a master copy, which can be
  updated manually when we're satisfied things are working probably,
  or better in some way.

*** TODO (2012-07-02-16:45) Daily package building

Packages should be built daily by the test framework, and a report
should be generated whether it was possible to build the package or
not. As the test framework runs on a red hat system it is not possible
to generate say the debian packages, but we are still able to generate
quite a few of them.

*** TODO (2012-07-02-16:46) Daily package testing

The packages that are built should also be installed and tested, and
the results of all of this should end up in the e-mail that gets sent
out in the morning. Wouldn't it be nice just to decide we were going
to release one day and just do it? :-)

*** TODO (2012-07-02-16:48) Test Emacs front end works

We should test also the Emacs front end. It would somehow need to be
started with a Standard ML source file open, have the type error slice
run on that file, and check that Emacs is highlighting things inside
the file, and that the process terminates.

** Equality types implementation [20%]
*** TODO (2012-06-28-16:00) Generating equality constraints for tuples

    The case involving tuples doesn't work yet, I'm going to need to
    think of a way to handle code like this: (1, 1.0) = (2, 2.0). The
    equality type variable which represents the tuple should be
    constrained to be equal to.... something. Not sure how this is
    going to work yet, I'll need to have a think about this.

*** TODO (2012-06-29-21:19) Detection of equality type error where 'eqtype' is in a signature

    In the case where we have 'eqtype x' in a signature (instead of
    what could be 'type x') an equality status constraint of
    EQUALITY_TYPE should be generated for x (obviously). Then if the
    user is to do something like 'val y : x = 5.0' then an equality
    type error should be output by Skalpel, the EQUALITY_TYPE status
    of x clashing with the NOT_EQUALITY_TYPE status of the 5.0.

*** TODO (2012-06-29-21:36) Detection of equality type error where ''a is involved in a signature

    If we have a function signature definition such as "val f : ''a ->
    ''a" we should detect an equality type error if something that
    isn't an equality type is given as an argument.

    It may be the case that this already works, which would indeed be
    lovely, but the world often isn't that kind. Check this out, it
    should only be the constraint generation phase that needs to be
    changed, and not the constraint solving, though I'm not absolutely
    certain of that.

*** TODO (2012-06-29-21:46) Add in equality type status constraints for types other than real

    Currently the NOT_EQUALITY_TYPE status is only generated for the
    real type. This status should be inserted in the constraint
    generation stage for other types (in functions and exceptions for
    example).

*** DONE (2012-06-27-01:33) Seeing a type variable being constrained to be the same as a status

  During unification we have the case of equality type variables being
  constrained to equality type statuses. This happens in the function:

  fsimplify ((E.EQUALITY_TYPE_CONSTRAINT ((equalityTypeVar as T.EQUALITY_TYPE_VAR eqtv, equalityTypeStatus as T.EQUALITY_TYPE_STATUS status), ls, deps, ids)):: cs') l = |"

  If we look up equalityTypeVar in the unification state and it doesn't
  exist, then the process is straight forward, we just add it to the
  unification state, with the constraint of its equality type status.

  In the event that the equalityTypeVar does actually already appear in
  the state then we create a new constraint of the equality type
  variable from the dependancy that was existing in the state and the
  equality type status, and then we go off and solve it.

  There are two things to still do here. Firstly, the equality type
  status should probably go in the state, replacing the dependancy that
  was there (though we will still need to create the new constraint and
  solve it, to check there aren't any equality type errors), and
  secondly when creating this constraint the labels are joined together
  (shown below with labs@ls), but the deps and the ids remain the
  same. There is something called deps in the dependancy that we see
  already existing in the state, should they be unioned too?
  Possibly. Something to look into.

  Relevant code excerpt:

  \| SOME (T.EQUALITY_TYPE_DEPENDANCY (eqTypeVarDep, labs, stts, deps) =>
  let
  (* jpirie: what about stts and deps? Should these be combined somehow? *)
  val c = E.EQUALITY_TYPE_CONSTRAINT ((T.consEQUALITY_TYPE_VAR eqTypeVarDep, T.EQUALITY_TYPE_STATUS status), labs@ls, deps, ids)
  (* jpirie: what about putting the new status in the map? *)
  in
  fsimplify (c::cs') l
  end

** First year report [28%]
*** DONE (2012-06-29-14:47) Overview [100%]
**** DONE (2012-06-29-14:49) Moving sections around

There's quite a lot of information in here, maybe this just isn't
really an overview any more. Can some of this information be moved to
other sections of the document? It's a bit all over the place isn't it?

**** DONE (2012-07-03-09:31) A simple example

Some of the text under the simple example heading is a bit messy, this
should really be cleaned up. It would be nice also to get some LaTeX
code which will display highlighting like it does in the Emacs user
interface, which would save me some space instead of including lots of
screenshots. This isn't really a problem for this document but it's
something that I will need to sort out for the thesis document.

*** TODO (2012-06-29-14:47) Literature review [16%]
**** TODO (2012-06-29-15:03) Simplifying some of the reviews

Some of the reviews in this document are WAY too big, this needs to be
taken down a peg or two.

**** TODO (2012-06-29-15:39) Haack and Wells

     There's plenty to talk about with respect to this paper, look at
     what I've got there again and clean it up.

**** DONE (2012-06-29-15:35) Variable name completion paper

     A literature review on this has still to be written up

**** TODO (2012-06-29-15:40) Discriminative sum types

     A review on this paper looks like it was started but then I got
     distracted by something else, probably work on equality
     types. Extend the explanation that I've got here, there were some
     interesting ideas in the paper and a description of some of them
     should end up here

**** TODO (2012-06-29-15:41) An efficient unification algorithm

     That's WAY too much detail, surely. I know this information came
     from a previous report that I'd written, so perhaps I included
     that verbatim. Nevertheless I need to work out what I can cut out
     of this explanation and then add some explanation in about how
     the ideas of this paper could be implemented to improve the way
     that Skalpel handles certain things.

**** TODO (2012-06-29-15:43) Higher order unification and macthing

     Again, there is probably too much information in here. Some of
     this information can come out most likely. Remember, it's great
     if I can put in there how ideas from the literature can improve
     Skalpel.

*** TODO (2012-06-29-15:55) Review of other implementations

    A section with this kind of heading is something else that should
    probably go in this review. Why not start with looking at the
    implementation of Goo and Sasano, who wrote the paper about
    completing variable names for implicitly typed languages? Could be
    a nice start. It will be time consuming to look into other
    implementations so perhaps just a couple is the best thing to do
    here.

*** TODO (2012-06-29-14:47) First Year Work [0%]
**** TODO (2012-06-29-15:05) Equality types text

     The text about equality types needs to be updated and cleaned up
     to the point where I am at the moment. Ideally, the information
     that I'm putting in there should just be an improvement on the
     work that I was talking about in the research log entries.

     I thought about extending the representation that we have in the
     paper to put the work that's going on with equality types, but
     would that be a world of hurt? The amount of definitions I would
     need to put into this document would be high (although, then it
     would be something that we could use to update the paper and
     ultimately something that would stay around to be put in my
     thesis? Might need to ask Joe about that. Hmm.)

*** DONE (2012-06-29-14:47) Future Targets [100%]
**** DONE (2012-06-29-15:12) Equality types future text

     I expect not to finish equality types before whatever time I am
     asked to submit this document. I need to reach a point where I'm
     going to decide to stop (is that now? Next week?) and write text
     that I then do not change before handing the document in.

     So this text needs to updated with the list of things that we
     don't yet handle (which should probably also be present in this
     document by the way!) and discuss what might be needed to make
     that happen. It might be best not to talk to technically about
     what specific changes I'm going to make, as anybody not very
     familiar with the source code won't stand any real chance of
     getting an acceptable level of understanding from that? Think
     about this.

**** DONE (2012-06-29-15:16) Sharing future text

I'm not working on the sharing feature at the moment, and I won't be
before handing in this report. Clean this text up so that it covers
the idea of sharing, and then leave it.

**** DONE (2012-06-29-15:18) Other languages future text
     The idea of supporting other languages is something that we have
     been thinking about for a while, but we're not at the point that
     we can go off and do this yet. There are many considerations to
     be made. In this section give an overview of the challenges that
     we'd face and the kind of changes that Skalpel would need to go
     through to do this.

*** TODO (2012-06-29-14:47) Conclusion [0%]
**** TODO (2012-06-29-15:20) Time estimates

It would be nice to give time estimates (in fact, this may be required) of
how long I estimate each thing I need to do next will take me (it will
be ultimately wildly inaccurate irrespective of how long I spend
thinking about it but it's the kind of thing that should go in the
report anyway).

*** TODO (2012-07-03-11:35) Other
**** TODO (2012-06-29-14:48) Referencing
**** TODO (2012-07-02-11:54) Indentation for lstlisting

At the moment the indentation that lstlisting uses is way off to the
left. This should not be the case, as it looks quite odd with the text
indented above it. Perhaps force indentation with \indent? Not
sure. Look into this.

**** TODO (2012-07-03-11:34) Vincent reference

I haven't put anywhere in the document yet text describing that
it was Vincent that has written most of the implementation for Skalpel
so far. That would be good to put in, and there should be references
made to his thesis, there is a good amount of information in there.

** Other
*** TODO (2012-06-29-13:04) Get access to paper sources from Vincent

  He's currently working on this. The plan at the moment is to commit
  the paper to the Skalpel repository, so when he has some free time
  that should pop up in this repository.

*** TODO (2012-07-02-16:37) Add titles to research log entries

If a future developer reads this and is looking for some extra
information that for some reason doesn't exist anywhere else (though
this should never be the case for technical information), and this
file actually gets used for the rest of my PhD, they might actually
need to read some of these research entries where I throw in musings
on various bits of information. If they don't have titles, the reader
will die of boredom as I witter endlessly about things that they don't
want to hear about, so it might be a good idea to tag them with
'implementation: equality types' or 'first year report' or
something. Something to think about in any case.

* Research logs
*** 2012-06-26

When we see an equality type variable (''a) we generated this:

val c   = E.initEqualityTypeConstraint (T.consEQUALITY_TYPE_VAR eqTypeVar) (T.EQUALITY_TYPE_STATUS(T.EQUALITY_TYPE)) lab

We still get the equality type error when this is constrained to be
NOT_EQUALITY_TYPE instead of EQUALITY_TYPE. Is the equality type error
actually really coming from here? If not, that explains the problem
with the missing label, because that's not where the equality type
error is coming from! I need to find the location where the equality
type error is coming from, and fix that (because it's likely wrong),
then we should get the label that's missing.

*** 2012-06-27

The error was not coming from the equality type variable, and rather
from a constraint EQUALITY_TYPE value that I had in for testing
purposes. This has to be updated. This is the reason that I have
started this research log, because when making quick changes for
debugging reasons, it's hell on earth to remember which changes in
which files I've actually made to temporarily aid debugging. It is
important to remember this information as it leads to problems later
on.

The problem currently is between the binder and the accessor. When we
are solving the accessor, we look up the binder, but we do not get all
the information that we need. We get most of it, but not all.

When we look up the binder we get something like this:

bind = TYPE_DEPENDANCY(TYPE_CONSTRUCTOR((n1,DECLARATION_CONS(0),l40154),ROW_CONSTRUCTION([FIELD_CONSTRUCTION((1,l40154):TYPE_DEPENDANCY(TYPE_VAR(t31850,-,POLY,UNKNOWN),[40157],[],[]),l40154),FIELD_CONSTRUCTION((2,l40154):TYPE_DEPENDANCY(
TYPE_CONSTRUCTOR(TYPENAME_DEPENDANCY((n242,DECLARATION_CONS(1692),l40144),[40143,40144],[],[]),ROW_DEPENDANCY(ROW_CONSTRUCTION([FIELD_CONSTRUCTION((1,l40145):TYPE_VAR(t31854,-,POLY,UNKNOWN),l40145)],-,l40145),[40143,40144,40145],[],[]),l
40143,UNKNOWN),[40143],[],[]),l40154)],-,l40154),l40154,UNKNOWN),[40154,40155,40156],[],[])

We see in the last part of the TYPE_CONSTRUCTOR tuple we have an
UNKNOWN. Perhaps the solution would be to make this an
EQUALITY_TYPE_DEPENDANCY with an equality type variable which comes
from the datatype declaration. Then we would be able to use that when
generating constraints at the point that we solve the accessor.

Perhaps we should really have a different binder altogether for
equality types, and when we solve the accessor we get an equality type
dependancy with the equality type variable inside. It's rather
convenient the way it is though.

(2012-06-27-15:10)

Added warning in the warnings section as am constraining constyarrow
to always be an EQUALITY_TYPE. I think it's this construction that
will change the last value in the tuple from UNKNOWN to
EQUALITY_TYPE. If this is the case then I can look at where
constyarrow is being constructed and locate where the equality type
variable should go in.

(2012-06-27-15:17)

It is indeed the case that this is what causes the last part of the
tuple to change. Going to look through and find out which constyarrow
construction is generating this new EQUALITY_TYPE tuple value in the
constraint generator, when I find that I should hopefully be able to
switch it to an EQUALITY_TYPE_VAR with a variable from the datatype
definition and we should get the right error.

(2012-06-27-15:28)

There is now a a constyarrow'Eq (these names in Ty.sml really need
changing) which forces an EQUALITY_TYPE_STATUS given as a parameter
when generating a type arrow constraint, and constyarrow' has been
reverted to its normal state.

(2012-06-27-16:09)

There were some places in the code where we were checking the equality
type status that was in the TYPE_CONSTRUCTOR datatype constructor and
checking if it was the same as another TYPE_CONSTRUCTOR's value. This
code will need to be rewritten to handle this, for the moment
detection of this old kind of error is commented out. Some eq-test
files which I have will now not detect errors, so I'll have to go back
and make some of them work.

(2012-06-27-16:34)

So now the equality type variable from the datatype definition is
available when we solve the equality type accessor, but an error is
still not detected. The link that is missing is when solving two
equality type variables. There is enough information in the state now
for Skalpel to figure out that there is an equality type error, but
the code which solves the constraint of two equality type variables
will need to be extended.

(2012-06-27-16:38)

I think it's the case when solving two equality type variables that
we're not sure what to do when both of them already exist in the
map...

*** 2012-06-28

(2012-06-28-00:38)

It's not actually the case the analysis engine is stuck because an
equality type variable is being mapped to two things. Here's what
happens in a run of eq-test14.sml, which looks like this:

datatype ''a mydt = firstCons of int | secondCons of ''a;
secondCons(5.0)

We generate equality type variables for anything which can later turn
out to be an equality type error, and in the constraint generation
stage we constraint equality type variables to be equal to other
equality type variables. In some places we generate equality type
status values (EQUALITY_TYPE, NOT_EQUALITY_TYPE, or UNKNOWN), which
equality type variables are then constrained to be.

So in the shown code example, the constraint solver does the following
solving with respect to equality types:

(EQUALITY_TYPES) Unification.sml: solving an equality type constraint of EQUALITY_TYPE_VAR(eqtv17709) and EQUALITY_TYPE_VAR(eqtv17708). Labels = [40150]
(EQUALITY_TYPES) Unification.sml: solving an equality type constraint of EQUALITY_TYPE_VAR(eqtv17713) and EQUALITY_TYPE_VAR(eqtv17712). Labels = [40154]
(EQUALITY_TYPES) Unification.sml: solving an equality type constraint of EQUALITY_TYPE_VAR(eqtv17712) and EQUALITY_TYPE_VAR(eqtv17711). Labels = [40157]
(EQUALITY_TYPES) Unification.sml: solving an equality type constraint of EQUALITY_TYPE_VAR(eqtv17711) and EQUALITY_TYPE_STATUS(EQUALITY_TYPE). Labels = [40158]
(EQUALITY_TYPES) Unification.sml: solving an equality type constraint of EQUALITY_TYPE_VAR(eqtv17712) and EQUALITY_TYPE_STATUS(EQUALITY_TYPE). Labels = [40157,40158]
(EQUALITY_TYPES) Unification.sml: solving an equality type constraint of EQUALITY_TYPE_VAR(eqtv17713) and EQUALITY_TYPE_STATUS(EQUALITY_TYPE). Labels = [40154,40157,40158]
(EQUALITY_TYPES) Unification.sml: solving an equality type constraint of EQUALITY_TYPE_VAR(eqtv17718) and EQUALITY_TYPE_VAR(eqtv17717). Labels = [40160]
(EQUALITY_TYPES) Unification.sml: solving an equality type constraint of EQUALITY_TYPE_VAR(eqtv17714) and EQUALITY_TYPE_VAR(eqtv17718). Labels = [40160]

These are the constraints that we need to solve which were generated
from the first line of the code. When we constrain equality type
variables to be the same as other equality type variables, this is
stored in the internal state as an EQUALITY_TYPE_DEPENDANCY, which can
take as the first argument of its tuple an equality type variable, the
other arguments being label information, and some other arguments. The
reason we store these in the state as a dependancy and not directly as
an equality type variable is so that we can put label information
along side this information which provide program points WHY an
equality type variable is constrained to another equality type
variable.

So we have 17709 constrained to 17708, 17713 constrained to 17712,
17712 constrained to 17711, and 17711 constrained to
EQUALITY_TYPE. Aha! If that's the case then both 17712 and 17713 are
constrained to be equality types also! So when we see an equality type
variable being constrained to an equality type status, we look in the
state to see if that equality type variable is dependant on other type
variables. When we see this constraint:

(EQUALITY_TYPES) Unification.sml: solving an equality type constraint of EQUALITY_TYPE_VAR(eqtv17711) and EQUALITY_TYPE_STATUS(EQUALITY_TYPE). Labels = [40158]

We look up the state to see if other equality type variables are
dependancy on equality type variable 17711 and sure enough we see that
there are, 17712. We then generate a constraint that 17712 have the
same equality type status that 17711 is currently being constrained
to, and go to solve that along with the rest of the other
constraints. This works its way back up the equality type variable
constraints until it reaches the point where we discover that two type
variables are constrained to be the same, but both are mapped to
dependancies on differing EQUALITY_TYPE_STATUS values, at which point
we generate an equality type error, or we reach the point where we
encounter the point where we have an equality type variable which
isn't mapped to anything (as is the case with 17713 in the constraint
solving process above).

Alright so here things get a little bit more complicated, in the first
line of the code we generate a binder so that we able to reference
things in the first line of the code (the datatype constructor names
for example, in other lines of the code). When we reference datatype
constructor names for example, as indeed we do in line two of the
code, we have to solve the accessor. Here's what that looks like.

(EQUALITY_TYPES) Unification.sml: solving an equality type accessor. Labels = [40161]
sem = EQUALITY_TYPE_VAR(eqtv17714)
id = 1695
bind = TYPE_DEPENDANCY(TYPE_CONSTRUCTOR((n1,DECLARATION_CONS(0),l40154),ROW_CONSTRUCTION([FIELD_CONSTRUCTION((1,l40154):TYPE_DEPENDANCY(TYPE_VAR(t31850,-,POLY,UNKNOWN),[40157],[],[]),l40154),FIELD_CONSTRUCTION((2,l40154):TYPE_DEPENDANCY(
TYPE_CONSTRUCTOR(TYPENAME_DEPENDANCY((n242,DECLARATION_CONS(1692),l40144),[40143,40144],[],[]),ROW_DEPENDANCY(ROW_CONSTRUCTION([FIELD_CONSTRUCTION((1,l40145):TYPE_VAR(t31854,-,POLY,UNKNOWN),l40145)],-,l40145),[40143,40144,40145],[],[]),l
40143,EQUALITY_TYPE_STATUS(UNKNOWN)),[40143],[],[]),l40154)],-,l40154),l40154,EQUALITY_TYPE_VAR(eqtv17713)),[40154,40155,40156],[],[])

In the last argument of the top level TYPE_CONSTRUCTOR datatype
constructor instantiation we see that there is some equality type
information available: EQUALITY_TYPE_VAR(eqtv17713). This is providing
us with an equality type variable from the first line which we can use
to generate constraints with. So when we see as follows:

(EQUALITY_TYPES) Unification.sml: solving an equality type constraint of EQUALITY_TYPE_VAR(eqtv17714) and EQUALITY_TYPE_VAR(eqtv17713). Labels = [40154,40155,40156,40161]

So here we have two numbers- 17714 and 17713. 17713 has already been
described, it comes from the first line of the code (specifically, the
ConBindOf function of Analyze,sml, where we generate the constraints
for new datatype constructors. The 17714 number comes from the
f_longidexp function of Analyze.sml, which is the point at which we
generate the equality type accessor constraint. While generating this
equality type accessor constraint, we feed this number in, and so we
end up with the equality type variable 17714 being constrained to be
the same number as 17713. We go on to solve the following further
constraints.

(EQUALITY_TYPES) Unification.sml: solving an equality type constraint of EQUALITY_TYPE_VAR(eqtv17717) and EQUALITY_TYPE_VAR(eqtv17716). Labels = [40162]
(EQUALITY_TYPES) Unification.sml: solving an equality type constraint of EQUALITY_TYPE_VAR(eqtv17716) and EQUALITY_TYPE_VAR(eqtv17715). Labels = [40163]
(EQUALITY_TYPES) Unification.sml: solving an equality type constraint of EQUALITY_TYPE_VAR(eqtv17715) and EQUALITY_TYPE_STATUS(NOT_EQUALITY_TYPE). Labels = [40164]
(EQUALITY_TYPES) Unification.sml: solving an equality type constraint of EQUALITY_TYPE_VAR(eqtv17716) and EQUALITY_TYPE_STATUS(NOT_EQUALITY_TYPE). Labels = [40163,40164]
(EQUALITY_TYPES) Unification.sml: solving an equality type constraint of EQUALITY_TYPE_VAR(eqtv17717) and EQUALITY_TYPE_STATUS(NOT_EQUALITY_TYPE). Labels = [40162,40163,40164]
(EQUALITY_TYPES) Unification.sml: solving an equality type constraint of EQUALITY_TYPE_VAR(eqtv17718) and EQUALITY_TYPE_STATUS(NOT_EQUALITY_TYPE). Labels = [40160,40162,40163,40164]
(EQUALITY_TYPES) Unification.sml: solving an equality type constraint of EQUALITY_TYPE_VAR(eqtv17714) and EQUALITY_TYPE_STATUS(NOT_EQUALITY_TYPE). Labels = [40160,40162,40163,40164]

So something isn't working here. We know that 17714 is of status
NOT_EQUALITY_TYPE, and that 17714 is constrained to 17713, and that
17713 is constrained to be of status EQUALITY_TYPE. The analysis
engine needs to be able to see this and detect this type error.

The problem is likely to do with the state. Part of the problem is
that it's difficult to know exactly why this problem is happening, and
this can be solved by acting on the earlier todo note on
2012-06-27. When we are checking that there are any status values that
clash, the type variables that we are solving along the way that we
set to be equal to equality type status values *should get this new
equality type status added to the map against it*. At the moment, we
just check that it's alright for the moment, and then we move on to
solve the rest of the constraints.

(2012-06-28-10:43)

Alright, whenever I see two equality type variables being constrained
to be equal to each other, but the one on the right hand side is
already in the map has an equality type status, I'm going to make it
the case that the left hand side is updated in the map to be also
constrained to be that status, where it is not mapped to a status
already. If it is mapped to a status already, then I need to check
whether there is a clash between the status values.

(2012-06-28-12:50)

AHHH that's got things going, we're getting equality type errors now
for the code fragment:

datatype ''a mydt = firstCons of int | secondCons of ''a;
secondCons(5.0)

Excellent. I'm going to go back and fix up some of the other equality
type error tests which have broken now, then maybe write up some more
details on how the equality type errors are detected in a given piece
of code if necessary.

(2012-06-28-13:18)

In the simple case of 5.0 = 5.0, the equality type error has now been
put back that was broken. This took me all of 60 seconds. It's much
easier to do things now there's a system in place (huzzah!).

(2012-06-28-15:52)

The case involving tuples doesn't work yet, I'm going to need to think
of a way to handle code like this: (1, 1.0) = (2, 2.0). The equality
type variable which represents the tuple should be constrained to be
equal to.... something. Not sure how this is going to work yet, I'll
need to have a think about this.

(2012-06-28-17:20)

Just got the analysis engine compiling again. I'm currently fixing up
the basic example:

val x = 1.0;
val y = 2.0;
x = y

The problem with this is that when we generate the NOT_EQUALITY_TYPE
status for 1.0, that information is not going into the binder when we
bind x, so subsequently when we solve the accessor in the third line
and constrain that to be an EQUALITY_TYPE, no error is discovered
because we by default get an UNKNOWN status put into the binder.

I have changed parts of the analysis engine so that equality type
variables are now propagated around more parts of the system, but I
still have to track down where this binder is situated, and put the
equality type variable representing 1.0 into that binder.

(2012-06-28-17:31)

I should really start using branches when working on this stuff. The
code broke and I want to commit it to the repository, but I don't want
to do that if the analysis engine doesn't compile (and I *will not* be
able to do that soon anyway, once I update the test framework, as if
the analysis engine cannot be compiled then the daily test e-mails
will fail, which is a situation I really want to avoid).

On the other hand it has kept me in the office another half hour to
fix the problem, so not all bad.

Skalpel has been *EXTREMELY* useful in the detection of type errors
today, in particular arity clash between functions. I was at the point
where I was about to remove all my changes and start again, because
the type error messages I was getting from the compiler were just
useless, and pointing me to silly places. Skalpel definitely saved me
probably 30-60 minutes in this case, an excellent win!

Irritating points though, when I see an arity clash, I want to see all
of the places where there are different arity. Skalpel highlights them
of course, but I have to scroll up and down the file looking for
them. It would be nice to have a button that executed the function
'jump to next bit in the file that has highlighting for the currently
selected slice'. This would be most helpful.

I have found that executing Skalpel on single files to be very
useful. What would also be nice is a 'Work on this file only' button,
where Skalpel runs on a file but suppresses any errors about undefined
identifiers.

Feels good that Skalpel definitely saved me time today. I'd MUCH
rather spend the time writing about that event here, than spent my
time stuck in a whirlwind of type errors. I'll maybe work on the first
year report this evening, it would be good to continue with that.

*** 2012-06-29

(2012-06-29-12:55)

Trying to stay away from developing equality types today and stick to
the first year report, but I'm writing down while I remember it that
equality type errors should have two endpoints not one. I guess we'll
need some kind of endpoint label information in the label sets that
are generated. We already generate errors that have multiple endpoints
though I can't remember exactly how this works, I should be able to
use the same mechanism for equality type error endpoints as type
constructor clashes...

Adding this as a TODO item also.

(2012-06-29-13:12)

Just found the org-mode guide I had filed away. Will fix this document
up to make use of some of the nice org features.

*** 2012-07-01

(2012-07-01-22:12)

I've updated the test framework. Now the repository will actually be
updated, a fresh binary will be generated from the new sources and the
tests will be ran on this new binary.

The compilation log has been added to the daily e-mail, so if
compilation fails we should see this in the e-mail.

Note that from this point, any source code that is pushed to the
master branch *should compile*. This has not always been the case in
the past but now it is necessary (and what should happen anyway, in
case others wish to clone the repository). Any developmental work
should be done on a branch, and then merged into the master branch
when it compiles again (it doesn't necessarily need to be stable, but
it should compile and shouldn't break lots of previous tests.

I'll try to be sure and look at the test framework output tomorrow
carefully, looking for bugs (for example, an empty e-mail or some big
error message). Hopefully I won't get some distraction that carts me
off in another direction, but I'll have the test framework e-mail to
remind me anyway.

Note that the test framework should still diff results against a
master, and not against the previous day. This is a change which still
needs to be made, and should go higher up on the priority list.

The literature review for the paper on variable name completion is
deemed to be finished, but perhaps I should talk more specifically
about their type inference algorithm? Does the reader really care?
Maybe I want to look at their algorithm in much more depth as part of
the review of other implementations (preferably in another section)?
Think about this.

*** 2012-07-02

(2012-07-02-10:48)

The reports from the test framework this morning are a bit strange,
the compilation output only lists the actions of MLLex. Perhaps this
is the only thing coming to stdout (the contents of which are added to
the e-mail). Are the warnings on compilation printed to stderr because
it would be good to have these too. Fiddling around with the first
year report so don't have time to look at this at the moment, I'll
have to come back to it.

(2012-07-02-11:56)

It might be nice to have syntax highlighting in the code that's being
used in the lstlisting environment but currently that is not the
case. Is that something which I should have? It is certainly the case
anyway that I'm going to need some LaTeX code which will highlight the
background and foreground of text in all the ways that the Skalpel
output does, but I should be able to get that from the paper perhaps
when Vincent commits the sources. Something to think about anyway.

In a different note, the indentation for lstlisting is mucked
up. Added a TODO item to fix that, it looks rather bizarre. Probably
just a parameter needs to be added to the figure environment or
something.

(2012-07-02-12:54)

There are new examples of things which aren't working with equality
types that I've discussed in the future work section. I have chosen
these examples because they are unlikely to be completed by the time
this report actually needs to be read by someone sometime soon. Do
these features last (detecting equality type errors in datatype
declaration where one constructor in the declaration can never be
compared for equality (eg int -> int), and eqtype in a signature
definiton) so that this text is technically accurate for as long as
possible. There should be other things to fix up with respect to
equality types if I have the time before this gets handed in anyway,
so I'll just work on the other things.

I'm going to continue on with the future work section I think and
finish that off, so that an entire section can be marked as complete
and I can move on, or review it as a whole with Joe and find things to
change.

(2012-07-02-16:26)

Hmm, not sure whether to talk about some of this material from the
Haack and Wells paper or not, namely things like how constraints are
assigned to program points and how minimized errors are found. If I
include the proper definitions then the document may increase in size
as it'll need to cover everything relevant, but I think I'm going to
have to include at least the definitions for labels and perhaps some
parts of the constraint system to describe how equality types are
implemented properly anyway. It would also allow me to talk at more
depth about the similarities between this paper and the implementation
of Skalpel, some years on now. Many of the definitions described in
the paper are still true, even some of the things about how the
unification algorithm and minimization algorithm work. I'll think
about that.

Perhaps it would be better not to discuss these details here, but just
to launch into a big discussion when talking about how equality types
are implemented, and describe everything there that is necessary. It
would be a bit strange to have text about how minimal slices are
found under a section title about equality types though. Perhaps
instead this information should go in a new chapter called
'Background' or something, where I could explain how everything works,
and that would allow me to talk about some of the technical aspects of
the Haack and Wells paper in the later literature review chapter, by
which time I'll have already have all the definitions I need.

(2012-07-02-16:58)

Alright, what I think I'm going to do with the overview is to move
section 1.3, the other approaches to type error slicing, to some other
chapter which looks at how other systems operate, and then clean the
overview up and keep it how it is.

Then perhaps after the overview would come a background section where
I can define how the current system works? Then perhaps extend that in
the first year work section with information about how the equality
types constraint generation and unification work?

While I think about it, it would give me an opportunity to look at the
symbols from the paper and would make me think about them some more,
as I'd have to extend it a little for equality types. It would perhaps
allow me to clean up the paper too, which I'm supposed to be doing at
some very much undefined time, and the paper would eventually be
updated to include work done on equality types anyway. I'll think some
more about this anyway.

*** 2012-07-03

(2012-07-03-11:28)

The overview for the first year report is marked done, I'll maybe look
at bits of that with Joe in the next meeting. I still have a manual
page break on page 3 of the document, there's warning to this effect
but it would be good to sort that out. Referencing still needs to be
done also for the document, I guess I'll do that at the end after I've
finished writing the body of the text.

Vincent still hasn't been mentioned in this text, the work that he
did should be pointed out explicitly. A reference to his thesis will
also be needed. I'll add this to the TODO.

* Next meeting with Joe

- Emacs interface calling compiler binary alongside Skalpel?
- (switch-buffer) defadvice to not create new buffer
- ask about any news on viva date, must be sometime soon?


