* schedule
** 2011

october 2011: repo, copyright
november 2011: json test database
december 2011 overloading bug, command-line interface, nuke wrapper

** 2012

january 2012: sml/nj -> mlton, massive renaming, equality types?
february 2012: renaming, code cleaning
march 2012: ast exploration, code documentation, renaming
april 2012: automatic test framework, bug fixes, renaming, equality types, user guide
may 2012: equality types, bugzilla
june 2012: equality types, first year report
july 2012: equality types, first year report, test framework, web demo
august 2012 - poster, debugging output, finishing equality types
september 2012 - equality types, debugging output, new release, displaying separate slice
october 2012 - overloding resolution?, esop?
november 2012 - ?
december 2012 - ?

** 2013

january 2013 - ?
february 2013 - ?
march 2013 - ppdp/icfp?
april 2013 - ?
may 2013 - ?
june 2013 - ?
july 2013 - popl ?
august 2013 - ?
september 2013 - ?
october 2013 - esop?

* paper targets
** measure programming improvement
** algorithm speed / engineering
** graphical slice presentation
** generalising to other languages
** whatever is needed to make skalpel work on itself
* warnings
** equality types
   consbindof uses an old method of carrying around equality type
   variables, an equality type variable should be generated from the
   type name and constrained that way, rather than carrying it around
   in the standard type constraint.

   in constraint generation, case f_exp of a.expfn doesn't have any
   equality type constraints

   remove my warning comments in unification.sml (in type constructor
   accessor solving, case match 2), they should be fine now. also in
   componetype.

   a.decdatrep and a.specrep get eqtvs from f_longtycon. need to check
   labels for these.

   a.expcase has equality type variables which should have constraints
   generated out of it but it currently throws them away (i guess
   that's just not been implemented yet). similarly for a.expconslist,
   a.expor, a.expand, a.expite, a.expwhile (what is that anyway?),
   a.expraise, and a.exphandle.

   a.expop generates a fresh equality type variable and returns that
   as its list. should this equality type variable have any kind of
   constraint on it?

   f_progone throws away the equality type variables it gets back from
   f_exp. is this correct? probably it is because i can't think of any
   constraints off the top of my head that we would want to do at the
   f_progone level.

   f_labexp has something worrying where we take the first element in
   the list of new equality type variables and put that into a type
   constraint with a type variable. will this cause a problem later?
   do we need multiple type constraints.

   some of the constraints in log (2012-09-06-14:59) have been left
   unimplemented, because i actually think that we can do without
   them. furthermore, this constraint:

   | some (t.equality_type_dependancy((t.equality_type_var eqtv), resultlabels, resultdeps, resultids), recordinformation) =>

   when handling a constraint from an equality type variable to an
   equality type variable list, does nothing, and simply solves the
   remaining constraints. i'm not sure if this is ever a situation
   where we should solve these constraints more carefully, testing
   will need to be completed.

* todos
** test framework
*** (2012-07-31-01:46) web demo

    currently the web demo is completely untested by the test
    framework. this is an important thing to test as it will break
    frequently, so think of a way that this could be done.

*** (2012-07-20-10:50) running tests from a fresh clone of the repository

the best way for the test framework to work is if it actually ran
tests from a fresh clone of the repository, then the test framework
would have to do the same steps that any user would have to do in
order to run its tests.

it also has the additional advantage that if anyone in the skalpel
project wants to know how something has to be built, they can just
look at the test framework. naturally, this information should be
documented anyway, but the test framework will have to contain the
exact steps needed to build whatever it is going to test. this would
be quite a good thing for us.

so for example, at the moment the mlb files cannot be generated from
the cm files if i remember correctly. this is the sort of thing that
the test framework would pick up on, and have to make the necessary
changes to the mlb files after an attempt at conversion has been made.

*** (2012-07-02-16:45) daily package building

packages should be built daily by the test framework, and a report
should be generated whether it was possible to build the package or
not. as the test framework runs on a red hat system it is not possible
to generate say the debian packages, but we are still able to generate
quite a few of them.

*** (2012-07-02-16:46) daily package testing

the packages that are built should also be installed and tested, and
the results of all of this should end up in the e-mail that gets sent
out in the morning. wouldn't it be nice just to decide we were going
to release one day and just do it? :-)

*** (2012-07-02-16:48) test emacs front end works

we should test also the emacs front end. it would somehow need to be
started with a standard ml source file open, have the type error slice
run on that file, and check that emacs is highlighting things inside
the file, and that the process terminates.

** equality types implementation
*** (2012-06-29-21:19) detection of equality type errors with the eqtype keyword

    in the case where we have 'eqtype x' in a signature (instead of
    what could be 'type x') an equality status constraint of
    equality_type should be generated for x (obviously). then if the
    user is to do something like 'val y : x = 5.0' then an equality
    type error should be output by skalpel, the equality_type status
    of x clashing with the not_equality_type status of the 5.0.

*** (2012-08-08-16:13) value declarations with ticks

    val 'b f = fn x : 'b => x = x;

    does this apply to things other than value declarations?

    fun 'b f (x:'b) = x = x

    (same as above)

    i don't get generate not_equality_type for 'a for example,
    although equality_type is generated for ''b we need the constraint
    for 'a.

    this also demonstrates the problem fairly well:

    fun f (x:'b) = x = x;
    error-type error in function application.
    function: = : ''a * ''a -> bool
    argument: (x, x) : 'a * 'a
    reason: can't unify ''a to 'a (requires equality type)
    found near x = x
    static errors

** other
*** todo (2012-08-30-15:16) add tags to research log entries for august
* research logs
** tags available
   equality-types
   labels
   binders
   accessors
   write-up
   first-year-report
   test-framework
   other-implementations
   papers
   latex
   website
   poster
** 2012-06
*** 2012-06-26
tags: {equality-types, labels}

when we see an equality type variable (''a) we generated this:

val c   = e.initequalitytypeconstraint (t.consequality_type_var eqtypevar) (t.equality_type_status(t.equality_type)) lab

we still get the equality type error when this is constrained to be
not_equality_type instead of equality_type. is the equality type error
actually really coming from here? if not, that explains the problem
with the missing label, because that's not where the equality type
error is coming from! i need to find the location where the equality
type error is coming from, and fix that (because it's likely wrong),
then we should get the label that's missing.

*** 2012-06-27
tags: {equality-types, binders, accessors, labels}

the error was not coming from the equality type variable, and rather
from a constraint equality_type value that i had in for testing
purposes. this has to be updated. this is the reason that i have
started this research log, because when making quick changes for
debugging reasons, it's hell on earth to remember which changes in
which files i've actually made to temporarily aid debugging. it is
important to remember this information as it leads to problems later
on.

the problem currently is between the binder and the accessor. when we
are solving the accessor, we look up the binder, but we do not get all
the information that we need. we get most of it, but not all.

when we look up the binder we get something like this:

bind = type_dependancy(type_constructor((n1,declaration_cons(0),l40154),row_construction([field_construction((1,l40154):type_dependancy(type_var(t31850,-,poly,unknown),[40157],[],[]),l40154),field_construction((2,l40154):type_dependancy(
type_constructor(typename_dependancy((n242,declaration_cons(1692),l40144),[40143,40144],[],[]),row_dependancy(row_construction([field_construction((1,l40145):type_var(t31854,-,poly,unknown),l40145)],-,l40145),[40143,40144,40145],[],[]),l
40143,unknown),[40143],[],[]),l40154)],-,l40154),l40154,unknown),[40154,40155,40156],[],[])

we see in the last part of the type_constructor tuple we have an
unknown. perhaps the solution would be to make this an
equality_type_dependancy with an equality type variable which comes
from the datatype declaration. then we would be able to use that when
generating constraints at the point that we solve the accessor.

perhaps we should really have a different binder altogether for
equality types, and when we solve the accessor we get an equality type
dependancy with the equality type variable inside. it's rather
convenient the way it is though.

(2012-06-27-15:10)

added warning in the warnings section as am constraining constyarrow
to always be an equality_type. i think it's this construction that
will change the last value in the tuple from unknown to
equality_type. if this is the case then i can look at where
constyarrow is being constructed and locate where the equality type
variable should go in.

(2012-06-27-15:17)

it is indeed the case that this is what causes the last part of the
tuple to change. going to look through and find out which constyarrow
construction is generating this new equality_type tuple value in the
constraint generator, when i find that i should hopefully be able to
switch it to an equality_type_var with a variable from the datatype
definition and we should get the right error.

(2012-06-27-15:28)

there is now a a constyarrow'eq (these names in ty.sml really need
changing) which forces an equality_type_status given as a parameter
when generating a type arrow constraint, and constyarrow' has been
reverted to its normal state.

(2012-06-27-16:09)

there were some places in the code where we were checking the equality
type status that was in the type_constructor datatype constructor and
checking if it was the same as another type_constructor's value. this
code will need to be rewritten to handle this, for the moment
detection of this old kind of error is commented out. some eq-test
files which i have will now not detect errors, so i'll have to go back
and make some of them work.

(2012-06-27-16:34)

so now the equality type variable from the datatype definition is
available when we solve the equality type accessor, but an error is
still not detected. the link that is missing is when solving two
equality type variables. there is enough information in the state now
for skalpel to figure out that there is an equality type error, but
the code which solves the constraint of two equality type variables
will need to be extended.

(2012-06-27-16:38)

i think it's the case when solving two equality type variables that
we're not sure what to do when both of them already exist in the
map...

*** 2012-06-28
tags: {equality-types}

(2012-06-28-00:38)

it's not actually the case the analysis engine is stuck because an
equality type variable is being mapped to two things. here's what
happens in a run of eq-test14.sml, which looks like this:

datatype ''a mydt = firstcons of int | secondcons of ''a;
secondcons(5.0)

we generate equality type variables for anything which can later turn
out to be an equality type error, and in the constraint generation
stage we constraint equality type variables to be equal to other
equality type variables. in some places we generate equality type
status values (equality_type, not_equality_type, or unknown), which
equality type variables are then constrained to be.

so in the shown code example, the constraint solver does the following
solving with respect to equality types:

(equality_types) unification.sml: solving an equality type constraint of equality_type_var(eqtv17709) and equality_type_var(eqtv17708). labels = [40150]
(equality_types) unification.sml: solving an equality type constraint of equality_type_var(eqtv17713) and equality_type_var(eqtv17712). labels = [40154]
(equality_types) unification.sml: solving an equality type constraint of equality_type_var(eqtv17712) and equality_type_var(eqtv17711). labels = [40157]
(equality_types) unification.sml: solving an equality type constraint of equality_type_var(eqtv17711) and equality_type_status(equality_type). labels = [40158]
(equality_types) unification.sml: solving an equality type constraint of equality_type_var(eqtv17712) and equality_type_status(equality_type). labels = [40157,40158]
(equality_types) unification.sml: solving an equality type constraint of equality_type_var(eqtv17713) and equality_type_status(equality_type). labels = [40154,40157,40158]
(equality_types) unification.sml: solving an equality type constraint of equality_type_var(eqtv17718) and equality_type_var(eqtv17717). labels = [40160]
(equality_types) unification.sml: solving an equality type constraint of equality_type_var(eqtv17714) and equality_type_var(eqtv17718). labels = [40160]

these are the constraints that we need to solve which were generated
from the first line of the code. when we constrain equality type
variables to be the same as other equality type variables, this is
stored in the internal state as an equality_type_dependancy, which can
take as the first argument of its tuple an equality type variable, the
other arguments being label information, and some other arguments. the
reason we store these in the state as a dependancy and not directly as
an equality type variable is so that we can put label information
along side this information which provide program points why an
equality type variable is constrained to another equality type
variable.

so we have 17709 constrained to 17708, 17713 constrained to 17712,
17712 constrained to 17711, and 17711 constrained to
equality_type. aha! if that's the case then both 17712 and 17713 are
constrained to be equality types also! so when we see an equality type
variable being constrained to an equality type status, we look in the
state to see if that equality type variable is dependant on other type
variables. when we see this constraint:

(equality_types) unification.sml: solving an equality type constraint of equality_type_var(eqtv17711) and equality_type_status(equality_type). labels = [40158]

we look up the state to see if other equality type variables are
dependancy on equality type variable 17711 and sure enough we see that
there are, 17712. we then generate a constraint that 17712 have the
same equality type status that 17711 is currently being constrained
to, and go to solve that along with the rest of the other
constraints. this works its way back up the equality type variable
constraints until it reaches the point where we discover that two type
variables are constrained to be the same, but both are mapped to
dependancies on differing equality_type_status values, at which point
we generate an equality type error, or we reach the point where we
encounter the point where we have an equality type variable which
isn't mapped to anything (as is the case with 17713 in the constraint
solving process above).

alright so here things get a little bit more complicated, in the first
line of the code we generate a binder so that we able to reference
things in the first line of the code (the datatype constructor names
for example, in other lines of the code). when we reference datatype
constructor names for example, as indeed we do in line two of the
code, we have to solve the accessor. here's what that looks like.

(equality_types) unification.sml: solving an equality type accessor. labels = [40161]
sem = equality_type_var(eqtv17714)
id = 1695
bind = type_dependancy(type_constructor((n1,declaration_cons(0),l40154),row_construction([field_construction((1,l40154):type_dependancy(type_var(t31850,-,poly,unknown),[40157],[],[]),l40154),field_construction((2,l40154):type_dependancy(
type_constructor(typename_dependancy((n242,declaration_cons(1692),l40144),[40143,40144],[],[]),row_dependancy(row_construction([field_construction((1,l40145):type_var(t31854,-,poly,unknown),l40145)],-,l40145),[40143,40144,40145],[],[]),l
40143,equality_type_status(unknown)),[40143],[],[]),l40154)],-,l40154),l40154,equality_type_var(eqtv17713)),[40154,40155,40156],[],[])

in the last argument of the top level type_constructor datatype
constructor instantiation we see that there is some equality type
information available: equality_type_var(eqtv17713). this is providing
us with an equality type variable from the first line which we can use
to generate constraints with. so when we see as follows:

(equality_types) unification.sml: solving an equality type constraint of equality_type_var(eqtv17714) and equality_type_var(eqtv17713). labels = [40154,40155,40156,40161]

so here we have two numbers- 17714 and 17713. 17713 has already been
described, it comes from the first line of the code (specifically, the
conbindof function of analyze,sml, where we generate the constraints
for new datatype constructors. the 17714 number comes from the
f_longidexp function of analyze.sml, which is the point at which we
generate the equality type accessor constraint. while generating this
equality type accessor constraint, we feed this number in, and so we
end up with the equality type variable 17714 being constrained to be
the same number as 17713. we go on to solve the following further
constraints.

(equality_types) unification.sml: solving an equality type constraint of equality_type_var(eqtv17717) and equality_type_var(eqtv17716). labels = [40162]
(equality_types) unification.sml: solving an equality type constraint of equality_type_var(eqtv17716) and equality_type_var(eqtv17715). labels = [40163]
(equality_types) unification.sml: solving an equality type constraint of equality_type_var(eqtv17715) and equality_type_status(not_equality_type). labels = [40164]
(equality_types) unification.sml: solving an equality type constraint of equality_type_var(eqtv17716) and equality_type_status(not_equality_type). labels = [40163,40164]
(equality_types) unification.sml: solving an equality type constraint of equality_type_var(eqtv17717) and equality_type_status(not_equality_type). labels = [40162,40163,40164]
(equality_types) unification.sml: solving an equality type constraint of equality_type_var(eqtv17718) and equality_type_status(not_equality_type). labels = [40160,40162,40163,40164]
(equality_types) unification.sml: solving an equality type constraint of equality_type_var(eqtv17714) and equality_type_status(not_equality_type). labels = [40160,40162,40163,40164]

so something isn't working here. we know that 17714 is of status
not_equality_type, and that 17714 is constrained to 17713, and that
17713 is constrained to be of status equality_type. the analysis
engine needs to be able to see this and detect this type error.

the problem is likely to do with the state. part of the problem is
that it's difficult to know exactly why this problem is happening, and
this can be solved by acting on the earlier todo note on
2012-06-27. when we are checking that there are any status values that
clash, the type variables that we are solving along the way that we
set to be equal to equality type status values *should get this new
equality type status added to the map against it*. at the moment, we
just check that it's alright for the moment, and then we move on to
solve the rest of the constraints.

(2012-06-28-10:43)

alright, whenever i see two equality type variables being constrained
to be equal to each other, but the one on the right hand side is
already in the map has an equality type status, i'm going to make it
the case that the left hand side is updated in the map to be also
constrained to be that status, where it is not mapped to a status
already. if it is mapped to a status already, then i need to check
whether there is a clash between the status values.

(2012-06-28-12:50)

ahhh that's got things going, we're getting equality type errors now
for the code fragment:

datatype ''a mydt = firstcons of int | secondcons of ''a;
secondcons(5.0)

excellent. i'm going to go back and fix up some of the other equality
type error tests which have broken now, then maybe write up some more
details on how the equality type errors are detected in a given piece
of code if necessary.

(2012-06-28-13:18)

in the simple case of 5.0 = 5.0, the equality type error has now been
put back that was broken. this took me all of 60 seconds. it's much
easier to do things now there's a system in place (huzzah!).

(2012-06-28-15:52)

the case involving tuples doesn't work yet, i'm going to need to think
of a way to handle code like this: (1, 1.0) = (2, 2.0). the equality
type variable which represents the tuple should be constrained to be
equal to.... something. not sure how this is going to work yet, i'll
need to have a think about this.

(2012-06-28-17:20)

just got the analysis engine compiling again. i'm currently fixing up
the basic example:

val x = 1.0;
val y = 2.0;
x = y

the problem with this is that when we generate the not_equality_type
status for 1.0, that information is not going into the binder when we
bind x, so subsequently when we solve the accessor in the third line
and constrain that to be an equality_type, no error is discovered
because we by default get an unknown status put into the binder.

i have changed parts of the analysis engine so that equality type
variables are now propagated around more parts of the system, but i
still have to track down where this binder is situated, and put the
equality type variable representing 1.0 into that binder.

(2012-06-28-17:31)

i should really start using branches when working on this stuff. the
code broke and i want to commit it to the repository, but i don't want
to do that if the analysis engine doesn't compile (and i *will not* be
able to do that soon anyway, once i update the test framework, as if
the analysis engine cannot be compiled then the daily test e-mails
will fail, which is a situation i really want to avoid).

on the other hand it has kept me in the office another half hour to
fix the problem, so not all bad.

skalpel has been *extremely* useful in the detection of type errors
today, in particular arity clash between functions. i was at the point
where i was about to remove all my changes and start again, because
the type error messages i was getting from the compiler were just
useless, and pointing me to silly places. skalpel definitely saved me
probably 30-60 minutes in this case, an excellent win!

irritating points though, when i see an arity clash, i want to see all
of the places where there are different arity. skalpel highlights them
of course, but i have to scroll up and down the file looking for
them. it would be nice to have a button that executed the function
'jump to next bit in the file that has highlighting for the currently
selected slice'. this would be most helpful.

i have found that executing skalpel on single files to be very
useful. what would also be nice is a 'work on this file only' button,
where skalpel runs on a file but suppresses any errors about undefined
identifiers.

feels good that skalpel definitely saved me time today. i'd much
rather spend the time writing about that event here, than spent my
time stuck in a whirlwind of type errors. i'll maybe work on the first
year report this evening, it would be good to continue with that.

*** 2012-06-29
tags: {first-year-report, labels}

(2012-06-29-12:55)

trying to stay away from developing equality types today and stick to
the first year report, but i'm writing down while i remember it that
equality type errors should have two endpoints not one. i guess we'll
need some kind of endpoint label information in the label sets that
are generated. we already generate errors that have multiple endpoints
though i can't remember exactly how this works, i should be able to
use the same mechanism for equality type error endpoints as type
constructor clashes...

adding this as a todo item also.

(2012-06-29-13:12)

just found the org-mode guide i had filed away. will fix this document
up to make use of some of the nice org features.

** 2012-07
*** 2012-07-01
tags: {test-framework, first-year-report}
(2012-07-01-22:12)

i've updated the test framework. now the repository will actually be
updated, a fresh binary will be generated from the new sources and the
tests will be ran on this new binary.

the compilation log has been added to the daily e-mail, so if
compilation fails we should see this in the e-mail.

note that from this point, any source code that is pushed to the
master branch *should compile*. this has not always been the case in
the past but now it is necessary (and what should happen anyway, in
case others wish to clone the repository). any developmental work
should be done on a branch, and then merged into the master branch
when it compiles again (it doesn't necessarily need to be stable, but
it should compile and shouldn't break lots of previous tests.

i'll try to be sure and look at the test framework output tomorrow
carefully, looking for bugs (for example, an empty e-mail or some big
error message). hopefully i won't get some distraction that carts me
off in another direction, but i'll have the test framework e-mail to
remind me anyway.

note that the test framework should still diff results against a
master, and not against the previous day. this is a change which still
needs to be made, and should go higher up on the priority list.

the literature review for the paper on variable name completion is
deemed to be finished, but perhaps i should talk more specifically
about their type inference algorithm? does the reader really care?
maybe i want to look at their algorithm in much more depth as part of
the review of other implementations (preferably in another section)?
think about this.

*** 2012-07-02
tags: {test-framework, first-year-report}

(2012-07-02-10:48)

the reports from the test framework this morning are a bit strange,
the compilation output only lists the actions of mllex. perhaps this
is the only thing coming to stdout (the contents of which are added to
the e-mail). are the warnings on compilation printed to stderr because
it would be good to have these too. fiddling around with the first
year report so don't have time to look at this at the moment, i'll
have to come back to it.

(2012-07-02-11:56)

it might be nice to have syntax highlighting in the code that's being
used in the lstlisting environment but currently that is not the
case. is that something which i should have? it is certainly the case
anyway that i'm going to need some latex code which will highlight the
background and foreground of text in all the ways that the skalpel
output does, but i should be able to get that from the paper perhaps
when vincent commits the sources. something to think about anyway.

in a different note, the indentation for lstlisting is mucked
up. added a todo item to fix that, it looks rather bizarre. probably
just a parameter needs to be added to the figure environment or
something.

(2012-07-02-12:54)

there are new examples of things which aren't working with equality
types that i've discussed in the future work section. i have chosen
these examples because they are unlikely to be completed by the time
this report actually needs to be read by someone sometime soon. do
these features last (detecting equality type errors in datatype
declaration where one constructor in the declaration can never be
compared for equality (eg int -> int), and eqtype in a signature
definiton) so that this text is technically accurate for as long as
possible. there should be other things to fix up with respect to
equality types if i have the time before this gets handed in anyway,
so i'll just work on the other things.

i'm going to continue on with the future work section i think and
finish that off, so that an entire section can be marked as complete
and i can move on, or review it as a whole with joe and find things to
change.

(2012-07-02-16:26)

hmm, not sure whether to talk about some of this material from the
haack and wells paper or not, namely things like how constraints are
assigned to program points and how minimized errors are found. if i
include the proper definitions then the document may increase in size
as it'll need to cover everything relevant, but i think i'm going to
have to include at least the definitions for labels and perhaps some
parts of the constraint system to describe how equality types are
implemented properly anyway. it would also allow me to talk at more
depth about the similarities between this paper and the implementation
of skalpel, some years on now. many of the definitions described in
the paper are still true, even some of the things about how the
unification algorithm and minimization algorithm work. i'll think
about that.

perhaps it would be better not to discuss these details here, but just
to launch into a big discussion when talking about how equality types
are implemented, and describe everything there that is necessary. it
would be a bit strange to have text about how minimal slices are
found under a section title about equality types though. perhaps
instead this information should go in a new chapter called
'background' or something, where i could explain how everything works,
and that would allow me to talk about some of the technical aspects of
the haack and wells paper in the later literature review chapter, by
which time i'll have already have all the definitions i need.

(2012-07-02-16:58)

alright, what i think i'm going to do with the overview is to move
section 1.3, the other approaches to type error slicing, to some other
chapter which looks at how other systems operate, and then clean the
overview up and keep it how it is.

then perhaps after the overview would come a background section where
i can define how the current system works? then perhaps extend that in
the first year work section with information about how the equality
types constraint generation and unification work?

while i think about it, it would give me an opportunity to look at the
symbols from the paper and would make me think about them some more,
as i'd have to extend it a little for equality types. it would perhaps
allow me to clean up the paper too, which i'm supposed to be doing at
some very much undefined time, and the paper would eventually be
updated to include work done on equality types anyway. i'll think some
more about this anyway.

*** 2012-07-03
tags: {first-year-report, other-implementations}

(2012-07-03-11:28)

the overview for the first year report is marked done, i'll maybe look
at bits of that with joe in the next meeting. i still have a manual
page break on page 3 of the document, there's warning to this effect
but it would be good to sort that out. referencing still needs to be
done also for the document, i guess i'll do that at the end after i've
finished writing the body of the text.

vincent still hasn't been mentioned in this text, the work that he
did should be pointed out explicitly. a reference to his thesis will
also be needed. i'll add this to the todo.

(2012-07-03-22:51)

good lord, the goto and sasano implementation actually worked straight
away, kudos to them for having a system i can set up and get working
in under two minutes. it is indeed implemented entirely in emacs lisp
though, and i guess the comments in what seems to be japanese aren't
going to give me too much help on the matter.

the method that they have for allowing users to choose different
selections is very intuitive, though i don't think we can use this
mechanism to our advantage at this current time in skalpel.

(2012-07-03-23:43)

their tokenizer suffers from the magic numbers bad smell, i should
check we don't have the same smells in our grm file.

(2012-07-03-23:55)

i can see why they don't support much of the sml feature set, they're
in for a fair bit of engineering trouble if the implementation keeps
heading this way. i assume that they aren't actually wanting to end up
supporting all of the sml programming language in this way, it would
be pretty insane.

subst1, subst2, subst3, subst4?? aaaahhh *flashbacks*. the code looks
to be pretty well written on the whole though, it's a bracket-fest but
that's to be expected. this car/cdr/caar/cdar stuff is driving me
batty, whoever chose those as names must surely be a masochist.

the 'unify' function in lambda-unification.sml is essentially their
constraint solver. skimming over it, looks like they have cases for if
the left hand side and the right hand side are arrow types, if the
left hand side is a basic type and the right hand side is an arrow
type, and the same the other way around. i'll need to read over parts
of the paper again and try and match up what they have in the paper
with what the have in the implementation, which hopefully will not be
greatly difficult. i guess it'll depend whether what they have in
their paper accurately reflects their implementation...

*** 2012-07-04
tags: {other-implementations}

(2012-07-04-09:41)

does this implementation by goto and sasano have both the w and v type
inference algorithms? they have something here for the w algorithm but
i'm not sure this algorithm would stand up on its own, perhaps it's
there solely to be used with the v algorithm. trying to figure that
one out...

(2012-07-04-11:44)

ok, it looks like they have implementations of both the w and v
algorithms. during the v algorithm they seem to run the w algorithm
when it comes to function applications:

;;function application
((appexpd-p expd)
 (let* ((result-for-m (type-inference-w env (appexpd-fun expd)))
 (result-set-for-d (lambda-type-inference-v
      (apply-subst-to-env env (w-result-subst result-for-m))
      (appexpd-argd expd)))
 (result-set (map-set
'(lambda (x)
   ;;when unification fails, the function unify throws an error with nil, which becomes the value of this catch expression.
   (catch 'error
     (let*
	 ((new-tyvar (varty (freshtyvar)))
	  (s3 (unify (singleton-set (cons
				     (apply-subst-to-type (w-result-type result-for-m) (v-result-subst x))
				     (arrowty (v-result-type x) new-tyvar))))))
       (v-result
	(union-subst s3 (union-subst (v-result-subst x) (w-result-subst result-for-m)))
	(apply-subst-to-type new-tyvar s3)
	(v-result-c x)))))
result-set-for-d)))
   (set-compact result-set))) ;;remove nil

that's alright. i suppose they don't need much more than the w
algorithm anyway, if there's a type error you aren't going to want to
include it in the suggestions list are you (well, we might want to do
that, but maybe highlight that suggestion in red or something and when
you hover over it get the slices showing why that choice would make
the code untypable, who knows).

*** 2012-07-06
tags: {papers, equality-types}

(2012-07-06-10:21)

reading these papers is turning me into a zombie, going start doing
some more of the equality types implementation, then write up text
about that in the first year report afterwards.

(2012-07-06-12:16)

have added a warning in to the warnings section, working on fixing a
test that broke. note that in ty.sml the constyarrow' equality type
status is fixed to be not_eqaulity_type.

(2012-07-06-12:28)

warning removed. new warning added for fixing reals to be of
not_equality_type status when creating the type constraint.

(2012-07-06-14:53)

this is causing the constraint solver to crash, likely because of the
previous warning about reals constrained to be not_equality_type in
the last parameter of the type constraint initialization. i didn't
design this part of the constraint solver to accept this, and rightly
so, this should be an equality type dependancy if i remember correctly
(the other log entries and code seem to indicate that this is the case
also).

i'll make this a dependancy on the equality type variable that is
created in the sconreal function during constraint generation... that
should do the trick right?

note that the endpoints still have to be fixed up. it might be nice
to finish up fixing the tests that i have to a good point, then start
looking at getting the endpoints right. then after this is done i can
commit the equality type tests i have to the test database and get
them running daily for breakages.

this might be a nice point to extend the test framework a bit so that
the equality type tests sit in an equality-types/ folder inside the
suite of tests, rather than them being given the next point in the
enumeration sequence, which doesn't tell us much of anything.

perhaps something like

equality-types/01-just-real-numbers.sml
equality-types/02-reals-inside-tuple.sml
equality-types/03-two-reals-with-variales.sml
equality-types/03-one-real-variable-self-test.sml
equality-types/04-real-and-variable-in-let.sml

or something, ideally clearer if possible and can be done without a
stupidly long file name. just think about it. oh, at the same time do
get the test framework working off a master file instead of the one
yesterday, and don't generate log files for tests which are the same
as the master. much less test files in the repository that way. some
kind of confirmation that the test suite ran though would be handy.

(2012-07-06-15:25)

i'm changing the type_var constructor to take something of
equalitytype in the last element of its tuple rather than an
equalitytypestatus, be aware that this is going to affect compilation
pretty hard...

(2012-07-06-15:35)

forcing the stripequalitystatus (type_var [...]) case to return an
empty list as its first element, this used to be eq. adding a warning,
this should let me figure out where the errors are much more quickly.

*** 2012-07-09
tags: {equality-types, labels}
(2012-07-09-08:16)

going to continue on with equality types for at least part of today,
then i'll have to work on the first year report. most of this should
be at some sort of standard but the literature review still needs
work. need to get the date when this is actually needed to be
completed, so i can get it out of the way and get on with finishing
equality types and move on.

(2012-07-09-10:05)

is stripequalitystatus actually needed in ty.sml? we seem to use it in
the env.sml file and in unification, but i'm not totally convinced
that we actually need that any more...

(2012-07-09-10:40)

actually, we don't use stripequalitystatus in env.sml, we have a
function which will indirectly use it though, but that function itself
is actually never called.

i'm going to try and remove this, if all hell breaks loose then i'll
put it back :o). i'm pretty sure this is something left over from a
previous way that equality types were represented

(2012-07-09-11:24)

i think the removal of stripequalitystatusfromconstraints in env.sml
went alright, that was one of the dependancies on stripequalitystatus
in ty.sml. there are two other calls to this function if i remember
correctly in the unification algorithm, if they aren't needed either,
or are in places where i am fixing the old code, then i can remove
this section of code.

this is important as it is this location where quite a few of the
compilation errors are coming from.

(2012-07-09-12:22)

stripequalitystatus is actually used when solving equality type
accessors, i'm going to fix up that bit of the code for now, but it
might be an idea to think about moving it into the unification
algorithm if it's not needed anywhere else.

(2012-07-09-12:59)

i'm removing all the old equality type checks that we used to do (eg
in the case of type_var and type_var check that the eq properties were
the same, as we should now be checking all this information with
equality type variables (each constraint to a status).

(2012-07-09-14:43)

i'm suffering this problem again where the unification algorithm says
"yes, i see the error!" then runs itself again, doesn't find the error
the second time around, realise that it should, and dies.

i'm still not quite sure what causes this problem, i thought it was
when there was a label missing but i don't think that's the case any
longer....

(2012-07-09-15:04)

it occurs to me that this problem with the repeated unification run
problem may indicate a problem with the unification algorithm, and
that it is *not* a problem with the constraint generation
algorithm. i'm not sure if this is definitely the case, maybe the
problem may still lie with the constraint generation algorithm, but if
it detected the equality type error once, then the constraints
generated are actually correct surely? it's what we take out for the
repeated runs that's wrong?

(2012-07-09-17:38)

just had a thought, the second set of labels that i was talking about
in the warnings... is this the set of labels that i always found to be
empty about a year ago? it wasn't confirmed to be always empty but
that was what was suspected, look into confirming this. perhaps run
the entire test database with debug output then see if any of the deps
have values? note: a script will be needed to do that, the volume of
the output is far too large to be done by hand.

(2012-07-09-23:44)

still on this problem with the unification algorithm falling over on
the second run. the problem is that i don't know what the real error
is for certain. the initial error was 'the error should be an error'
which i've changed to the current understanding which i've got now.

*** 2012-07-10
tags: {equality-types, labels, first-year-report, latex}
(2012-07-10-00:08)

it looks like the labels are correct, so why is this failing on the
next run? it looks to me like for some reason the accessors are being
solved incorrectly on the next run, when we look up the binder we
don't get the same binding the second time around.

(2012-07-10-00:57)

got it, it was indeed a missing labels problem, there were labels that
were available from the type_dependancy constructor but were not being
included, so i just unioned those labels with the labels that we had
already and the unification algorithm seemed perfectly happy to
continue.

i'm going to change the error that the unification spits out so that
it recommends that the developer look into missing labels, while i'm
not certain that this is always the case this is what i suspected
initially, and what it has turned out to be so it's a pretty good
guess.

straight back to the first year report tomorrow, i think i'll try to
write up how current things work with respect to equality types, at
least in some shape or form, and try and write the conclusion which
should just leave me with the literature review to do before i can put
it aside until i speak to joe.

fairouz has offered to read some of the first year report, might be an
idea to do this as another pair of eyes can't possibly hurt. i might
do this tomorrow if i think it looks alright.

(2012-07-10-01:06)

alright i've updated the error message that comes out in the
minimisation algorithm to give a hint to the developer that the
problem may be in the propagation of labels in the unification
algorithm. hopefully this will help someone else, i'm sure i'll need
to know it again.

committing this to the repository, this work wasn't done on a branch
but it really should have been. it would be good to start using
branches for the work that i'm doing and then pushing the unstable
changes to those branches, then the latest changes get backed up in
the repository but the main branch will still compile fine for
everyone.

(2012-07-10-12:20)

it's worth pointing out that the bug joe pointed out around line 3 in
the code:

val x = 1.0;
val y = 2.0;
if x = y
[...]

where the spaces in 'x = y' were not getting highlighted is now
fixed. this must have come from the newer way that things are
represented. i like it when bugs get fixed for free. i'll update the
screenshot that's going in the first year report.

(2012-07-10-14:20)

i'm not sure how to describe the way that equality types that have
been implemented. i don't know if i really want to drag in all the
definitions from the paper and do a full explanation with that. i
think i might just explain an overview of how it works without talking
about how the binders have been extended to hold equality type status
values, accessor solving has been extended to solve these equality
type status values, etc.

(2012-07-10-16:26)

the overview has been updated to describe the analysis engine even
though it was already marked completed. i'm going to use this
definition in the first year work section, breaking off to describe
the whole analysis engine there seemed to be a little out of place.

(2012-07-10-18:48)

alright i've put in some text about the work that's been done on
equality types. i'm marking that section as 'done' and moving on to
the literature review / review of other type systems. i would ideally
like to finish one of these sections today but they are things that i
could spend months working on, so i'll just try to draw a line at a
sensible place.

i've started placing figures here. not 'here' [h] but here [h] using:

\usepackage{float}
\restylefloat{figure}

in the preamble. seems to stop latex doing completely silly things
like filling the rest of the page with text then placing the figure on
the next page when that is very much not desired.

(2012-07-10-23:00)

i've finished off some text for the conclusion now as well, but i
still need to think about some dates for a timetable. i guess i'll
just take two years from now as a thesis submission date, an equality
types completion date, sharing completion date, and fill in the
blanks. it's quite hard to guess this kind of thing but i guess it's
to think more about what's ahead than create anything which is accurate.

*** 2012-07-11
tags: {first-year-report}

(2012-07-11-13:46)

i've figured down some rough dates for things to be completed by
for the first year report, the text has been updated accordingly.

*** 2012-07-12
tags: {other-implementations, first-year-report}

(2012-07-12-01:59)

i'm trying to get this implementation for seminal working so i can
talk a little bit about it in the first year report, i'm using
compiler sources from about 6 years ago so i expect there'll be a bit
of trouble on the way along.

note that in the sources for the ocamlc compiler configuration script,
if you want to install to a certain prefix then you have to go in to
the script and add that in manually, the --prefix parameter is not
supported (well actually it looks like there is some kind of attempt
made there to support this, but i'm not going to start trying to fix
it at this, i just hacked it to make it work for what i need it to do
right now).

(2012-07-12-02:13)

hm i seem to have constructed an example where seminal suggests that a
function be changed so that it throws away its second argument so that
it won't cause a type error. i guess that's valid, but isn't it a
little unlikely that it's what the user actually wished to do?

i think i'll put this example in the first year report.

(2012-07-12-11:03)

oh i forgot that the comments for this lambda-mode were in
japanese. curses! plan is to clean the other-implementations.tex text
up, maybe add something to the text about lambda mode, then send bits
of text out to be proof read. must e-mail joe and ask when he wants
this report at some point today too, it can really be finished off at
any time.

perhaps i should just get it to a finished state today and send that
out, then if joe doesn't want it yet then i can just keep extending
the text, the literature review and so on, until he does want it. that
might be best actually, it would be good to get back on to the
implementation and keep pushing on with equality types. hm.

i guess i should make some viva slides too, that sounds like the kind
of thing that might be necessary. should be straight forward to do,
maybe i should get that done tomorrow if i get the report finished off
and sent out today...

(2012-07-12-12:54)

i've added some more comments to the text that existed which reviewed
λ-mode. i'm going to mark that as 'done' for now, so i can move on to
the literature review and get that cleaned up. hopefully i'll be able
to look over everything at the end of the day.

fairouz asked to look at some of the text, so i've sent her what i've
got at the moment. hopefully she'll be able to look over the overview
if she has time.

going to work on the literature review for the rest of the day and get
that text cleaned up, it needs much more love than it's currently had...

*** 2012-07-13

(2012-07-13-10:28)

need to get the first year report to a completed state today to send
to joe. plan is to then take fairouz' comments on sunday, add those
in, then send that to joe as well in the event that he has time to
read it. in any event the changes will be useful because that's all
text that should be going into the thesis document.

(2012-07-13-16:46)

alright i've updated the literature review and done referencing for
the document. i'll send off an updated pdf now.

it should be noted that i'm sourcing some of my literature review from
the paper-reviews folder that i have in the repository. either they
should be all integrated into the main document, or all of the
literature review paper reviews should end up in there, at the moment
there is some directly .tex file, and some in the paper-review folder,
which is not optimal.

we should also think about having some sort of shared bibtex file for
the ultra group, that might be a good thing to have available
somewhere. something to think about certainly, i know people have
certain formats that they want to stick to so maybe we can define a
format for such a bibtex file. there must be formats that people
already used, maybe there's even a script that will check if a bibtex
file adheres to a certain format. something to look into at some point.

*** 2012-07-17
tags: {first-year-report, latex}

(2012-07-17-23:41)

first year report is all done and been handed in, been working today
on a viva presentation which i've finished. it's worth noting a few
things when using the beamer package.

when including references, the \newblock command needs to be defined
as it's not defined in the beamer document class. so just do the usual
bibtex stuff, but the \bibliography command in a \frame, but add the
following definition at the top of the file:

\def\newblock{\hskip .11em plus .33em minus .07em}

also, when using lstlisting code in a \frame, define the frame to be
fragile by doing this:

\begin{frame}[fragile]{motivation for skalpel project - type error
example}

i'm using the lstlisting package to get background highlighting for
code in .tex files. it can take a bit of fiddling to get the
background text to highlight exactly the way that it's needed, but
there's highlighting in the first year viva presentation (including an
endpoint which has a box), so look there for future reference.

i'm not sure if this is the same mechanism vincent used, maybe it
would be nice to find that out.

the viva is scheduled for tomorrow, i guess work on the analysis
engine will recommence shortly after that and i can continue with
equality types.

*** 2012-07-19
tags: {first-year-report, test-framework}

(2012-07-19-09:21)

started updating the first year report to include joe's comments. i'll
do a little on this, then i'd like to get on with updating the test
framework.

(2012-07-19-12:01)

i have a suspicion that the test framework is not actually rebuilding
the analysis engine binary correctly after it gets the latest sources
from the public repository. i've added a change so that the existing
skalpel analysis engine binary is deleted before the tests are
performed.

(2012-07-19-12:40)

moving the 'sem', 'id', and 'bind' variables which contain some
information (i know enough information about the roles of these to
change their names now i think) into debug statements. at the moment
they are just standard print statements, which when running the test
framework and piping the output to a file runs the /tmp directory out
of space on lxultra8.

(2012-07-19-13:51)

put 6 lines of the first part of git log into the e-mail instead of 5,
when merging branches occur we need 6 lines. i'll look at what results
come out tomorrow, i suspect there's some kind of path problems, but
the compilation errors should make their way into the e-mail now.

(2012-07-19-15:15)

it occurs to me that the test framework should really run tests from a
*fresh clone* of the repository. then the test framework will have to
do the same steps that a user has to do in order to build the test
framework, and can't make use of any existing files that are around.

*** 2012-07-20
tags: {test-framework}

(2012-07-20-10:33)

there was some incorrect code to the repository committed yesterday
with respect to removing a file in a bash script, which broke the test
framework. this should be fixed now.

it's interesting though that the errors file that was generated (which
comes from the /tmp directory) when trying to compile the analysis
engine contained the text that you would think would be part of stdout
(standard mlton based output). maybe that is for some reason sent to
stderr, hm. i'll need to look into that.

i'm adding a change so that errors are no longer reported in a
separate file so instead of doing 1> and 2> for std[out|err]
redirection i'm now doing &>. it's probably going to be easier to read
this way in the e-mail anyway, as if stdout and stderr is interleaved
i might find it a pain to read.

i'm going to probably change the test framework today so that it tests
from a master file as well, that would be a nice addition. also, if
there aren't any differences from the last run test, we shouldn't
bother creating a test report. that should mean that we don't have
lots of test logs in the repository and keep only the interesting
ones.

after i've finished updating that i'll be working on either equality
types or reading some papers. i've also still got the notes from joe
from the first year report to finish typing up, might do that today as
well.

(2012-07-20-14:33)

all the viva-related forms are now handed in. hans and claire are both
happy so that should be that all sorted. apparently they still don't
need my ethical approval form, so i'll just keep it until they do
actually want to receive that information from me.

*** 2012-07-22
tags: {test-framework}

i've changed the crontab entry for the test framework so that the
result of stdout gets placed in my directory, that should help with
debugging any problems that come up. previously only stderr was
directed to a file, but the test framework didn't run today, and no
errors were output to stderr. i think i have found the cause of this
and fixed it, but the stdout output would have been nice to help this
debugging process.

now the crontab entry looks like this:

0 7 * * * /u1/pg/jp95/repos/skalpel/testing/run-test-framework.sh >/u1/pg/jp95/test-framework-output 2>/u1/pg/jp95/test-framework-errors

i've added a bit of documentation to how the test framework operates,
which can be found in
documentation/skalpel-developer-info/test-framework. maybe i'll make a
symbolic link to this from the testing/ folder of the repository, i'll
think about that. there needs to be more text of this form, but this
is all i have time to write at the moment.

*** 2012-07-23
tags: {test-framework, equality-types}

(2012-07-23-12:16)

the test framework e-mail reported a series of failures this morning,
which were a result of me poking it with a sharp stick to see if it
was actually doing what it was supposed to be doing, which it turns
out it was not.

the e-mails from the last couple of days have silently failed to build
the analysis engine, then run tests on whatever version of the skalpel
analysis engine happens to exist in the repository. as we now remove
this binary, the test framework *must* generate a new version
correctly or it will not be able to run the analysis engine tests.

the problem with building the new version of the binary was that the
$path environment variable was not being set when running
cronjobs. i've updated the cron command that we run to load the file i
have which declares my $path, which allows the test framework to find
the binaries it needs to build the analysis engine binary such as
mlton and mllex.

i've also added the analysis engine version hash to the test e-mail,
just to be doubly sure that we are in fact getting the correct
version. hopefully the e-mail that comes through tomorrow morning
should have everythnig fixed.

(2012-07-23-14:44)

i think i've worked out a way for equality type errors to get multiple
endpoints. essentially, all i want to do here is to report two
endpoint labels when reporting an equality type error. the first is
easy to get, as in the function that we're currently in at the point
that we discover that a type error has occurred we always have that
label, which is an endpoint.

the other endpoint label could be gained by doing keeping track of a
label which is responsible for the equality type status that a type
variable has. so if we have some mapping of equality type variables to
equality type status values, we have something like this:

eqtv1 -> equality_type_status(equality_type)
(eqtv2 -> eqtv1 => eqtv2 -> equality_type_status(equality_type))
(eqtv3 -> eqtv2 => eqtv3 -> equality_type_status(equality_type))
eqtv3 -> equality_type_status(not_equality_type)

and an error is detected, because eqtv3 is constrained to be both
equality_type (from eqtv1) and not_equality_type. we have the label
for not_equality_type, but for the equality_type we have available to
us the set of labels that eqtv3 has assigned to it in the map. we need
the *single* label for eqtv1, because that is the endpoint of the
error.

i could either carry through the equality type variable that we
inherit the status from or the label. i think the equality type status
variable will give more meaning to debuggers and makes more sense than
a program point location so i'll try something like that. so
internally we'd have something like this:

eqtv1 -> equality_type_status(equality_type), inferredfrom=none
(eqtv2 -> eqtv1 => eqtv2 -> equality_type_status(equality_type), inferredfrom=some(eqtv1))
(eqtv3 -> eqtv2 => eqtv3 -> equality_type_status(equality_type), inferredfrom=some(eqtv1))
eqtv3 -> equality_type_status(not_equality_type)

so now we'd have the second label because we can look up the existing
eqtv3 inferredfrom value, then grab the *single* label associated with
eqtv1 in the state map. if there is more than one label an exception
should be thrown.

i'm going to try and implement something like this, it seems a
reasonable way to go and will give is the second endpoint that is
needed here for little extra analysis engine overhead.

*** 2012-07-24
tags: {equality-types, labels}

(2012-07-24-14:01)

i've written a few comments in the unification file about how
constraint solving with respect to equality types works which should
hopefully help some people to some degree in the future.

the unification.sml file is far too long, and when working with the
fsimplify function i feel like i'm working in some sort of
forest. perhaps there might be a nice way to split this file up, even
just taking the fsimplify function and putting it in its own file i
think might be a help. i'll think about doing that later.

i've just noticed that there are some cases where the equality type
endpoint isn't correct with the current system where only one endpoint
is reported.

perhaps it's the case that this can happen when solving equality type
accessors, and we end up in the case solving two equality type
variables which have to be equal to one another, but both of those
equality type variables turn out to be of conflicting status values
located after some long chain of constraint solving takes place.

i don't think this is a problem, because the system that i'm working
on at the minute where the equality type variable number is stored
where an equality type status was inferred from means we should have
all the information and are able to report the correct endpoints. i'm
going to do this stuff on another branch, so that the test framework
can compile the master branch, then merge whenever i reach the end of
a day where my changes can be compiled.

also, perhaps the equality type tests that i have should be integrated
into the test framework. my current plan was to wait until i get them
working, then just run skalpel with json output and put it straight in
the test framework, but perhaps it would be better to create the
answers to tests by actually creating the json file by hand. something
to think about anyway.

(2012-07-24-14:46)

aha, i detected a hidden bug in one of my equality type tests, which i
found when i was documenting the function and noticed something
odd. it occurs to me that had i not noticed this, it would have been
extremely difficult to actually find it by trying to debug the program
i have. i've also been worried for a while about a scenario where
someone says "hey, an equality type error isn't detected in my
program, here it is", because there's so much information that needs
to be looked at to understand why that doesn't work. i'm going to
think about this, i really need to improve the debugging print
features available for knowing which equality type variables are
defined, which are changing, and what the differences in the state are
before and after the change.

(2012-07-24-23:39)

the list of labels in the deps field is always empty when solving
equality type constraints. i've noticed this when other constraints
are being solved too, so i'm actually going to make use of it to store
some equality type variables which will result in the user getting the
correct endpoints.

*** 2012-07-25
tags: {equality-types, labels}

(2012-07-25-01:06)

i have to note here that i've changed my mind about how endpoint
labels are going to be tracked. i'd previously thought that i'd pass
the equality type variables around and we could just look up the
program locations that are associated with any given equality type
variable, but in order to use the existing structure i have to pass
around the labels instead.

i think i'm going to go ahead and just pass around the labels, we
don't really loose any information so this approach should really be
fine here and save some development time.

(2012-07-25-11:33)

i've updated the debugging system without updating the text that we
get when executing ./skalpel with no arguments. adding a warning, i'll
fix this up when i get my head out of fixing the current endpoint
modifications.

note: i would love to see some of these eq-testxxx.sml files in the
analysis engine test database today. actually, i would also like to
see these files in a separate folder, with sensible names, and not
stick to the enumeration of tests system that we currently have.

(2012-07-25-13:17)

great! we now get correct endpoint locations for equality type errors,
which means i can start putting some of the tests that i have no into
the test database, and the constraint solving algorithm for equality
types should be finished.

my plans therefore for the rest of the day are to extend the analysis
engine test database so that i can put these tests in a subfolder of
the test database directory with sensible file names, and the analysis
engine won't care (this would be very useful to me, and for the
purposes of demonstration of skalpel). i'll then put the tests i have
in that folder, run the analysis engine tests to check that works,
then figure out what still needs to be done with respect to supporting
equality types. it should be noted that the work that i need to do
should lie solely in the constraint generator , so i shouldn't need to
touch the constraint solver now (hopefully).

(2012-07-25-14:35)

there is a magic numbers bad smell in the code which deals with the
analysis engine test database. the number is 4.

this is probably either supposed to represent the length of ".sml" or
the length of "test" in the filename. i'll figure out which...

(2012-07-25-14:45)

alright, so the number '4' was used twice so that it actually meant
".sml" and "test".

exterminate!

*** 2012-07-26
tags: {test-framework}

(2012-07-26-14:26)

i've finished changing the test framework so that it can handle test
files which aren't named based on enumeration. the way that it works
now is that there is a new file in the analysis engine test folder
called "test-control", which has a list of all the files which the
analysis engine is to test. when adding a new test to the test
database, a developer should just add a standard ml code file with any
name (say x.sml) and a solution file written in json (which is named
x-solution) as before to the test directory, then place the filename
(x.sml) in the test-control file next to the other filenames.

i don't think this code will support sub-directories yet, i'll look
into that now. then we could have folders called say 'functors' which
would contain examples of functors etc. this might come in handy, so
i'm going to add this feature in once i've finished testing the
current code.

(2012-07-26-16:14)

the analysis engine database can now support sub-directories, and all
bugs associated with that have been ironed out hopefully. i'll run the
test framework now on lxultra8 and make sure that still works.

(2012-07-26-17:47)

that didn't still work, but it does now. the mail sent from the test
framework tomorrow should hopefully contain no errors with any luck,
everything should run smoothly.

(2012-07-26-18:16)

i have edited the way that the test framework checks its tests so that
the checking is done against a master copy instead of a copy from the
day before. this should prevent the problem of a failed test coming up
one day, no-one noticing it, and then it won't appear in the next diff
output.

i'll have to remember and update these master files. i've also removed
the tracking of the test logs in the repository, we have the e-mails
and i don't think storing the test reports for each day is really
necessary. we can always look back at our e-mails if we really have
to.

(2012-07-26-19:18)

the json output from the analysis engine when it runs itself on an sml
code file is of a slightly different format to the json that the test
answers are written in. i remember that i was cleaning up what was
actually output from skalpel, as some of the information was no longer
relevant or duplicated in some basic way (eg, the 'ident' field is
just an enumeration of the 'tyvar' field, so why store both?).

i'm going to fix this so that these formats are the same. that should
make it really very easy indeed to add tests to the test database.

the documentation needs to be updated with information how to add
tests to the test database now as i've changed that procedure. i've
added a warning to the top of this file and i'll get around to that soon.

*** 2012-07-27
tags: {test-framework}

(2012-07-27-02:05)

old code numbers should be added to the top of old code files. working
on something else right now so have added a warning and i'll work on
that later today.

(2012-07-27-02:28)

the following output is produced from the tester when debugging is enabled

(testing) tester.sml: cannot find slice: ⟨..datatype ⟨..⟨..⟩ = ⟨..secondcons of ''a..⟩..⟩\n ..secondcons (5.0)..⟩ in [⟨..datatype ⟨..⟨..⟩ = ⟨..secondcons of ''a..⟩..⟩..secondcons (5.0)..⟩]

this is when checking the equality type test i have just put in. the
difference is the presence of the "\n" in the slice that is being
produced by the analysis engine. i don't think this is actually
produced by the analysis engine, this must be some kind of weird
bug. i'll look at this later today.

(2012-07-27-14:49)

the above error was fixed just by removing the \n characters in the
output, i don't have the time to fiddle with even more of this test
code so i'm going to remove this by hand for now.

though the equality type tests are now working some of the numbered
tests are not working with this new format well at all, and are
complaining about dependancy issues. i don't even know which part of
the test file that is specifically complaining about, because the word
'dependancy' can have various meanings in the analysis engine, and
that word doesn't actually appear in the test output. i'll need to
figure out what this is supposed to represent before i can fix it.

it would be nice to get this fixed and have all the equality type
tests committed to the repository today, that's the target at
least. i'm going to update this code that's output to the developer so
that it's more useful first. there are still some error messages that
throw variable names at the developer which aren't helpful and this is
one of those cases, so it's important that it's fixed up.

(2012-07-27-15:47)

ok so the dependancies that are being reported as not being found from
code3.sml are certainly in the test database file. something strange
is going on with the code related to testing whether two context
dependancy lists are in fact the same.

(2012-07-27-16:00)

right, i have tracked down this problem. there is an inconsistency is
the test solutions, where sometimes the context dependencies start at
0 and sometimes they start from 1. i'm just going to track which
number the context dependancies start at in the json file, so i'll
have to fiddle with the parser and export mechanism a little and then
hopefully all will be well.

(2012-07-27-18:50)

the skalpel analysis engine binary now can export json correctly for
use in the test framework apart from the use of the \n separator which
has to be removed manually. there should really be a command line
argument option so that this does not have to happen.

*** 2012-07-28
tags: {test-framework, website}

(2012-07-28-00:18)

a few basic equality type tests have been moved into the analysis
engine test database and now sit under the test control
file. hopefully these tests will pass tomorrow morning and i'll add
probably the rest then.

i noticed there was a problem this morning where the website wasn't
tested for dead links, this should be fixed now and they should get
tested tomorrow morning.

i'm aware that the documentation for how to update tests still needs
to be written, i'll get around to that sometime soon, hopefully
saturday afternoon or something. after that the plan will be to push
forward with equality types and handle more complex cases.

*** 2012-07-30
tags: {equality-types, poster}

(2012-07-30-01:32)

i've updated the analysis engine test database with a few more
examples. i'm not adding the solution to this one yet though, as i'm
not happy with the slice that we get for it:

datatype 'a mydt = firstcons of 'a | secondcons of 'a;

secondcons(5.0) = secondcons(6.0)

i'm not happy with the slice because it led to the discovery of this
bug:

((fn _ => 0) 5.0) = 0

is reported incorrectly as an equality type error. i see why this is
the case, but the analysis engine needs to realise that the result of
the function that is being tested for equality. as the type of the
anonymous function is of type ''a -> int we should be comparing the
equality type status of int (equality_type) against the equals
operator (equality_type) and not the 5.0 real number
(not_equality_type), as this is thrown away.

i have a few tests also which do not report equality type errors (and
they should not, because the code is typable). i'm going to add these
to the test database when i find out what the best way is to generate
that test file when there are no errors (by default, the analysis
engine will simply produce a blank file, indicating that the process
has finished (<name-of-output>-finished).

anyway, it's good to have a few of these test cases in the test
database. there are a couple of things next on the agenda, fixing up
the webdemo, adding webdemo tests to the text framework, updates to
the poster, changes to first year report text, and i'm not sure which
i'm going to pick yet. whatever it ends up being i'll document the
progress in here as per usual.

(2012-07-30-10:20)

old filenames are now at the top of the codexxx.sml files in the
analysis engine test database, so they can be moved to new names
safely.

(2012-07-30-16:28)

i've updated the poster to include some changes for the meeting
tomorrow with joe, we can look at the poster then and decide what
other things we want to change and possibly just change them on the
fly.

i'm going to take a look at the webdemo soon, as that's something
which if i don't look at before tomorrow i might not get the chance
until the end of the week.

*** 2012-07-31
tags: {test-framework, website}

(2012-07-31-01:28)

the skalpel analysis engine *will not run on anubis*. the anubis
server (www) does not contain the libgmp.so.3 library, which the
analysis engine depends on.

this means that the skalpel analysis engine *must* be run on the www2
server.

(2012-07-31-01:33)

nope, that's not the case either.

both the www and the www2 servers do not have the libgmp.so.3 library
available on them, so at the moment it is impossible to run the
webdemo. the solution to this is for one of these machines to have
this library installed.

i'll need to contact it about this, they are really the only people
who can fix that problem. unless i were to include this library in
ld_library_path... but i'm not sure that would work well at all. there
might well also be other dependancies.

(2012-07-31-01:37)

ah, that actually worked. i copied libgmp.so.3 from lxultra8 into the
binary folder, updating ld_library_path to include the current
directory, exported the environment variable, and now the binary will
at least execute.

even better, the binary generated type error slices. i shall play
around with this tomorrow.

the url that the user gets for type error slices doesn't look right to
me, as the slice output gets put in /lib (well, not the actual slice
output, as that currently doesn't even exist, but the output of a
'tohtml' script places things there) and the url looks like something
quite distinct from that.

a solution might be to:

1) update the skalpel binary (because it's pretty old)
2) make sure libgmp.so.3 is found
3) get the slices output to the correct location (wherever that might
   be)
4) direct the user to this correct location

hopefully the user will actually get some output after these four
steps. once the webdemo is working i need to think about:

-> how to import test cases now with the new analysis engine test
   database format?
-> how can the test framework be extended to test the web demo,
   because mark my words it will break again.

(2012-07-31-13:11)

right, so after spitting out the errors to the log files that are
output by slicing.cgi (these appear in /tmp on the www2 server) it is
indeed complaining about libgmp.so.3. i've included this in
ld_library_path.

the skalpel analysis engine binary is complaining that an input file
is not being specified now so i'm changing slicing.cgi on the fly. i'm
documenting my changes here so that i can repeat them on the
slicing.cgi file that sits in the repository and install the website
and webdemo from scratch. at the moment, i'm changing a temporary
file and the files will be destroyed.

system call line changed to the following:

system("ld_library_path=.:./bin/:$ld_library_path; export ld_library_path; ./bin/slicer -b 2 ./lib/basis.sml -s /tmp/$session.sml -p /tmp/$session.sml.pl &> /tmp/$session.log");

the binary (./bin/slicer) is now the skalpel binary from my bin/
folder of the repository (so it is not actually the webdemo binary, it
is the standard binary with the name change). an error is reported
that an input file is not specified (makes sense, because it isn't
specified in the system line).

(2012-07-31-13:24)

huzzah! i got some slices! how nice. another change to the system
line, it is now as follows:

system("ld_library_path=.:./bin/:$ld_library_path; export ld_library_path; ./bin/slicer -b 2 ./lib/basis.sml -s /tmp/$session.sml -p /tmp/$session.sml.pl &> /tmp/$session.log");

the change is that skalpel no longer thinks the input file is an sml
that it should be outputting information too. this fixes the actual
analysis engine process up, and this works fine.

the user is taken automatically to a url like the following:

http://www.macs.hw.ac.uk/ultra/skalpel/tmp/50/5017/5017cf1b6273.html

from the original location of:

http://www2.macs.hw.ac.uk/cgi-bin/cgiwrap/~jp95/slicer/slicing.cgi

this url they are taken to is incorrect. it should be this:

http://www.macs.hw.ac.uk/~jp95/cgi-bin/slicer/tmp/50/5017/5017cf1b6273.html

if they are taken to that url then the user will be able to see type
error slices for the code.

also, what is going on with the link when the user clicks on 'online
demo'. from http://www.macs.hw.ac.uk/ultra/skalpel/index.html the user
is directed to
http://www2.macs.hw.ac.uk/cgi-bin/cgiwrap/~jp95/slicer/slicing.cgi,
but from
http://www2.macs.hw.ac.uk/cgi-bin/cgiwrap/~jp95/slicer/slicing.cgi the
user is directed to
http://www2.macs.hw.ac.uk/cgi-bin/cgiwrap/~jp95/skalpel/slicing.cgi,
which is a directory that does not exist. the folder i have is called
'slicer' and not 'skalpel' (it should probably be called
'skalpel'). the point is that these links are pointing to two
different locations, this shouldn't be a circumstance that can
arise. this will need to be fixed also.

(2012-07-31-13:32)

i'm going to dare to apply the changes i have made so far and install
the website and webdemo. i remember i updated the documentation for
this so hopefully everything will still be fine.....

(2012-07-31-13:36)

in the webdemo makefile, i'm updating my location of the webdemoadr2
to be:

webdemoadr2 = ${macs2}"cgi-bin/cgiwrap/~jp95"/skalpel

instead of

webdemoadr2 = ${macs2}"cgi-bin/cgiwrap/~jp95"/slicer

'slicer' folder in my cgi-bin director has been moved to slicer-old for
backup. i expect to find a new 'skalpel' directory in its
place. skalpel website is also backed up to
/home/www/macs/ultra/skalpel-backup (from /home/www/macs/ultra/skalpel).

(2012-07-31-13:43)

yes, this is now a little more complicated. programs and libraries are
missing from the webserver that are needed to install the website and
webdemo (because we do things like compile the analysis engine binary,
generated documentation using org to html conversion, etc).

for the moment, i'm going to add the relevant libraries to my
ld_library_path and try and work round it that way. i'll have to
e-mail steve about this.

** 2012-08
*** 2012-08-01
tags: {test-framework,

(2012-08-01-05:53)

can't sleep, must be the excitement of solving all problems... :-)

i'm trying to get the webdemo working through things that i shouldn't
have to do, i'll probably e-mail steve even if i get this working.

the ls command and the cp command don't work due to the following
missing libraries:

libacl.so.1
libattr.so.1
libselinux.so.1
libsepol.so.1

i have added these to my home directory (copied from lxultra8) and
used the ld_library_path environment variable to allow the webserver
system to find them, and i'm now able to use ls. huzzah! hopefully i
will also be able to use cp.

(2012-08-01-05:57)

emacs does not work though, missing libgtk-x11-2.0.so.0. hopefully i
won't need to fix that problem as i might be able to avoid using it on
the www server...

(2012-08-01-05:58)

cp works! a luxury indeed! the broken emacs though is breaking the
webdemo installation as alas it is needed to convert sml.org into
sml.html for viewing on the web. copying this library from lxultra8 in
the hope that will sort things out...

also copying some files to get zsh working, that shell is more
powerful so i prefer it. it's not critical to get this working though
and other users may not use this shell, but i'll list this here anyway
in case i need to find it again. here's the libraries i've taken from
lxultra8 in total:

for basic shell functionality:
libacl.so.1
libattr.so.1
libselinux.so.1
libsepol.so.1

for emacs:
libgdk-x11-2.0.so.0
libgtk-x11-2.0.so.0
libatk-1.0.so.0
libgdk_pixbuf-2.0.so.0
libpangocairo-1.0.so.0
libpango-1.0.so.0
libcairo.so.2
libgobject-2.0.so.0
libgmodule-2.0.so.0
libglib-2.0.so.0
libsm.so.6
libice.so.6
libtiff.so.3
libjpeg.so.62
libpng12.so.0
libz.so.1
libxpm.so.4
libx11.so.6
libxrender.so.1
libxft.so.2
libfontconfig.so.1
libfreetype.so.6
libasound.so.2
librsvg-2.so.2
libdbus-1.so.3
libgpm.so.1
libncurses.so.5
libgconf-2.so.4
liborbit-2.so.0
libgthread-2.0.so.0
libxext.so.6
libxinerama.so.1
libxi.so.6
libxrandr.so.2
libxcursor.so.1
libxcursor.so.1
libxcursor.so.1
libxcursor.so.1
libxfixes.so.3
libpangoft2-1.0.so.0
libxau.so.6
libxdmcp.so.6
libexpat.so.0
libxml2.so.2
libcap.so.1
libdbus-glib-1.so.2
libssl.so.6
libcrypto.so.6
libavahi-glib.so.1
libavahi-common.so.3
libavahi-client.so.3
rlibbz2.so.1
libgssapi_krb5.so.2
libkrb5.so.3
libcom_err.so.2
libk5crypto.so.3
libkrb5support.so.0
libkeyutils.so.1

for zsh shell:
libgdbm.so.2
libncursesw.so.5

(2012-08-01-07:17)

erm, that was more libraries than i thought! oh well. i used this
command (which could be improved upon) to copy these files, might come
in useful:

(error=`ls ~/ > /dev/null; emacs --version 2>&1 | grep "error" | sed s/".*libraries: "// | sed s/": cannot.*"//`
echo "handling: \"$error\"..."
ssh lxultra8 "cp /lib/$error ~/ 2>/dev/null; cp /usr/lib/$error ~/ 2>/dev/null"
)

this just strips the name of the library that has not been found and
tries to copy it from /lib and /usr/lib on lxultra8, silently failing
when it doesn't copy the errors. this could be put in a loop to speed
things up (but if anyone reading this does this, do something when
silent failures happen otherwise the script will loop forever if a
library doesn't exist on lxultra8 in either location).

ok, running the webdemo script again.

(2012-08-01-07:21)

the webdemo script is now failing because it can't find the code*.sml
files. ok, this is good, this is one of the errors that i expected to
fix in the first place.

for the moment i'm just going to tell the webdemo script that the
files are in the numbered/ folder of the skalpel repository, as it'll
find all the code files it wants there.

(2012-08-01-07:26)

the webdemo doesn't actually edit the users public_html directory to
put the webdemo there. placing the directory manually.

(2012-08-01-07:30)

great! some things work, some things don't. all menu bar links to the
left hand side of the web pages seem to work absolutely fine so that's
a win. here's what needs to be changed:

1. code examples don't show up on the example page
2. when running code examples (tested manually), the user gets sent to
   the wrong url to view the slice
3. webdemo installation should copy install files to the cgi-bin
   folder of the user executing the install script, otherwise the user
   will be sent from the www server to a nonexistant cgi-bin
   directory.

(2012-08-01-09:00)

i notice that the skalpel binary has not been created. the webdemo
isn't producing any slices, this is probably why. the name of the
skalpel binary has changed since the last installation, so it's
probably something to do with that.

(2012-08-01-09:06)

actually, it doesn't:

make[1]: entering directory `/u1/pg/jp95/repos/skalpel/analysis-engines/standard-ml'
mllex  parse/ml.lex
mllex: error while loading shared libraries: libgmp.so.3: cannot open shared object file: no such file or directory
make[1]: *** [mlton-base] error 127

i guess i need to add the limgmp.so.3 library to my nice large list of
files. it seems to be working for me so far to locate and place
binaries in my ld_library_path, so i'll just continue!

(2012-08-01-09:16)

this doesn't work, the web demo fails to create the analysis engine
binary. i'm going to change it so that the user specifies the location
of the analysis engine binary, it'll be better than the web demo
building it anyway because it's slow.

(2012-08-01-09:54)

alright, the links problem is fixed, the user should be able to get to
the page showing the slices. pity there aren't any! no slices are
showing for any input, which must be some problem involving the
binary, looking into it now.

(2012-08-01-10:27)

right so when the webdemo runs i now get this error:

./bin/skalpel: error while loading shared libraries: libgmp.so.3: cannot open shared object file: no such file or dire
ctory

that's about as far as i can go with this. i can't just provide this
file, as there are other dependencies that file is linked to which
don't exist. when steve installs the gmp library, the webdemo should
be fully working aside from the code needed to read the new locations
of the code*.sml files.

(2012-08-01-14:48)

updateexamples is the script responsible for updating the code*.sml
files. i think it's looping infinitely...

(2012-08-01-15:24)

these webdemo scripts are a bit ruthless on the developer when one
makes a mistake (sometimes we put a / at the end of directory paths in
variables, sometimes we don't. if you use the wrong one strange things
can happen such as a script looping infinitely). got to look out for
that!

anyway, the web demo now detects the code files from the test database
location (because the numbered code files haven't had their names
changed. it might indeed be good to have some conversion mechanism so
that the web demo can still understand it.

so the bottom line is everything looks like it's working, so when the
gmp library gets installed we should have a working webdemo.

(2012-08-01-16:21)

i've managed to get the dependancy list for the web demo down
significantly from about 60 packages. i've added another make target
that will generate files in the repository (such as building the
analysis engine binary, getting an html file from sml.org and so on),
with the idea in mind that the developer can run that make target on
their normal machine (in my case lxultra8), then just run a cut-down
version of make install-webdemo on the web server. it's much better
this way anyway, compiling binaries on the web server isn't a great
idea anyway.

we do certainly need to be able to run the analysis engine binary
though, no getting away from that. i'll get on to steve now to install
the gmp library, but i won't mention the others; we don't need to be
able to compile the analysis engine on the web server.

(2012-08-01-20:42)

i've made a few updates to the poster, looks like i'm going to get a
fair amount of space to play with by the time i've made these
edits.

the test framework should be able to check the website for dead links
tomorrow, it failed its test this morning to do that because i was
busy installing and uninstalling it during all this webdemo
installation.

*** 2012-08-02

(2012-08-02-12:42)

i'm still working on getting the webdemo working, i realise that the
gmp errors are coming the fact that web server runs a different
machine architecture to lxultra8. this means that skalpel needs to be
compiled on the webserver.

i'm hoping that after re-installing on the web server's 64-bit
architecture i'll be able to compile skalpel on it. i'm trying to
compile mlton on it now but i remember that compiling mlton requires
an sml compiler to be installed which is annoying. i'll have to
install poly/ml and try to compile mlton with that. i'm determined to
get around to working on equality types today, i don't want to loose
all days installing software and fiddling with libraries.

(2012-08-02-12:48)

installing poly/ml now to ~/software-64. i'll make this a publicly
accessible folder so that anyone can run the binaries inside.

(2012-08-02-12:53)

to install mlton with poly/ml, use the 'make polyml-mlton' command. i
couldn't find this information in the installation document on the
website so i've put it here.

apparently that only gets you so far through the installation then the
compiler defaults back to mlton. what seems to happen is that the
makefile from the root of the source download heads into the mlton/
folder of the sources and runs 'make polyml-mlton' which then dies
because mlton is not installed.

(2012-08-02-13:13)

okay, so part of the output when compiling mlton with poly/ml is this:

-bash-4.1$ make polyml-mlton
[...]
/bin/sh: mlton: command not found
make: mlton: command not found
make: mlton: command not found
make: mlton: command not found
make: mlton: command not found
make -c front-end ml.lex.sml
make[1]: entering directory `/u1/pg/jp95/software-64/mlton-20100608/mlton/front-end'
rm -f ml.lex.sml
no-mllex ml.lex
make[1]: no-mllex: command not found
make[1]: *** [ml.lex.sml] error 127
make[1]: leaving directory `/u1/pg/jp95/software-64/mlton-20100608/mlton/front-end'
make: *** [front-end/ml.lex.sml] error 2

it seems to proceed on anyway and say that the no-mllex command is not
found. after looking in the sources, i've found that if the compiler
can't find ml-lex, then it changes the name of the command to execute
to 'no-mllex' ending up with the output:

make[1]: no-mllex: command not found

even though no-mllex is not a command.

it's proceeding with the installation so i'm going to try and install
part of the sml/nj compiler on the web server (the full thing can't be
installed, because sml/nj does not run on 64 bit architecture
machines). hopefully i can build ml-lex and ml-yacc and that will
help.

(2012-08-02-13:35)

"running ./build requires a properly functioning installation of
sml/nj."

./build is a script in the sml/nj sources. so i can't build
ml-lex. hmm

(2012-08-02-13:49)

i have managed to copy ml-lex and ml-yacc from a machine i own of the
same architecture to the web server which just so happens to run
(usually, there would be library problems with this).

now i'm getting this: "cc: mlton-polyml.o: no such file or
directory". fantastic, that's not useful. there are still mlton errors
on the previous lines though that are spat out because mlton is not
installed. how am i supposed to build this software if i don't have it
already installed? this is just a nightmare. i'm going to try fiddling
around with a few things but then i'm going to move on to equality
types, or this is just going to eat all my time.

(2012-08-02-14:17)

steve e-mailed me to tell me that mlton was installed on a test system
for me to look at before it was installed system-wide. as a stroke of
luck, i noticed that mlton was installed on a 64 bit test system
(osiris). the mlton binary was compiled with that and used to install
the webdemo, and now we have a working web demo! thank god for that.

i'm going to test the poly/ml installation that steve has on the test
system, then if that's fine i'll ask him to roll that out system wide
along with rlwrap and mlton.

(2012-08-02-16:12)

going to work on the poster for the rest of the day, and spend
at least the majority of tomorrow on equality types.
=======
*** 2012-08-03

(2012-08-03-11:26)

it occurs to me that being able to print out a program with its label
information would actually be very useful. i'm getting debug output
like this:

(equality_types) unification.sml: solving an equality type constraint of equality_type_var(eqtv19686) and equality_type_status(not_equality_type). deps = [40162] and labels = [40161,40162]

(equality_types) unification.sml: solving an equality type constraint of equality_type_var(eqtv19691) and equality_type_status(equality_type). deps = [] and labels = [40164]

there's nothing really wrong with this except that i can see that for
example equality type variable 19686 is being constrained to be
not_equality_type which comes from the endpoint label 40162. but what
is that label? i actually know what it is, because the program is so
small there's only one location that could actually have come from,
but in cases where the label output is larger it can be more difficult
to find out why different constraints are being made at any given
time.

i don't know how much work this would be (hopefully little work), but
something to think about.

(2012-08-03-12:36)

in the slice.sml file we basically have a bunch of functions which
handle every datatype constructor from the abstract syntax tree and
print it out. the datatype constructors from this tree basically have
label information everywhere anyway.

if i could re-use that function to print out a 'slice' of the entire
file, with with some option enabled to print label information, that
that would give me what i need.

(2012-08-03-13:09)

there might be something here to do exactly what i want, i was using
the printslice function but using the printastprogs function will
print the information for me which is exactly what i want.

it would be nice to get the label information output in more readable
format, ideally in the same format that is presented in the papers,
automatically. i guess i should just be able to do this by parsing the
output of printastprogs and just turning it into latex. something to
think about certainly.

(2012-08-03-13:20)

printastprogs doesn't store things like \n characters and spacial
information, which isn't actually surprising. maybe it's best to use
printslice after all and just extend that...

*** 2012-08-04

(2012-08-04-11:17)

i started working yesterday on a more basic equality types problem
which showed the problem where labels were not being propagated
correctly, which is now fixed. today i'm going to try and compile a
list of the various equality types features which i have yet to work
on. i'm also going to extend the work i did on getting labelled
program output,  and need to look at how the web demo analysis engine
binary is different from the normal binary, i suspect we make this
distinction without much justification. perhaps not, but it's good to
check these things out.

(2012-08-04-14:39)

oof, this outputting a labelling program is such a pain because of the
representation of the abstract syntax tree. oh well.

i'm making quite heavy use of \operatorname for these purposes. it
would actually be quite good if skalpel were to output a .tex file
with all this information in it and then compile it for me to produce
a .pdf, but i probably won't have time to do that, at least at the
moment.

for the meantime i'll just use mathbin to parse the output that the
analysis engine gives me.

(2012-08-04-16:25)

i've extended the print system now to give out \operatorname for
anything which isn't a label or some form of dots or bracket when
slices are output with the program_labelling debug mode (./skalpel -d
program_labelling). i still need to add in some code to export the
labels along with this information.

i'm going to just do this for the program that i'm working on right
now as i want to push on and get some of this working.

note to self, make good use of the extra binding keys on the
keyboard. holy jesus they are useful.

(2012-08-04-17:51)

hm, i'm unsure how to display the label information. i'm just
intending to put it as superscript but the problem with that is that
it is confusing to see just what that label represents. we need some
kind of brackets round the whole thing.

we have a shortage of brackets, hm. i'm going to see what they do in
the haack and wells paper.

(2012-08-04-17:57)

there are examples of program labelling in there but all the labels
aren't shown, probably because it would blown the user away. for now
i'm going to use big brackets with \bigg[ around the labelled stuff
for now, that will look clear in the latex output at least and should
be easily changeable.

(2012-08-04-18:19)

hmm, the new line characters aren't showing up in latex (because latex
ignores \n, something like \\ will work). i'll have a look and see if
there's an easy way to change that.

essentially every \n character when exporting to latex should be
changed. should be an easy search and replace right?

(2012-08-04-18:21)

hm, there are a few places where this could be changed:

1. tostring
2. transfun
3. seplines
4. printproglist
5. printoneslice
6. printslices

i'll check these out.

(2012-08-04-18:34)

it was the seplines function. it might be worth checking out some of
these other functions later to check there's going to be no breakage.

(2012-08-04-19:04)

i'm about half way through the exporting labelled program stuff i
think. going to try and finish this off later this evening if i can
find the time. looking less likely i'll get that equality type passing
that i wanted to but this labelled program output will really be
rather useful so i think it's worth it.

*** 2012-08-05

(2012-08-05-03:47)

hm, i'm still working on getting a labelled program output. this has
taken more time than i thought it was going to.

this probably would have taken less time if there was a better
representation of the abstract syntax tree, that's probably something
worth thinking about.

on the other hand, the abstract syntax tree can be easily changed when
we move to another language, maybe it's just best to stick with it
until that point, then we can make a better representation for that.

(2012-08-05-04:42)

ugh, done at last! there may well be breakages in the test e-mail
that's going to arrive at 7am, this will happen if i've accidentally
added debug strings into some of the text that comes out to the case
where the is *not* supposed to be debug output instead of the other
way around.

it's an easy fix in any case. i'll look at which tests fail (if any),
take the constraint generation debug rules to see which abstract
syntax tree nodes are being visited, and then use that information to
change the text that's output from slice.sml.

(2012-08-05-13:48)

the stuff that i did last early this morning works nicely, but i see
that when i'm reading the label information from the output that it is
difficult to see the matching brackets. i'm going to try and use the
tikz package to fix this, though i haven't used it before it looks
like the best way to do things.

my current idea is to have each opening and closing big square bracket
('\bigg') as a plain node, and then draw a curved line between these
two nodes. the issue is that all the text in-between also has to be a
node, and positioning problems comes into play.

perhaps the best way is to do something like this:

\newlength{\mylabelwidth}
\begin{document}
\begin{tikzpicture}
  \node[draw] (a) {a};
  \settowidth{\mylabelwidth}{\pgfinterruptpicture some label \endpgfinterruptpicture}
  \node[draw,right] (b) at ([xshift=\mylabelwidth+10pt]a.east) {b};
  \draw[->] (a) --(b) node [midway,above] {some label};
\end{tikzpicture}

so the length is stored appropriately. i'll have to have a think about that.

(2012-08-05-15:09)

oh hell maybe just assigning colours for the brackets would be
easier. or having different sizes and colors of brackets....

ah, what about having standard ml generate some latex code which has a
colour assigned to it at the level where it generates the \bigg[ and
\bigg] brackets, then it would be the standard ml code that would make
the brackets have the same colour.

yeah... that should work... i think. i'll try that out.

(2012-08-05-18:13)

huh? calling a random number function randrange with a lower bound x
and an upper bound y such as with randrange(0,6) should probably
return a random number. why does it return a datatype with four
components, each of which i have to now examine?

oh well. that's what i'm using from the sml/nj library to generate the
random colours for brackets anyway in the labelled program output so
that i can tell them apart.

(2012-08-05-11:44)

going to finish off this program labelling stuff before i go to
bed. the random number generation stuff is a bit poorly documented, so
i'm just playing around with it. i've managed to get it to actually
output a number, but it's constant every time. maybe there's some
seeding that needs done somewhere...

i must check that the software to be installed system wide is actually
getting done, i shall do this tomorrow. i intend to spend probably
most of the day on equality types stuff and a little on the poster
too. that should really be completed before the end of the week.

*** 2012-08-06

(2012-08-06-01:27)

finished with the output of program labelling. there are other
improvements that can be made to it but that i intend to do after i
get a bit of equality types work done.

(2012-08-06-10:54)

i see that equality type constraints aren't correctly configured when
dealing with valbindcore.

if we have something like this:

datatype 'a mydt = firstcons of 'a;
val x = firstcons(5.0);
x = x

then there is no equality type error detected, however if we have
this:

datatype 'a mydt = firstcons of 'a;
val x = 5.0;
x = x

then the equality type error is correctly detected. i guess there must
be something funny with the way equality type constraints for datatype
constructors are getting generated, either that or there is a
constraint generation rule being fired that i haven't written equality
type code for yet.

(2012-08-06-12:21)

hm, i think this is a binder issue. i think when the binder is put in
for x where x = firstcons(5.0); for some reason the top level label
somelabelnum [firstcons(5.0)]^{somelabelnum} is not set to be
not_equality_type status, so when it's put into the state map the
error isn't detected.

that's the working theory at least.

(2012-08-06-12:48)

ok i think i see the problem. when we look up the binder for each of
the x = x values, the equality type information that is present in the
state map is equality_type_status(unknown), which is likely the cause
of the problem. i see that the label information for this program is
[40143,40147,40148,40149,40154,40155,40156,40157,40158,40159], which
is enough information to conclude that this is is of status
not_equality_type (though the state map should probably contain a
variable which holds this information, not just a status).

(2012-08-06-13:23)

hmm, i'm not sure whether to change the way the constraint generation
algorithm works a little, or whether to change the constraint solving
algorithm. when looking up a binder such as x is the example i was
looking at earlier today, this is output by the debugging mechanism:

(equality_types) unification.sml: bind = type_dependancy(type_constructor(typename_dependancy((n242,declaration_cons(1692),l40144),[40143,40144],[],[]),row_dependancy(row_construction([field_construction((1,
l40145):type_dependancy(type_poly(row_dependancy(row_construction([field_construction((1,l39728):type_dependancy(type_constructor((n5,declaration_cons(61),l784),row_dependancy(row_construction([],-,l785),[78
3,785],[],[]),l784,equality_type_status(unknown)),[0,3,4,5,6,782,784,1032,39729,39730,39731,39732],[],[]),l39728),field_construction((2,l39728):type_dependancy(type_constructor((n5,declaration_cons(61),l784)
,row_dependancy(row_construction([],-,l785),[783,785],[],[]),l784,equality_type_status(unknown)),[0,3,4,5,6,782,784,1032,10084,10085,10086,10087,10088,10089,10090,10091,11132,11133,11134,11135,11136,11137,11
138,11139,11140,11141,11143,11144,11145,39734,39735,39736,39737,39738,39739],[],[]),l39728),field_construction((3,l39728):type_dependancy(type_constructor((n302,declaration_cons(61),l10090),row_dependancy(ro
w_construction([],-,l10091),[10089,10091],[],[]),l10090,equality_type_status(unknown)),[0,10084,10085,10086,10087,10088,10090,11160,11161,11162,11163,11164,39741,39742,39743,39744,39745,39746],[],[]),l39728)
],-,l39728),[39725,39726,39727,39728,40162],[],[]),51,poly,constant(5.0,373,40162),l40162,equality_type_var(eqtv19685)),[40146,40147,40148,40149,40150,40151,40158,40159,40160,40161,40162],[],[]),l40145)],-,l
40145),[40143,40144,40145],[],[]),l40143,equality_type_status(unknown)),[40143,40147,40148,40149,40154,40155,40156,40157,40158,40159],[],[])

if there is an equality type status that isn't at the top level (isn't
embedded somewhere in type_dependancy), then we constrain the accessor
to have that status (and only that status, actually. if there are
future statuses, then we ignore them).

so the questions posed here are:

-> should the top level equality type information,
   equality_type_status(unknown), actually be something else and that
   is there erroneously?

-> should the constraint solving algorithm take all status values and
   all equality type variable values inside the binding expression and
   constrain the accessor to be equal to each one?

decision to follow. this should result in an equality type error being
detected without breaking any of the existing tests.

(2012-08-06-13:40)

just discovered an error on my hard disk. pushing now just in case. :/

(2012-08-06-14:42)

i have decided to go with option one. switching to devel and going to
implement this. i'm hoping that i'll be able to do this today and pick
some other parts of equality types to start working on. i'm not sure
exactly what there is to do, so i might start by making a list.

(2012-08-06-16:47)

we no longer strip equality type status values directly from the
binding occurrence. instead, i'm going to change the
stripequalitystatus in ty.sml function so that we strip equality type
variables to create constraints from each of the variables in the
binder to the accessor.

(2012-08-06-16:56)

hm, i'd really rather not strip things at all. it would be really
great if i could get the top level equality type information holder to
contain all the information that i could need. i'll look into this
now, and add back in some kind of strip based solution if i do need to
look at all the information in the binder.

(2012-08-06-17:00)

i've removed the stripping of equality type status values and it
doesn't affect the tests. excellent, i didn't like that
solution. hopefully i'll be able to get this binder represented nicely
in the state map and that should fix the current test.

(2012-08-06-17:45)

the controlling of this top level equality type information is either
done in constypenamevar or stripdepsty. i'm randomly changing unknown
values to equality_type to figure out where this information is coming
from but i think i've tracked it to one of these locations.

constypenamevar has a comment indicating that it is used in the
binding of datatypes, which sounds like that could be the cause of the
issue. checking it out now.

(2012-08-06-17:50)

constypenamevar is the source of the issue. it is always returning
equality_type_status unknown, most likely because i hadn't got around
to writing that code yet, but now is the time.

i'll probably parameterise this function and then i'll need to figure
out what to put in each of the cases that call this
function. hopefully it's only called in a limited number of places and
i have equality type variable information in the functions that call
them.

(2012-08-06-17:53)

the good news is that it's only being called in one place. the bad
news is that it's being called from f_datbind, the function which
handles the binding of datatype constructors.

the reason why this is bad is that it's unknown at that point whether
there is going to be an equality type error or not. for example:

datatype 'a mydt = firstcons of 'a
val x = firstcons(5.0)
val y = firstcons(2)
y = y

there is no equality type error here. the problem is that changing
constypenamevar would mean that we are changing the equality type
status of mydt as a whole, at line 1, which would make this program
incorrectly report an equality type error.

the solution to this is to look deeper into the binding. so when the
analysis engine sees something like this:

(equality_types) unification.sml: bind = type_dependancy(type_constructor(typename_dependancy((n242,declaration_cons(1692),l40144),[40143,40144],[],[]),row_dependancy(row_construction([field_construction((1,
l40145):type_dependancy(type_poly(row_dependancy(row_construction([field_construction((1,l39728):type_dependancy(type_constructor((n5,declaration_cons(61),l784),row_dependancy(row_construction([],-,l785),[78
3,785],[],[]),l784,equality_type_status(unknown)),[0,3,4,5,6,782,784,1032,39729,39730,39731,39732],[],[]),l39728),field_construction((2,l39728):type_dependancy(type_constructor((n5,declaration_cons(61),l784)
,row_dependancy(row_construction([],-,l785),[783,785],[],[]),l784,equality_type_status(unknown)),[0,3,4,5,6,782,784,1032,10084,10085,10086,10087,10088,10089,10090,10091,11132,11133,11134,11135,11136,11137,11
138,11139,11140,11141,11143,11144,11145,39734,39735,39736,39737,39738,39739],[],[]),l39728),field_construction((3,l39728):type_dependancy(type_constructor((n302,declaration_cons(61),l10090),row_dependancy(ro
w_construction([],-,l10091),[10089,10091],[],[]),l10090,equality_type_status(unknown)),[0,10084,10085,10086,10087,10088,10090,11160,11161,11162,11163,11164,39741,39742,39743,39744,39745,39746],[],[]),l39728)
],-,l39728),[39725,39726,39727,39728,40162],[],[]),51,poly,constant(5.0,373,40162),l40162,equality_type_var(eqtv19685)),[40146,40147,40148,40149,40150,40151,40158,40159,40160,40161,40162],[],[]),l40145)],-,l
40145),[40143,40144,40145],[],[]),l40143,equality_type_status(unknown)),[40143,40147,40148,40149,40154,40155,40156,40157,40158,40159],[],[])

the top-level equality type information is
equality_type_status(unknown). this is coming from
constypenamevar. this will always be unknown, we can't possibly know
equality type information at that point in the program.

instead, the solution is to look deeper in, where other equality type
information is present. above, for example,
equality_type_var(eqtv19685) is there, so we can create a constraint
for the equality type variable representing the accessor to be the
same as that. i just looked up what this is in the state map:

(equality_types) unification.sml: solving an equality type constraint of equality_type_var(eqtv19685) and equality_type_status(not_equality_type). deps = [] and labels = [40162]

label 40162 is the real number '5.0'. this will give an equality type
error, but will not have all the correct labels. the labels will show
a) the 5.0, b) the x accessor and c) the 5.0 number. we should see
much more information including:

-> the binding of firstcons
-> the accessor of firstcons
-> the binder of x

(2012-08-06-18:22)

hmm, at the point where that equality type variable is discovered, it
is an argument to a type_poly constructor. the type_poly constructor
with just the equality type variable and labels is this:

type_dependancy(type_poly(<...>,51,poly,constant(5.0,373,40162),l40162,equality_type_var(eqtv19685)),[40146,40147,40148,40149,40150,40151,40158,40159,40160,40161,40162],[],[])

well, that accounts for most of the labels! the only label this
doesn't account for is the binding of x at the point in the program
below:

datatype 'a mydt = firstcons of 'a;
val x = firstcons(5.0);
    ^
  here
x = x

every other relevant label is however included. if this other last
label can be accessed then this should be possible...

i should have this label. it should be available when solving the
accessor as a whole. checking...

(2012-08-06-18:30)

yup! that's the final piece of the puzzle. so the plan now is when
solving equality type accessors:

-> look through the binding to find equality type variables

-> constrain the equality type variable in the accessor we are solving
   to be unifiable with each of these equality type variables

-> when creating the above constraint, take the labels that belong to
   the datatype constructor which holds an equality type
   variable. also take the label from the binder of the accessor that
   we are looking up, and the labels associated with the equality type
   variable we find (these should be in the state map)

questions i need to think about are:

-> what happens if the binding contains multiple equality type
   variables?

-> is the top level datatype constructor's equality type information
   the only important one if it's available?

i don't know the answers to these yet. i'll think about these over
dinner. hmmm.....

(2012-08-06-20:41)

i'm going to make the constraints in such a way that the accessor we
are solving at the time is constrained to be unifiable with all of the
equality type variables that are present in the binder.

i'm hesitating to do this a little because i'm wondering if the user
might get extra slices than they should get. perhaps not. i'm going to
write up the implementation for this and run it on some examples then
look at the results. in any case this solution should work fine for
this test, i'm just concerned that it might produce problems on larger
tests.

(2012-08-06-20:55)

i've thought about this some more and i don't think that this will
produce problems.

if we find some binder with three equality type variables α, β, and γ,
and we are currently solving an accessor constraint with equality type
variable δ, then the following constraints would be created:

δ -> α
δ -> β
δ -> γ

there are various situations that can occur:

1. one equality type variable in the binder causes an equality type
   error (say β), but the others (α, γ) don't. that's completely fine,
   the user will only get one relevant error and because we take the
   labels associated with the constructor that holds β, they will get
   the correct error. this is the case that the code example i've been
   looking at falls into.

2. none of the configurations generate an equality type error. the
   user doesn't get any error, the code for this purpose can be
   typable.

3. δ -> α and δ -> β both are equality type errors, but β is the
   equality type variable associated with a datatype constructor,
   which in one of its field holds a datatype constructor with has α
   associated with it. in a sense β is "higher up" than α, so it has
   different labels. if it has labels which are not relevant to the
   equality type error, and when they are removed we get the same
   constraint as δ -> α, then this is the same error, and the analysis
   engine will realise this and remove the duplicate. if δ -> β and δ
   -> α are both equality type errors, but both have different label
   sets and none of these labels can be removed, then we have two
   distinct errors, and the user should be presented with both. the
   analysis engine should take care of that already.

4. all of the equality type variables in the binder will cause an
   equality type error when δ is constrained to be unifiable with
   them. that's alright too, that's just case 3 repeated over and over
   again.

i'm going ahead and writing this. i think i'm right, but i'll test the
results just in case.

(2012-08-07-22:02)

hmm, what to do about the type dependancy case. we have type
dependancies... inside type dependancies, even in the case that i'm
currently solving:

bind = type_dependancy(type_constructor(typename_dependancy((n242,declaration_cons(1692),l40144),[40143,40144],[],[]),row_dependancy(row_construction([field_construction((1,
l40145):type_dependancy(type_poly(row_dependancy(row_construction([field_construction((1,l39728):type_dependancy(type_constructor((n5,declaration_cons(61),l784),row_dependancy(row_construction([],-,l785),[78
3,785],[],[]),l784,equality_type_status(unknown)),[0,3,4,5,6,782,784,1032,39729,39730,39731,39732],[],[]),l39728),field_construction((2,l39728):type_dependancy(type_constructor((n5,declaration_cons(61),l784)
,row_dependancy(row_construction([],-,l785),[783,785],[],[]),l784,equality_type_status(unknown)),[0,3,4,5,6,782,784,1032,10084,10085,10086,10087,10088,10089,10090,10091,11132,11133,11134,11135,11136,11137,11
138,11139,11140,11141,11143,11144,11145,39734,39735,39736,39737,39738,39739],[],[]),l39728),field_construction((3,l39728):type_dependancy(type_constructor((n302,declaration_cons(61),l10090),row_dependancy(ro
w_construction([],-,l10091),[10089,10091],[],[]),l10090,equality_type_status(unknown)),[0,10084,10085,10086,10087,10088,10090,11160,11161,11162,11163,11164,39741,39742,39743,39744,39745,39746],[],[]),l39728)
],-,l39728),[39725,39726,39727,39728,40162],[],[]),51,poly,constant(5.0,373,40162),l40162,equality_type_var(eqtv19685)),[40146,40147,40148,40149,40150,40151,40158,40159,40160,40161,40162],[],[]),l40145)],-,l
40145),[40143,40144,40145],[],[]),l40143,equality_type_status(unknown)),[40143,40147,40148,40149,40154,40155,40156,40157,40158,40159],[],[])

these stripping rules need to be written pretty carefully, it's going
to be quite difficult to debug after they have been written. i'll have
a think about how exactly the stripping should work and write here
what the solution is.

*** 2012-08-07

(2012-08-07-10:44)

okay, i think i've got this function working to strip the equality
type variables values, testing it now.

it would be nice for skalpel to a have a "consider only this file"
option, where it will run itself on the current file and ignore all
undefined identifier errors. i've been thinking this because even
though i'm working on a fairly big sml program and am working in lots
of different files, it's rare i care about getting the information
from the other files.

(2012-08-07-12:12)

well, if it isn't my old friend:

error: error! the unification algorithm terminated in a success state,
 but an error was generated previously! hint: it has been found
 previously to be the case that this error is cased by a bug solely in
 the unification algorithm where some labels are not propagated
 correctly...

joys! at least i know what the problem is. :-)

(2012-08-07-13:11)

hmm usually this problem is caused by having not enough labels in the
new error that is created and recursed upon, but i think all the
labels here must surely be sufficient. i'll print the labels and
compare them against the labelled program output that i wrote up.

(2012-08-07-14:00)

indeed, there is a label problem. two errors are constructed in this
example i've been working on, one for each of the x accessors, and in
neither of them do the labels look correct.

i'll play around with them now.

(2012-08-07-14:23)

the problem is coming from the function that strips equality type
variables from the binding, it's not collecting all the labels along
the way, i have only a few here.

(2012-08-07-15:01)

ah excellent, i have an equality type error now! this was indeed a bug
in the stripping of equality type variables from a binding. i'm going
to look at this more closely and run the rest of the equality type
tests to see what happens.

(2012-08-07-15:17)

this test result looks good, and the other test examples didn't
break. i'm going to form a rough list of features of the sml language
that can have equality type errors but that aren't yet detected, then
i'll choose one to work on.

i'm also going to improve the work i did on producing a labelled
program output in tex, that's proved to be very useful when debugging.

(2012-08-07-16:30)

i've improved the tex output so that the output can just be pasted
into a file and then compiled. really skalpel should output this
information to a file, that's the main improvement that could be made
here. i might do this later, but for the moment i'm happy to just
paste it into a file.

*** 2012-08-08

(2012-08-08-10:08)

i have a rough idea of what work needs to be completed with respect to
equality types.

i'm moving the examples of programs that i have that don't work into
the repository, in a not-handled folder of the test database. as the
database doesn't blindly read in files any more, this should be
perfectly acceptable.

(2012-08-08-13:06)

wtf? skalpel is generating equality type errors for the tests i
haven't even got around to working on yet. uh, win? wait, am i
bi-winning?

i'm going to take the time to look a little more into what skalpel can
actually do, it looks like more is working than i thought.

(2012-08-08-13:27)

er, wow. i'm rather happy with the results that i'm getting. this is
great, it's doing better than i expected. i'm just sitting here trying
to break it now. i have saved the output of an interactive session
from a meeting with joe where equality types are detected involving 'a
like this:

val 'b f = fn x : 'b => x = x;

this sort of thing still doesn't work. i have some questions about
this for the next meeting actually, but this sort of case isn't what
i'll be working on right away (i'll figure that out in a moment...)

(2012-08-08-15:48)

okay so i'm currently thinking i'll get type error slices for tuples
first, and then records (or vice versa, as they are really very
similar indeed). from there i'll get ''a working when it's in the
signature (i've got some examples of this working already i think, and
anyway it works with datatype declarations).

from there i'll look at handling the eqtype keyword, i suspect this
might be quite tricky actually. with the eqtype keyword handled
correctly though we should handle all type correctly and there
shouldn't be much to do after this point.

(2012-08-08-16:34)

err, tuples and records are now working when used with accessors. i
guess that code i wrote yesterday worked way better than i thought it
was going to. this going to save me so much time, i didn't think the
solution i wrote yesterday would extend to those.

i have to update the tasks.org file now for alessio and put it on the
web. i will look (happily!) more into this matter tomorrow.

(2012-08-09-23:18)

it occurs to me as i'm writing about bugzilla in tasks.org that
another attempt should be made to fix the css style sheets. the
web server has changed significantly and it's possible that this
problem is easy to fix now.

i'm tempted to try this myself tomorrow. perhaps i'll do this, depends
how time goes.

tasks.org is currently unavailable to people outside the heriot-watt
network. perhaps i should commit this to the public repository, alessio
will be able to clone it easily that way too. we have copyright
statements secured for that file, so it should probably be in the
skalpel repository, rather than the tes repository.

*** 2012-08-09

(2012-08-09-09:39)

hm, test framework still broken this morning, forgot to merge the
master branch with the devel branch. might add a check in my scripts
so that i don't do that.

(2012-08-09-10:15)

right, i need to figure out a certain irregularity. it does seem that
equality types are further along than i thought, but there is one
problem.

an error here is not detected:

(1,2.0)=(1,2.0)

but, here, it is:

val x = (1,2.0);
x = x

the plan is to make this work (i think this is because when solving an
equality type error including an accessor the new solution is being
used of stripping out equality type variables from the binding), and
then create a bunch more tests and put them in to the analysis engine
test database.

if all this happens quite quickly, i'll deem myself happy with this
and will stop work on equality types for the day, and sort out some
things that are hanging around on the back burner, which will probably
include items from this list:

- making rest of changes joe recommended to the first year report
- finishing the poster
- fixing tasks.org html generation
- updating documentation
- looking at bugzilla

perhaps this problem will take me all day, but i'd rather like to
tackle some of the problems on that list today if i can get the
chance.

(2012-08-09-11:00)

it looks like the reason that this doesn't work is because in the
unification steps printed out, we are never solving anything with more
than one equality type variable inside. we need at least two equality
type variables to get a conflict (because the conflict is always
between a not_equality_type status and an equality_type status).

perhaps i need to do something in the constraint generator. i think
somehow reusing the function that i wrote which strips equality type
variables seems to be a good way to go, as it's working really well on
the other tests.

(2012-08-09-11:24)

it's worth noting that this function which i wrote which strips
equality type variables is only called when solving accessors. maybe i
just need to make this function call somewhere else if i can see
another equality type variable for me to create the constraint with...

(2012-08-09-12:38)

okay, i think i see what needs to be done here. the reason this works
with accessors, is because in code like this:

val x = (1, 2.0);

x = x;

we generate constraints for (1, 2.0), including equality type
constraints. so inside the binder for x we have an equality type
variable.

when we see x = x, an equality constraint accessor is created, which
has an equality type variable attached to it.

so we have the equality type variable from the x accessor, and the one
nested inside the x binding. the equality type variable from the x
accessor has to be equality_type (because the '=' operator makes that
constraint), and the other turns out to be not_equality_type, due to
the presence of a real number in the tuple.

now instead with code like this:

(1, 2.0) = (1, 2.0);

the equality type variable for the (1, 2.0) section of the code is
instead no longer located in a binder, because there isn't one. it's
located on the right hand side of a standard type variable constraint,
like this:

type_poly(row_dependancy(row_construction([field_construction((
1,l39728):type_dependancy(type_constructor((n5,declaration_cons(61),l784),row_dependancy(row_construction([],-,l785),[783,785],[],[]),l784,equality_type_status(unknown)),[0,3,4,5,6,782,784,1032,39729,39730,3
9731,39732],[],[]),l39728),field_construction((2,l39728):type_dependancy(type_constructor((n5,declaration_cons(61),l784),row_dependancy(row_construction([],-,l785),[783,785],[],[]),l784,equality_type_status(
unknown)),[0,3,4,5,6,782,784,1032,10084,10085,10086,10087,10088,10089,10090,10091,11132,11133,11134,11135,11136,11137,11138,11139,11140,11141,11143,11144,11145,39734,39735,39736,39737,39738,39739],[],[]),l39
728),field_construction((3,l39728):type_dependancy(type_constructor((n301,declaration_cons(61),l10090),row_dependancy(row_construction([],-,l10091),[10089,10091],[],[]),l10090,equality_type_status(unknown)),
[0,10084,10085,10086,10087,10088,10090,11160,11161,11162,11163,11164,39741,39742,39743,39744,39745,39746],[],[]),l39728)],-,l39728),[39725,39726,39727,39728,40149],[],[]),52,poly,constant(2.0,373,40149),l401
49,equality_type_var(eqtv19682))

alright, so we have one equality type variable there. where's the
other one? well that was in the accessor before, so where is it now?

it doesn't exist. the accessor here was essentially the 'left hand
side'. the left hand side now however is this:

type_var(t31849,-,poly,unknown)

a type variable with unknown equality type information. the solution
to this is probably to attach the equality type variable that's
generated when we see the '=' operator comes up and attach it to the
type variable that is generated. my thought is that then we will have
something like this on the left hand side:

type_var(t31849,-,poly,equality_type_var(α))

then something like this on the right hand side:

type_poly(row_dependancy(row_construction([field_construction((
1,l39728):type_dependancy(type_constructor((n5,declaration_cons(61),l784),row_dependancy(row_construction([],-,l785),[783,785],[],[]),l784,equality_type_status(unknown)),[0,3,4,5,6,782,784,1032,39729,39730,3
9731,39732],[],[]),l39728),field_construction((2,l39728):type_dependancy(type_constructor((n5,declaration_cons(61),l784),row_dependancy(row_construction([],-,l785),[783,785],[],[]),l784,equality_type_status(
unknown)),[0,3,4,5,6,782,784,1032,10084,10085,10086,10087,10088,10089,10090,10091,11132,11133,11134,11135,11136,11137,11138,11139,11140,11141,11143,11144,11145,39734,39735,39736,39737,39738,39739],[],[]),l39
728),field_construction((3,l39728):type_dependancy(type_constructor((n301,declaration_cons(61),l10090),row_dependancy(row_construction([],-,l10091),[10089,10091],[],[]),l10090,equality_type_status(unknown)),
[0,10084,10085,10086,10087,10088,10090,11160,11161,11162,11163,11164,39741,39742,39743,39744,39745,39746],[],[]),l39728)],-,l39728),[39725,39726,39727,39728,40149],[],[]),52,poly,constant(2.0,373,40149),l401
49,equality_type_var(β))

and then when solving type vars we also run stripequalityvariables on
the right hand side, which will return β, and then make the constraint
α -> β. this constraint would then in this case be unsatisfiable, and
an equality type error would be generated.

that's the current working theory anyway. the type_var constructor
already has slots for equality type information, so i guess this
information can be used here. i'll think about this over lunch and
then start implementation.

(2012-08-09-14:16)

i'm changing the call to constytuple so that it takes an equality type
variable and created about 5 new functions so that this equality type
variable gets propagated right through to the point where constype_var
is called, where i can attach equality type information.

this might result in this information showing up in the right place
when doing constraint solving. if it does then i'll make this work in
a nicer way, otherwise i'll need to find another solution.

(2012-08-09-14:25)

no, wrong place. i'll remove these calls. i need to find out where
type variable number 31849 is generated, but there is no debugging
mechanism for this (mainly because creating a system for finding where
precisely a type variable is generated could be time consuming, and
after it's done there will be so much information it'll be like
looking for a needle in a haystack).

i'll keep hunting around.

(2012-08-09-15:30)

i've made a list at the top of things that still need to be handled
with respect to equality types. i'm just going to work through that.

(2012-08-09-16:18)

hmm still can't find the point where the type variable is created
which is constrained to the type_poly term that i want to strip the
equality type variable out of, it doesn't seem to be done in any of
the obvious places. it must be being done somewhere else, or something
is happening in the unification phase where a new type variable is
created for some reason and the information hasn't been propagated
through.

*** 2012-08-10

(2012-08-10-08:13)

starting with poster work today and going to try and take a look at
some of the things that are on backlog, going to come back to equality
types perhaps today if things go well but probably at the start of
next week.

(2012-08-10-09:06)

hmm, i think i fixed the bugzilla. the fix is rather outlandish, and
involves installing two bugzilla versions currently and hacking of a
perl file.

we will probably need to always hack this perl file but we shouldn't
need the additional bugzilla installation (of a different
version). i'll see if i can get rid of the need for this now.

(2012-08-10-09:24)

in template.pm i've changed the relative path of style sheets to be an
absolute path. this is an absolute hack, which happens to work for
reasons probably to do with the funky prefixes that we have to put on
urls for cgi scripts.

at the moment i've changed the @requested_css field in template.pm on
line 416 of template.pm and changed the .htaccess file in the root of
the bugzilla-4.2.2 folder. i've also put the installation in my user
account.

there is still a problem with going to the homepage of the bugzilla
installation, as the web server throws errors. i'll try to fix them now.

(2012-08-10-09:28)

to hell with this .htaccess file, i'm just deleting it as it's causing
problems. it stops my edit to template.pm from working too, as it
blocks access to the style sheets.

(2012-08-10-09:35)

i have made a change to common-links.html.tmpl file so that when
clicking home the user is directed straight to the index.cgi file
instead of just the directory, as the server doesn't redirect the user
to the index.cgi file (scott mentioned that this was a pain as well).

this looks fine now, i'll update the documentation then reinstall the
website so that we get a link to the new bugzilla version.

(2012-08-10-10:55)

documentation has been updated, and the website has been re-installed.

i've also added a link to the tasks.html file generated from
tasks.org. it should be noted that this file was copied to my $home,
and then installed that way. this file is not generated from tasks.org
yet due to issues with the convert-org-to-html script, but when this
is fixed then this file should be auto-generated.

it should be noted that these html pages that are generated need to be
changed, there is no link back to the skalpel website which will
decrease our google visibility. something that should be thought
about for later.

(2012-08-10-11:49)

updated the documentation for how to add tests to the analysis engine
test database. this can be found in:

documentation/skalpel-developer-info/test-framework

removing the warning that i have in this document.

(2012-08-10-13:34)

before this meting with joe i'm going to try to add in any comments he
made on the poster that haven't been added in already. then we can
look at again today and if he's happy with it i can put it to
printing. we still have time before the research open day.

(2012-08-10-16:15)

having a go at fixing the errors that were reported in the test
framework this morning, i think i have found of most of them. running
again now to test.

(2012-08-10-16:56)

mm, no i didn't find most of them! there are still quite a few left,
probably going to spend the rest of the time doing this and meeting
joe.

*** 2012-08-13

(2012-08-13-09:58)

going to start today working on the poster, there are still some
things that need to be cleaned up there.

(2012-08-13-10:43)

trying to get this label pointing to where a standard compiler reports
the error locating is not proving that easy, tikz is definitely the
way to do this kind of thing but i haven't used this package
before. might look into this later as it looks like a pretty powerful
package.

(2012-08-13-11:10)

think i've managed to squeeze at that text in on the left hand side
adequately without it looking too crushed.

there's quite a lot of space on the left hand side now that i've
merged the two boxes together (not the 'future work' box).

there's enough space to extend the future work section but also to add
in another section of text if that would be suitable. hm.

(2012-08-13-14:35)

i think this poster is more or less finished up now. i want to fiddle
a bit more with it because the system structure section could be
extended a bit. after that i'll get on with fixing two tests that were
reported broken this morning.

(2012-08-13-15:02)

hm. there's extra space here but i'm not really sure what to do with
it, everything is covered.

(2012-08-13-15:20)

can't think of anything to put in this space right now, will come back
to it later. the poster already has about as much text on it. hm, will
think about it later.

i'm going to fix up the tests that broke as it needs to be done.

(2012-08-13-17:16)

fixed those bugs up, they should work great tomorrow. i'll do some
more on the equality types stuff this evening.

*** 2012-08-14

(2012-08-14-10:19)

equality types today. i've made up a bunch of equality type tests and
am putting them into the skalpel repository now.

i'll also get the typable tests into the repository today, then i'll
work through the test cases i've got and try to get some of those passing.

(2012-08-14-11:22)

typable tests at the moment are put into the repository by mocking up
a json file from the default xml that's spat out of the analysis
engine when skalpel-debug is used. maybe i should change that to json
by default. hm i'll think about that.

(2012-08-14-11:40)

ahh, this res.html file is always exported whether the user wants it
or not. i thought i'd seen this file cropping up all over the
place. i'm going to look into this, this will confuse everyone.

(2012-08-14-12:00)

this seems to get output only when i run skalpel-debug. i might remove
this option altogether as it isn't useful, if the user wants html
output they should use the command line option to get that, not the
debug option.

yeah, i'm going to remove this option.

(2012-08-14-12:37)

i've changed that option so that we get json output by default from
skalpel with debugging mode enabled, so the errors output can be just
put straight into their own file in the test database.

creating solutions for the typable tests now.

(2012-08-14-13:36)

okay, all of the tests that weren't under test control because they
didn't have solution files are now in the test database. i'm removing
that whole folder, as it should be easy to generate solutions in test
database for any code file now.

(2012-08-14-14:20)

closing bug 136, fixed that up. that was a pain for me today also.

(2012-08-14-14:41)

aha, got in touch with vincent. he's been working on a paper of his
own and then had a few weeks off. vincent is kindly going to commit
the paper to the skalpel repository just now. might change my plan of
action for today to work on something like this.

he is getting 'permission denied' when trying to log in to
lxultra8. i'll e-mail joe about this.

(2012-08-14-15:15)

the sources for the paper are in the skalpel repository, vincent just
pushed them. i'll take a look at this at some point today, i don't
have some dependancies so i'll get those installed.

(2012-08-14-19:07)

i've been looking into the reason why an equality type error is not
detected in the following code fragment:

let
    val id : ''a -> ''a = fn x => x
in
    id 5.0
end;

i haven't handled the case where we have val <something> : <something
else>, so i suspect that this is a special case in the constraint
generator and doesn't fall into the same constraint generation as the
standard value declaration does.

i'd really like to at least build the pdf of the paper this evening
though, so i'll put this on the back burner. i'd also like the output
for these constraints to be more clearly readable, fix the display of
slices in the terminal and such things.

(2012-08-14-23:16)

not looking like i'm going to get the chance to get around to the
paper this evening, i'm still looking at this equality types test. i'm
tweaking the way that the program flow through the constraint
generator is depicted when printed to the debugging output, it's a bit
hard to understand in its current form. hoping to finish that up
tonight and push the changes.

*** 2012-08-15

(2012-08-15-01:18)

gah, i always forget how to do a empty character in sml. #"" never
does the trick, to do this #"\000" is needed. #"\0" won't do either,
it must be three 0 characters.

edit: nope, \000 is "\^@" (of course, what else would it be!). see log
at last early morning hour.

(2012-08-15-01:59)

god this is time consuming. i know it'll be worth the effort, but
this is the second change that i've made to something which is related
to the abstract syntax tree, and it really does eat up a lot of time
having so many different cases. it actually causes problems with the
equality type tests as well, as it's bugs in individual cases which
result in the failure of some of the tests.

(2012-08-15-02:06)

argh! \000 isn't working as the termination character:

> string.implode [#"\000"];
val it = "\^@": string

aaarrgh. now i understand why the tabbing is messed up.

(2012-08-15-02:21)

oh. you can't do the empty character in ml apparently. nice. i won't
be forgetting that in a hurry this time, what a pain. i'll just have
to work around it.

(2012-08-15-03:28)

ahh, this is starting to look much nicer now, though i'm going to stop
now as i do actually want to get on to other things (such as the paper)
when i wake up.

this code to print out the program flow is about 50% completed. i'm
hoping it's going to be enough to work with for the moment, it looks
like i'll certainly be able to debug these test cases much
easier. hm, fingers crossed.

(2012-08-15-10:21)

i've decided to start today by looking at getting the terminal slices
working. this shouldn't be that difficult, and it's going to need to
be done so that students can use skalpel in an easier way.

(2012-08-15-11:12)

i have fixed the terminal front end interface. apparently the 'switch'
keyword is now available when another perl package is installed. i
don't want the dependancy, so i've just replaced the switch statements
with if statements and that should work just fine for us.

i have noticed a few things that i'm going to change

1) this is what skalpel outputs for code1.sml

% skalpel -e 1 -p output.pl -b 2 lib/basis.sml ~/repos/skalpel/testing/analysis-engine-tests/standard-ml/numbered/code1.sml
[skalpel: parsing...]
[skalpel: constraint generation...]
[skalpel: enumeration...]
[skalpel: analysing /home/jpirie/repos/skalpel/lib/basis.sml]
[skalpel: analysing
/home/jpirie/repos/skalpel/testing/analysis-engine-tests/standard-ml/numbered/code1.sml]
<<<<< [ the slice goes here ] >>>>>
[skalpel: found counter=1 time=575 errors=[0[]]]
[skalpel: analysing /home/jpirie/repos/skalpel/lib/basis.sml]
[skalpel: analysing /home/jpirie/repos/skalpel/testing/analysis-engine-tests/standard-ml/numbered/code1.sml]
[skalpel: analysing /home/jpirie/repos/skalpel/lib/basis.sml]
[skalpel: analysing /home/jpirie/repos/skalpel/testing/analysis-engine-tests/standard-ml/numbered/code1.sml]
[skalpel: analysing /home/jpirie/repos/skalpel/lib/basis.sml]
[skalpel: analysing /home/jpirie/repos/skalpel/testing/analysis-engine-tests/standard-ml/numbered/code1.sml]
[skalpel: analysing /home/jpirie/repos/skalpel/lib/basis.sml]
[skalpel: analysing /home/jpirie/repos/skalpel/testing/analysis-engine-tests/standard-ml/numbered/code1.sml]
[skalpel: analysing /home/jpirie/repos/skalpel/lib/basis.sml]
[skalpel: analysing /home/jpirie/repos/skalpel/testing/analysis-engine-tests/standard-ml/numbered/code1.sml]
[skalpel: analysing /home/jpirie/repos/skalpel/lib/basis.sml]
[skalpel: analysing /home/jpirie/repos/skalpel/testing/analysis-engine-tests/standard-ml/numbered/code1.sml]
[skalpel: analysing /home/jpirie/repos/skalpel/lib/basis.sml]
[skalpel: analysing /home/jpirie/repos/skalpel/testing/analysis-engine-tests/standard-ml/numbered/code1.sml]
[skalpel: analysing /home/jpirie/repos/skalpel/lib/basis.sml]
[skalpel: analysing /home/jpirie/repos/skalpel/testing/analysis-engine-tests/standard-ml/numbered/code1.sml]
[skalpel: analysing /home/jpirie/repos/skalpel/lib/basis.sml]
[skalpel: analysing /home/jpirie/repos/skalpel/testing/analysis-engine-tests/standard-ml/numbered/code1.sml]
[skalpel: analysing /home/jpirie/repos/skalpel/lib/basis.sml]
[skalpel: analysing /home/jpirie/repos/skalpel/testing/analysis-engine-tests/standard-ml/numbered/code1.sml]
[skalpel: analysing /home/jpirie/repos/skalpel/lib/basis.sml]
[skalpel: analysing /home/jpirie/repos/skalpel/testing/analysis-engine-tests/standard-ml/numbered/code1.sml]
[skalpel: analysing /home/jpirie/repos/skalpel/lib/basis.sml]
[skalpel: analysing /home/jpirie/repos/skalpel/testing/analysis-engine-tests/standard-ml/numbered/code1.sml]
[skalpel: analysing /home/jpirie/repos/skalpel/lib/basis.sml]
[skalpel: analysing /home/jpirie/repos/skalpel/testing/analysis-engine-tests/standard-ml/numbered/code1.sml]
[skalpel: analysing /home/jpirie/repos/skalpel/lib/basis.sml]

this is far too much output. it might be useful to see all of these
things, so i'm going to keep this kind of output style in place, but
it's going to be been moved to the debug output.

2) the command line parameters could be a bit long for students, let's
   make it easier for them. i'm going to change it so that when
   running merely:

   skalpel code1.sml

   it uses basis option 2 with lib/basis.sml and outputs slices in the
   terminal window. that should make it very easy for them to
   understand.

3) the command line interface does not specify the file where a slice
   has come from. i don't want to fix this right now, it's not urgent
   and there are other things to attend to so i'm going to file a
   bug in the bugzilla database.

(2012-08-15-11:58)

item 1 in the previous log entry has been implemented. enable
constraint generation debugging to see this output. now we get this
output from skalpel:

% skalpel -bo 0 -e 1 -p output.pl -b 2 lib/basis.sml ~/repos/skalpel/testing/analysis-engine-tests/standard-ml/numbered/code1.sml
[skalpel: parsing...]
[skalpel: constraint generation...]
[skalpel: enumeration...]
[skalpel: unification...]
<<<<< [ slice goes here ] >>>>>
[skalpel: found counter=1 time=579 errors=[0[]]]
[skalpel: finished time=5089]

that's much better.

(2012-08-15-13:21)

hm, i'm not sure what to do about the default basis option. i think
that by default, we should use the full basis, but how do we know what
location that is in? the problem is that we don't know.

i guess we could store it in an environment variable, and if it's not
there default back to the -b 0 option. that sounds alright.

(2012-08-15-14:10)

argh! there's a bug in the terminal slice viewing script. if the
output directory is absolute, and not relative, it explodes. i'm going
to fix this now, this is required.

(2012-08-15-14:21)

ok, i think i've fixed most of this up. the only issue is that if the
user specifies a perl file that is not the default then they don't get
the slices in the terminal for some reason. i think this should be
easy to fix so i'll just go ahead and do that...

(2012-08-15-15:50)

done. also fixed that bug (not reported) where if no prefix is
specified for perl, html files etc, then it just went ahead but didn't
make any output files.

(2012-08-15-16:20)

i've changed things a little so that if the user doesn't specify a
basis option and they don't have an environment variable set then we
just throw an error. falling back to the no basis option is not really
acceptable.

there aren't any major bugs regarding the front end terminal interface
that i know of, so i'm ceasing work on this part for now.

(2012-08-15-17:36)

.. apart from it's unclear when skalpel doesn't find any errors. i've
added that in now so the user is presented with how many errors
skalpel has found, otherwise it's not that clear when a program is
deemed typable.

oh and i just noticed that the output files don't get cleaned up after
each run. they should be, if they are to be kept then some kind of
debug option is needed, otherwise skalpel executes old files. filing a
bug for now.

(2012-08-15-17:46)

actually, this bug is going to confuse me sometimes and might lead to
time loss. i'm going to add a warning at the top of this file too.

(2012-08-16-20:12)

having a quick look at the state of the documentation. it's actually
in not too bad a shape, better than i expected. it would be good to
clean some of this up though, it will need to be done before a release
happens at any rate.

(2012-08-16-00:02)

had a few e-mails from joe pointing some useful things out. i've
added a bunch of bugs against various components and i've changed the
default mail format that bugzilla uses from html to plain text which
might be for the best anyway.

i also mentioned that i want to start doing 30 minutes of
documentation a day, which sounds like a good thing to aim for, so
long as i remember to stop working after the 30 allocated minutes and
don't go off for hours updating things. eventually i'll run out of
documentation to update and maybe then i can use the time to fix bugs
or give aid to other neglected areas of the project. i'll see how it
goes, maybe this will be too difficult to keep up.

right, i'm going to sort out the building of the paper, it must be
looked at. joe mentioned that maybe this should sit somewhere that
isn't public, and maybe this should indeed be the case. something to
talk about at our next meeting i guess, added it to the list.

(2012-08-16-00:49)

okay, i can now build the paper. question is, what now? maybe i should
just go through the whole thing and build up suggestions to change, or
maybe i should go straight ahead and look at how equality types could
be built in to this.

(2012-08-16-02:58)

i've had a quick look at the paper this evening but ended up tweaking
the bugzilla error reports and the like. i'll have to read over this
tomorrow and take a good look at it.

*** 2012-08-16

(2012-08-16-11:46)

going to tidy up the poster before this meeting with joe today, it
would be good to get that to printing some time soon so i'll focus on that.

(2012-08-16-10:38)

i've made a few edits to the poster, and fixed some of the serious
bugs that existed for the terminal front end. i'll aim to finish this
the poster tomorrow and get it to joe to glance over and suggest any
changes before i get it sent for printing.

*** 2012-08-17

(2012-08-17-09:28)

poster today, needs to be finished. paper will be neglected for yet
another day.

(2012-08-17-15:08)

i've been working on this poster all day, and most of it has been
spent trying to reduce some space that tikz creates by about a few
millimeters. it's unbelievable how much time it can take preparing
this stuff properly, in the meeting with joe yesterday we spent most
of the time trying to get our heads around tikz. the time cost has
certainly not to be underestimated. hmm.

whenever i draw anything around some text, it moves. not much, but
just enough to be noticeable. i've tried rather a number of different
arguments which should move the position, but they don't in this case,
probably because they are being overridden. i'll keep reading through
the documentation and trying the things that are recommended, but the
deadline for this is the end of today. it should be in printing on
monday really.

(2012-08-17-15:35)

a warning for the future, tikz doesn't always draw the arrow between
nodes that you want, but rather the one that is defined first. so i
have a definition

node a
node b
node c

draw b c

which is supposed to draw a node between b and c. but it drawws it
between b and a, because a was defined first. maybe this has something
to do with the remember picture argument, who knows. i don't have time
to chase that down today.

(2012-08-17-15:55)

these positioning parameters just aren't affecting this node in any
way whatsoever.

(2012-08-17-15:58)

out of time for this. oh well, never mind.

*** 2012-08-18

(2012-08-18-15:06)

fixed the alignment of that text by adjusting the baseline manually,
poster should be fine on that side of things now.

*** 2012-08-20

(2012-08-20-13:57)

trying to print this pgf manual, but there seems to be something
strange happening with the print server as i can't print anything of
length greater than 2 pages from my printer (aside from the the linux
labs, which will print 4 pages, and the ground floor labs which will
print 0 pages). i have printed the tes paper however and that was
fine, so perhaps it has something to do with the size of the pgfmanual
document? anyway, moving on.

i still haven't received any e-mail confirming the poster size for the
displays on thursday. i should probably however get the poster to
graphics and printing today, so i'll try to find christine and get all
the paperwork sorted out involving that and printing when they need
the poster by at the latest.

i must look at the tes paper today though at some point, there should
be time for this.

(2012-08-20-14:46)

a future note: for the printing of poster, they need the poster 48
hours in advance. so for example if i want to pick up the poster on
thursday morning (which in this case i do) then i need to give it to
them first thing tomorrow. it would really be better to give it to
them today but i guess i'll wait until tomorrow in the hope that the
poster size will be confirmed.

(2012-08-20-15:14)

nick does need to confirm the printing of these posters, although
there isn't a form that he has to sign. i'll have to catch him later
today as i can't find him at the moment.

(2012-08-20-15:31)

alright, i'm going to work a bit on passing some more equality type
cases.

(2012-08-20-15:55)

right, so this doesn't work:

structure s : sig datatype ''a mydt = firstcons of ''a end =
struct
datatype ''a mydt = firstcons of ''a
end;

s.firstcons(5.0)

but when taking the signature definition away, it does work! this is
because when a signature is present a rather different route is taken
through the abstract syntax tree. i might not delve into this example
right now, this looks like it will take several hours to go through
and i don't want to stop half way through.

some notes for when i come back to this:

without the signature the abstract syntax tree goes through labsigexp
-> strexpbasic -> specdat -> datdesc -> datdescone -> [...]

with the signature the path is:

strbindone -> strid -> labstrexp -> strexpbasic

i'll need to do something clever with the signatures, because the
eqtype keyword can be used there. perhaps my time would be best spent
looking at that first.

i'll take a look at the paper instead for the moment, and do equality
types either after the poster printing tomorrow or this evening if i
get some time.

(2012-08-20-16:09)

managed to find nick, he's approved the printing of the poster. i'll
head in first thing tomorrow and get it to them so that i can pick it
up first thing on thursday morning.

*** 2012-08-21

(2012-08-21-09:51)

the poster has been sent to graphics and printing and will be ready
for pickup on thursday morning. the poster that has been sent is the
pdf that was generated from the .tex source in the tes/ repository,
git commit hash ba356c778adec28352f35dfaa27accfc68a88412.

the codes used to print the poster have been stored in the tes/
repository in the commit after the hash above for future reference, as
these could be used to print further posters.

(2012-08-21-10:08)

i just remembered there's a windows lab next to the linux lab, going
to quickly try printing the tikz documentation from there and hope
that printer can manage more successfully. plan for today is equality
types though, and looking at the paper. i'm hoping to work with
equality types first to familiarise myself with the structure again,
then read the paper and if i read far enough try to integrate into
that the way equality types are represented.

(2012-08-21-10:41)

something strange is happening with the skalpel configure script, i
noticed this yesterday too while writing some documentation. the
configure file which is present in the skalpel repository is actually
old. we should be generating the configure script by running autoconf
on configure.ac, but this file is not present.

this problem is really best averted by having the test framework clone
and compile the skalpel binary from scratch.

i'll look into fixing this up later, this is not what i want to be
working on today. i'll file a bug.

(2012-08-21-11:21)

printers seem to be fixed as tikz docs are printing now, moving on to
equality types. looking at the
struct-with-sig-including-tick-tick-a.sml example.

this doesn't seem to work because i haven't written code to strip out
equality type information from an explicit type variable. i will most
likely have to do so now.

(2012-08-21-12:15)

hmm, the path through the ast is somewhat complex. going to have to
figure this out first.

(2012-08-21-13:34)

still trawling through the ast, but i think i see where changes need
to be made in this example.

there is something that i have decided i would like, is for some small
gui which will allow me to see what constraints are generated at which
parts of the constraint generation process.

i made some kind of start with this earlier, so output comes out like
this:

[...] a.valdescone
[...] |- a.labid
[...] |-   |-a.ident (str="x")
[...] |-a.labtype
[...]       |-a.typearrow
[...]             |-a.labtype
[...]             |   ╰─a.typeonevar
[...]             |         |-a.equalitytypevar (f_typevar; str="''a")
[...]             |-a.labtype
[...]                   |-a.typeonevar
[...]                         |-a.equalitytypevar (f_typevar; str="''a")

except that i've used box drawing characters rather than the flimsy
ascii symbols (edited for the purposes of this document). i would love
for:

a) abstract syntax tree path printing in this way
b) to be able to see the constraints that are generated at each stage
by clicking on each node in the tree

if i had this i would just die with how nice it would be. i don't
really want to do that now because i've spent a fair bit of time
fiddling with this sort of thing and i want to get at least this test
passing quickly. i might look at doing something like this perhaps
this evening or whatever. something like that would be unbelievably
useful. perhaps i could try out the sml gtk bindings which i have
heard on the irc channel are actually very up to date...

(2012-08-21-14:05)

right, i think this issue is coming about because this example uses
explicit type variable accessors, which are something i haven't looked
at yet.

(2012-08-21-14:34)

argh, there is no debugging print out for any of this stuff yet,
signatures and structures are a complete mystery at the
moment. basically, in the example i've been working on, the answer to
the question "what constraints are generated for the binding of 'x' in
"sig val x : ''a -> ''a end"? i have no idea, i'll need to print out
this information.

(2012-08-21-14:40)

actually, as a quick method which will let me see this constraint
information quickly, i could prefix the output with stars and then
save it in a .org file.

that way i would be able to just see the output that i want with very
little effort. i feel bad about doing this though, because it's a
debugging feature which is tied to emacs, which is a route that should
generally be avoided. it's such little effort though for such great a
gain i'm going to do it that way and code it up immediately, as the
amount of output for even small programs is making my head explode and
this should help that situation without costing me a lot of time.

(2012-08-21-16:13)

hm, this isn't as straight forward as i thought. due to the nature of
the tree traversal constraints will get printed after the children are
traversed and printed, which means the tab expansion on nodes won't
work. hmm.

(2012-08-21-16:31)

i don't see an easy way to do this now. i shall think about this again
later at some point. going back to working on this example for now.

(2012-08-21-17:41)

haven't changed any of the underlying code today, it's all just
debugging improvements. i'm going to work on this some more this
evening to make up for that, there needs to be progress made on the
actual test case itself, ideally it should pass by the end of today
but i'm aware that might not happen. nevertheless i want to do some
more on this in the evening.

i'm happier with the debugging output now though, it's easier to
understand what the analysis engine is actually doing when it looks at
a program.

(2012-08-21-18:04)

aha, time to sneak some 30 minutes to update documentation. as i
mentioned earlier there is some kind of issue with the configuration
script that we currently have in the skalpel repository, i'll look at
that a little if i can get a gap of time inside this 30 minutes.

(2012-08-21-19:01)

hm, didn't quite get time to look at the configure script, i shall
leave that until another day. documentation is looking better though,
so that's a win.

(2012-08-21-21:12)

hoping to do something useful with this example before the day is
out. i think i've nearly finished writing the code to show the path
through the constraint generator so i can follow constraints through
the system easily.

(2012-08-21-23:07)

possibly it might be a better target just to finish the printing
mechanism and do the example tomorrow, this is alas probably going to
take most of the rest of the evening. a good use of an evening though
if it saves me pain tomorrow i guess!

*** 2012-08-22

(2012-08-22-00:22)

hmm it's still hard to see some of the constraints that are generated
on the path through the constraint generator, to do this nicely i'd
need to program up another program, like the gui i was talking about
earlier. i don't really have time to work on that right now, so i'll
use a workaround for that and just used what i've developed today.

(2012-08-22-01:44)

done, that took a little longer than i wanted but i guess i'm happy
with it despite the time cost this evening. this should help me figure
out what is going on with this equality type test tomorrow, and
hopefully i can get that passing before the industry day on thursday
and then come back to equality types on friday.

(2012-08-22-11:22)

i see from the work yesterday that the simple example i'm working on:

structure s : sig val x : ''a -> ''a end =
struct
fun x y = y
end;

s.x 5.0

results in over 50 constraint generation function calls. i can see now
why this example doesn't work yet, i haven't written equality
type information for all of these cases yet. i've started to add that
functionality now.

i think that the best way to do this is to work backwards, so i'm
going to try that, starting by looking at the constraints that are
available when s.x 5.0 is being handled. what should be happening is
s.x should be an accessor to the x value inside the structure s, and
when we look up that accessor we should see that x has equality_type
constraints attached to it, which will cause an error with the 5.0
argument given to x.

the text that i wrote earlier about not handling explicit type
variable accessors is accurate, and may be the direct reason why this
doesn't work at the moment.

(2012-08-22-13:48)

i decided to look at the paper, i haven't read this version through
thoroughly yet and just skipped to the part where information where
external labelled syntax and the syntax of constraint terms are shown
(figures 5 and 6). i'm wondering where the other kinds of variables
that we have fit into this, for example the row variables, the type
function variables, the field variables, the typename variables
etc. the equality type variables are essentially currently an extension
of these. there is always type constructor names variable γ, but that
is not the same as a typename variable. hm.

(2012-08-22-15:43)

i want to try a little experiment involving the way some equality
types are represented. i'm going to until 9pm at the very latest and
see if my idea works out, if i don't see it going anywhere then i'll
scrap it and get the test passing mentioned earlier with the rest of
the evening. i'll document the ideas here only if they work out,
otherwise i won't as they'll take time to write up.

this will unfortunately take over the documentation 30 minutes alas,
but i shall be sure and do some of that tomorrow! :-)

(2012-08-22-17:10)

aha, i had it in my head that the type variables being passed around
the constraint generator were type_var constructions, where as in fact
they are just numbers, like the equality type variables that are being
passed around. i was hoping that i could just put the equality type
variable information in the type_var construction, then that would be
one less thing to pass around, but as we are only passing type
variables numbers, this isn't so practical. we can't really constrain
these type variables to be equal to one another with equality type
constraint construction functions because the code would get very
messy with the type of the equality type constraint generation
function being ty.ty -> ty.ty -> label.label -> oneconstraint, and
from that point another constraint would be needed to assign variables
to status values (unless there was a dummy ty form constructed with a
status in it or something), and the whole thing becomes less
modular. if i remember correctly issues with labels arose when i tried
this method too, but this wouldn't have been the case now anyway
because equality type constraints take labels carefully into account
when generating constraints. i'm not happy though that we have
equality type accessors, which basically do the same things as a
normal accessor except they carry the equality type variable that is
needed for the generation of constraints.

i'm going to look at the way that accessors are done now, i'm not
convinced that we can't just wrap the equality type variable
information in the standard accessor that was being used before. if i
can make this happen then it should lead to clearer code in the way
that accessors are solved, which will actually help with the example
that i have been working on anyway.

(2012-08-22-17:40)

i am pretty sure i can sort out these accessors so that they nice,
going to do that now and then continue development on this test
case. didn't take nearly as long as i thought it would to look into
that stuff, great.

i've just to look at the differences between the relevant functions in
the constraint solver.

(2012-08-22-17:51)

actually, the more i look at it, the more the current system actually
looks like a good design. without an accessor specifically for
equality types, the constraint generation functions would have lines
to put equality type information into the 'sem' portion of the each
binder, for example:

val a  = e.genaccieem (e.consaccid (i.id (id, lab)) tv (cl.constyvar()) lab) lab
val a  = e.genaccioem (e.consaccid (i.id (v, lab)) (t.row_var sv) (cl.consoc ()) lab) lab
val a  = e.genaccifem (e.consaccid lid (env1, env2) (cl.consfunc ())lab) lab
val a  = e.genacciiem (e.consaccid lid (e.consenv_var ev lab) (cl.conssig ()) lab) lab

equality type information would need to be wrapped into the row
variables, environment variables and whatever on earth cl.constyvar
returns, which would be nasty to debug later, because wrapping
equality type information in these types would mean that dummy values
would need to be put in (eg equality_type_status(unknown)) which would
be printed out when debugging.

it wouldn't make it any faster to have two accessors instead of one
anyway, because the work done by solving the equality type accessors
is not duplicated in other types of accessors. i'm just going to keep
this as it is and continue working on the current equality type test.

i wrote something about accessors before when i was looking at this
test, now i have re-familiarised myself with the accessor solving
process things should go smoothly i hope. :-)

(2012-08-22-20:25)

alright from the debugging output i think an equality type error is
not detected in this case because the equality type variables aren't
propagated correctly for signatures (which makes sense, as i haven't
done anything with signatures yet). i'm going to tell the analysis
engine that something of the form

val x : [some equality_type] -> [some equality_type]

means that x also has attached to it some information that it too
should be have an equality_type which is passed to it. the constraints
for the term

s.x 5.0

look alright, so i'll put the right information in the binding of x
and it should work fine.

(2012-08-22-22:03)

aww, that alone didn't quite fix everything. this must have something
to do with the signature element. i wrote something about explicit
type variables before, i'm going to go back and read that because i'm
not seeing these come up in the debugging output.

(2012-08-22-22:32)

ah, i didn't have some debugging switches on, silly me. there are some
explicit type variable accessors being solved, i'm not sure what they
are doing though. i'm noticing something suspicious which help me. the
label 40175, which is this example is the label attributed to "5.0",
is being used in this accessor constraint:

accessor_constraint(overloading_classes_accessor(({id(373,40175),row_var(s10541),oc,40175},[40175],[],)))

perhaps this looks up the signature in some way and gets ''a out. now
that would be great, because then i can just pass the equality type
variables through and that should solve this problem. checking now.

(2012-08-22-22:49)

oh god, i didn't realise how many of these kinds of constraints we
actually solve. there are 40 occurrences of this kind of constraint
being solved in just this one example. oh this isn't going to be nice
is it.

ah, some of them are coming from the basis, these label numbers aren't
assigned anywhere in this program. maybe if i filter out the ones from
the basis i'll be left with a reasonable amount to look at.

(2012-08-22-22:53)

just one fits that description. hmm this might be a dead end, i think
it's checking out the real number as an accessor against some binder
in the basis and judging from these label numbers, the binder comes
from somewhere in the basis. i might be wrong. hmmm....

(2012-08-22-22:57)

nope, i'm right, the binder comes from the basis. whatever the
solution is to this problem it doesn't have anything to do with the
accessors for overloading classes. i'll take a look at some of the
other types of constraints that are generated.

(2012-08-22-23:09)

i don't see any constraints that i can look into on the side from the
code 's.x 5.0' or from the signature expression. i'm going to print
out the constraints for the structure. maybe something is happening
like s.x looks up x in the structure s, then the type information for
x is deemed by solving an accessor to the signature binding or
something.

*** 2012-08-23

(2012-08-23-00:19)

haven't been able to find any problems so far, i'm not sure why this
test is not working. i'll take another look at it tomorrow after the
business with the industry people is sorted out.


(2012-08-23-06:57)

i think i see a gap in the constraints that are getting printed out so
perhaps some are being generated that i'm not seeing. when i find the
constraint i'm looking for i'm hoping that it should be easy to make
this test pass.

(2012-08-23-07:34)

the binder for x in the signature expressing is this:

(equality_types) unification.sml: bind = type_dependancy(type_constructor((n1,other_cons,l40152),row_construction([field_construction((1,l40152):type_dependancy(type_var(t46157,-,poly,equality_type_status(un
known)),[40147,40153,40154],[],[]),l40152),field_construction((2,l40152):type_dependancy(type_var(t46157,-,poly,equality_type_status(unknown)),[40147,40154,40155,40156],[],[]),l40152)],-,l40152),l40152,equal
ity_type_status(unknown)),[40148,40149,40150,40151,40152],[],[])

i tried editing this before to contain an equality type status of
equality_type to see what it would do but the unification algorithm
still did not reach the conclusion that an equality type error was
present. hm.

the problem is that what i really want is to look at the equality type
information not on x itself but for the arguments of x, and make the
error at that point, but i'm not sure which constraints.

(2012-08-23-07:53)

i have changed the signature from val x : ''a -> ''a to val x : string
-> ''a in the hope of taking the label associated with the string type
and looking for that in the error that comes up, because this problem
is currently handled.

i see that there is a type constructor accessor being used in this
case, perhaps i need to look into the use of this accessor. i need to
head in to uni to make sure this poster is ready, i'll pick this up
when i next get a moment.

(2012-08-23-10:11)

got the poster and attached the appropriate sticky yellow dots on the
pack. i'll head there in about a half hour or something. it seems the
poster session lasts for two hours and a half, and then it's demos
after that.

*** 2012-08-24

(2012-08-24-10:12)

alright, a week from today i want to be getting pretty damn close to
finishing equality types. i'm going to see how much i can get done in
the next seven days, and hopefully power through a lot of the tasks
that are left.

i'm going to start by updating the list of the things which aren't
handled yet if necessary, then i'll most likely go back to that
example that i've been working on and get that passing today. i really
wanted to get that passing at the end of wednesday but i couldn't find
the constraints that i needed to change in time, hopefully i will be
able to do that today.

(2012-08-24-11:48)

i'm pasting the example here again so i can refer to it without
looking back

structure s : sig val x : ''a -> ''a end =
struct
fun x y = y
end;

s.x 5.0


i can't find any constraints linking the binding of y in the structure
to the ''a type variable in the signature whatsoever. in the program,
the signature comes first, but during constraint generation, we create
the constraints for the signature after generating the constraints for
the structure. i'm going to look at the constraints generated for the
signature and i hope to find a link there between those and the
structure.

what i expect to find is that the binding of x in the signature is
some kind of accessor to the binding x in the structure, but we'll
see.

i changed the first ''a in the signature to 'string' because that's an
error which already works which has the same kind of idea attached to
it. the problem is there is no debugging output associated with that
in the unification algorithm at all, so i have no idea what process
causes that to be an error.

perhaps the solution is to add lots more print statements throughout
the unification algorithm, then search though the output for the
labels 40153-40155 which are the labels associated with the 'string'
usage in the signature.

(2012-08-24-12:13)

i have discovered something, a function called 'matchsigstr' in
unification.sml. it had a nice comment written above it which vincent
wrote so i found it nice and quickly, huzzah! ;-)

this function has the comment:

(* generalises the structure env2 so that it is equal to
 * the signature env1.
 * for functors, b is always true and bfun will be false. *)
fun matchsigstr env1 env2 l filters labs stts deps bfun err =

this function is only called in three locations (ignoring recursive
calls, that doesn't help me here). i'm hoping somewhere around these
locations lies information that i can use to understand where exactly
structures are matched up with their signatures, perhaps the error
will be generated somewhere around there.

one of these locations is when solving functor constraints, i don't
care about that right now. another of these locations is when solving
signature constraints (this sounds like something that i want to
figure out), and the final location is when solving a signature
environment. i will look into both of these locations (not the functor
one, there is no functor in this example) and see what i can find.

(2012-08-24-12:23)

i added in debug print statements to tell me when the unification
algorithm is solving a signature constraints and signature
environments. i see in the output that there are 84 occurrences where
the unification algorithm tries to solve a signature constraint, but
there are no cases where the algorithm tries to solve a signature
environment.

i shall turn my attention to the solving of signature constraints.

(2012-08-24-13:02)

there are no errors generated when solving signature constraints, the
error must be generated elsewhere. i'm going to make the unification
algorithm print to debug whenever it generates any kind of error and
where that error came from. that will tell me at least where the error
is generated, then i can follow the label flow or something.

(2012-08-24-13:38)

alright, an error is generated when fsimplifying a type constraint of
a type variable. that's not quite the level of specificity that i was
after, but i'll take it. i'll print out the labels, and try to figure
out how the labels are built up. more importantly, i want to know how
the labels from the signature and the structure come together.

(2012-08-24-13:53)

i have changed the example because i didn't get the error that i
wanted to test against, it's now this:

structure s : sig val x : string -> string end =
struct
fun x y = y
end;

s.x 5.0


now i get this error:

(constraint_solving) unification.sml: error detected while
fsimplifying a type constraint of a type constructor and a type poly

this might be something that i can work with to help me figure out
what i need to do in order to detect equality type errors. i'm going
to look at the label sets now and try and follow things through.

(2012-08-24-13:56)

using the built-in basis, this is the error that i get:

type constructor clash between string and real:

slice in context:
line 1: structure s : sig val x : string -> string end =
lines 2-5:       ...
line 6: s.x 5.0

slice on its own:
⟨..structure ⟨..s : sig ⟨..val x : ⟨..⟩ string -> ⟨..⟩..⟩ end = ⟨..⟩..⟩;
 ..s.x 5.0..⟩

that's very similar to what i want for the equality type error,
hopefully i can make something rather similar to this.

(2012-08-24-13:57)

oh wait, the error is between a type constructor and a type poly!
that's great, that's exactly what i want isn't it? i can just annotate
the type_poly and the type_constructor with equality type variable
information (well it's won't be a type_constructor because i'll be
using ''a instead of string, but it should be a similar
method). here's the constraint that results in an error:

type_constraint(((type_constructor (typename_construction(string,declaration_cons(39),l548),row_dependancy(row_construction([],-,l549),[547,549],[],[]),l548,equality_type_status(unknown)),type_poly(row_dep
endancy(row_construction([field_construction((1,l39728):type_dependancy(type_constructor (typename_construction(real,declaration_cons(61),l784),row_dependancy(row_construction([],-,l785),[783,785],[],[]),l78
4,equality_type_status(unknown)),[0,3,4,5,6,782,784,1032,39729,39730,39731,39732],[],[]),l39728),field_construction((2,l39728):type_dependancy(type_constructor (typename_construction(real,declaration_cons(61
),l784),row_dependancy(row_construction([],-,l785),[783,785],[],[]),l784,equality_type_status(unknown)),[0,3,4,5,6,782,784,1032,10084,10085,10086,10087,10088,10089,10090,10091,11132,11133,11134,11135,11136,1
1137,11138,11139,11140,11141,11143,11144,11145,39734,39735,39736,39737,39738,39739],[],[]),l39728),field_construction((3,l39728):type_dependancy(type_constructor (typename_construction(a user type,declaratio
n_cons(61),l10090),row_dependancy(row_construction([],-,l10091),[10089,10091],[],[]),l10090,equality_type_status(unknown)),[0,10084,10085,10086,10087,10088,10090,11160,11161,11162,11163,11164,39741,39742,397
43,39744,39745,39746],[],[]),l39728)],-,l39728),[39725,39726,39727,39728,40179],[],[]),51,poly,constant(5.0,373,40179),l40179,equality_type_var(eqtv19691))),[0,3,4,5,6,546,548,1032,40143,40144,40145,40146,40
147,40148,40149,40150,40151,40152,40153,40154,40155,40175,40176,40177,40178,40179],[],))


well would you look at that. there's an equality type variable already
in there, because i already store equality type variable information
in the type_poly term.

i'm guessing that there will be another constraint that instead of
solving a type_constructor and a type_poly will solve a type_variable
and a type_poly (or something), then i can create a constraint between
the two equality type variables that are in the type variable and the
type poly term and i should get an equality type error. this could
work.... so long as i can find such a function! :-)

(2012-08-24-14:11)

there are 45 occurrences of "type_poly" in unification.sml. once i
whittle that down to just pattern match lines there should be maybe 15
or so. from there i'm going to print out the constraints that i'm
getting, and then reset the code example to what i actually want to
pass, and examine all constraints for something that looks like a
unification of ''a and 5.0. from there, edit that point to include the
unification of the equality type variables involved.

(2012-08-24-14:22)

i am getting something out now, there are constraints being unified
between a type_var and a type_poly. i think this might be the case
that i have been looking for, but the type_var constructor currently
doesn't contain equality type information, even though there is a slot
to support such a thing. this might be the time where i now have to
use that slot. it would be really useful if i had the label for the
type_var at the moment, because if that was the same label as the ''a
then that would confirm that this is the right location. but type
variables do not have labels attached to them, so i must have to use
something else.

(2012-08-24-15:58)

finding this constraint is proving to be pretty fiddly, it's like
looking for a needle in a haystack. i have this constraint which looks
like what i want:

type_var(t46158,-,poly,equality_type_status(unknown)) and something
else, namely this: type_poly(..........equality_type_var(eqtv19691))

the question is where the type variable 46158 coming from? type
variables are generated all over the analysis engine so it's anybody's
guess where that was generated. looking at the places in the
constraint generator where the relevant constraints are generated is
not a good move either, as this type variable is most likely created
at unification time, which is to be derived from some other type
variable, which is derived from some other type variable and so on.

i'm not sure what the best option is in terms of how to find out how
to get equality type information into that type variable.

(2012-08-24-16:06)

alright, i'm going to have to use the debug method i used before, and
place fake information inside type variables when they are constructed
in different places around the analysis engine and find the
construction that passes the fake information through to this
point. to do this i'll need to add such information in every type
variable construction in the constraint generation phase and the
constraint solving phase (or at least, keep going until i see the data
show up), and then figure out what to do next from that point.

(2012-08-24-16:10)

i've changed the constype_var function to always put 9999999 in the
equality type variable field of the type variable. if it shows up in
this constraint, then some function which calls constype_var is
responsible (i know it doesn't help much, pretty much everything
calls type_var, i'll have to break it down best i can).

(2012-08-24-16:13)

oh, it didn't show up in this constraint. it did show up in most of
the others, but not in this one. that's good news i think, that should
give me a shorter list to work with.

(2012-08-24-16:20)

i'm about to really do some crazy things which i don't want kept
later, so i'm going to commit now on the devel branch, and revert back
when i figure out where to make the change.

(2012-08-24-16:33)

there are approximately 40 cases here, one of them must construct the
type variable i'm looking for. i'm going to work through the
constraint generator first, then go through the constraint solver.

(2012-08-24-16:46)

alright i found it, but it's in the unification 'freshty' function
which means the root of the problem could be coming from anywhere in
the unification algorithm which calls freshty, and there are 42
occurrences of that. hm.

(2012-08-24-17:29)

i've decided to change freshty so that the equality type information
is carried over between freshening of type variables, which is really
something that would have to be done for this to work anyway. the only
problem with this is that i might loose the information that i have at
the moment. we'll see...

(2012-08-24-17:31)

alright, now that's happened the equality type information in the
type variable which is inside the type constraint is t.unknown. i'll
have to keep going through the cases where t.unknown is generated i
guess. i've changed quite a few of those so there shouldn't be that
many left i hope...

(2012-08-24-18:09)

got it, i'm getting an equality type error now. i need to play with
the labels a bit, because i'm not sure i have the right labels yet,
hrm. i have only one endpoint label too, so i need to look into that.

(2012-08-24-18:11)

wait, i can do this better. i'm putting in an equality type status
when i see ''a but what i should do is put in a variable which has
been constructed with label information.

and i hope that works because currently there is no region
information for the current error that is found... ^^

(2012-08-24-18:17)

ok, i made that change but the slice has wildly incorrect labels, this
is the slice:

equality type required:

slice in context:
lines 1-3335:    ...
line 3336: overload <=  : 'a * 'a -> bool with 'a in (in int, in word, in real, in char, in string)
lines 3337-3347:         ...

slice on its own:
⟨..overload ⟨..⟩ : ⟨..⟩ with ⟨..⟩ in ⟨..⟩..⟩

which is clearly nonsense. i'm not sure how the labels could be so
clearly wrong here. hmm wait... further errors are found. oh dear, all
these slices are the same and they're all nonsense. i'll look at the
labels now.

(2012-08-24-18:27)

ah i see, i think equality type errors are being detected in the
basis, and that's why there aren't any regions in the users code
file. i'm going to make a hack for the moment so that i can look at
the slice i get for the users code to see what that's doing as that
might provide some indication of what's going on, and then come back
and fix this problem, clean up, commit, and test.

(2012-08-24-18:44)

aha:

todo raised: unhandled equality type discovered in the constraint
solver, raised in the 'f_simplify' function of unification.sml

boy am i glad i made that exception. looks like it's trying to solve a
(status, variable) combination which isn't handled. i'll do what
vincent did and just flip the terms around.

(2012-08-25-11:44)

something weird is going on. there is an equality type variable which
is mapped to by two different equality type variables. the question is
what to put in the state map with the equality type variable that's
being mapped to twice. maybe i should just keep the same variable in
the map and update the labels. the unification algorithm should remove
any labels which become irrelevant...

*** 2012-08-25

(2012-08-25-02:23)

i have edited the constraint solving algorithm so that if we see
something of form (var, status), then we do not blindly update the var
in the map to be constrained to status if status is unknown and the
right hand side of the map is currently another equality type
variable. this will stop the equality type variable information
getting over-ridden by unknown status values, which will hopefully
solve this problem.

(2012-08-25-11:35)

hm, this problem must come from either the way that the constraint
solving algorithm handles having an equality type variable mapped to
by two different equality type variables, or possible from not having
built up the correct labels along the way when generating this
constraint. from what i can see the labels look correct though...

(2012-08-25-11:49)

right from what i see here the initial pass of the unification
algorithm works correctly, the right labels are generated and an error
is detected. when the unification algorithm is run a few more times,
it eventually gets to the point where it blows up because it hasn't
got two endpoint labels, and that's because it seems to have removed
all the labels from the error except the label for 5.0.

how can an error be detected with only one label? this is pretty
crazy, it must be because the same constraints aren't being generated
each time for the type_var constructor responsible for holding the
blame for ''a, as the ''a doesn't even appear in the last slice the
minimisation algorithm tries.

(2012-08-25-11:53)

i think i see a bug in the code that's here for solving equality type
status values:

| fsimplify ((e.equality_type_constraint ((equalitytypevar as t.equality_type_var eqtv, equalitytypestatus as t.equality_type_status status), ls, deps, ids)):: cs') l =

when looking up the state of eqtv, if we a status value, then we do
this:

| some (t.equality_type_dependancy((t.equality_type_status statusinmap), resultlabels, resultdeps, resultids)) => |

if (statusinmap = status andalso statusinmap <> t.unknown) then fsimplify cs' l
else
(* generate an error! *)


this is surely incorrect. what happens if status is unknown, but the
one in the map is equality_type or not_equality_type? it looks to me
like an error is generated. the code checks if the status in the map
is unknown, then we can replace it, but it doesn't handle the case if
the status we're currently getting is unknown and the map has
not_equality_type or equality_type in it. this might be the cause for
the problem. i'm not sure what labels to take here either, i'll think
about it.

at the moment i'm going to change it so that if we see an equality
type variable constrained to unknown when it already has a status of
equality_type or not_equality_type in the map then it will just ignore
it. we might actually need to take the labels from that constraint,
hmm.

(2012-08-25-12:14)

unification algorithm is still blowing up. i'm going to try taking the
labels from the unknown equality type status constraint and putting
those in the map, keeping whatever status is there already the same.

oh. doing that broke everything, and it didn't even detect an
error. how can adding more labels to an error cause the analysis
engine to not find an error?

(2012-08-25-12:43)

well, i have added a function to just print out the equality type
state when the analysis engine reaches the point where it doesn't have
an error but it believes it should have because it encountered one on
a previous unification algorithm run:

19684 : equality_type_dependancy((equality_type_status(equality_type),[40153,40154],[40154],[]))
19685 : equality_type_dependancy((equality_type_status(equality_type),[40153,40154],[40154],[]))
19688 : equality_type_dependancy((equality_type_var(eqtv19689),[40151],[],[]))
19690 : equality_type_dependancy((equality_type_status(equality_type),[40154],[40154],[]))
19693 : equality_type_dependancy((equality_type_status(unknown),[40175],[40175],[]))

well.... yes. i can see why that would cause problems, as there's
hardly anything in there! 40153 and 40154 are the ''a type
variable. 40151 is x : ''a -> ''a and 40175 is the 5.0 floating point
number.

what i don't understand is that the state for equality types at the
end of the first pass, where it correctly detects an equality type
error, is this:


state eq:
19684 : equality_type_dependancy((equality_type_status(equality_type),[40153,40154],[40154],[]))
19685 : equality_type_dependancy((equality_type_status(equality_type),[40153,40154],[40154],[]))
19688 : equality_type_dependancy((equality_type_var(eqtv19689),[40151],[],[]))
19690 : equality_type_dependancy((equality_type_status(equality_type),[40154],[40154],[]))
19692 : equality_type_dependancy((equality_type_status(equality_type),[0,40143,40144,40145,40146,40147,40148,40149,40150,40151,40152,40153,40154,40171,40172,40173,40174,40175],[40154,40175],[]))
19693 : equality_type_dependancy((equality_type_status(equality_type),[0,40143,40144,40145,40146,40147,40148,40149,40150,40151,40152,40153,40154,40171,40172,40173,40174,40175],[40154,40175],[]))
19694 : equality_type_dependancy((equality_type_status(equality_type),[0,40143,40144,40145,40146,40147,40148,40149,40150,40151,40152,40153,40154,40171,40172,40173,40174,40175],[40154,40175],[]))

there is lots of label information in this state, certainly enough to
show that there is a type error in the program. hm.

*** 2012-08-27

(2012-08-27-10:16)

going to work on the same example i've been working on for the last
few days and try to get this label problem sorted out. what i might do
is give the error every label in the program at constraint generation
time just to see what the constraint generation algorithm would do
with that information. if it fails then something else is wrong,
because if it has all of the labels in the program then it can't
possibly be a problem with labels.

(2012-08-27-11:40)

i'm almost certain that this has to be a label problem, i've been
constructing artificial label sets to use for this program and that
seems to generate equality type errors perfectly fine. when the
initial equality type error is generated though before minimisation it
looks like all the labels are there, i can't see any that are
missing.

(2012-08-27-13:02)

then again, i just gave created an error with every single label in
the entire program, and the minimisation algorithm still failed.

(2012-08-27-15:20)

one thing i'm noticing is that the state gets reset half way through
for some reason. i assume this is something to do with the
minimisation algorithm, but i might have to look into it and check
that later.

(2012-08-27-15:39)

alright, i've made some kind of headway, there was an equality type
variable not being stripped correctly, and now that it is the state
looks like a lot better (just before unification fails):

state eq:
19684 : equality_type_dependancy((equality_type_status(equality_type),[40153,40154],[40154],[]))
19685 : equality_type_dependancy((equality_type_status(equality_type),[40153,40154],[40154],[]))
19688 : equality_type_dependancy((equality_type_var(eqtv19689),[40151],[],[]))
19690 : equality_type_dependancy((equality_type_status(equality_type),[40154],[40154],[]))
19692 : equality_type_dependancy((equality_type_status(equality_type),[0,40143,40144,40145,40146,40147,40148,40149,40150,40151,40152,40153,40154,40172,40173,40174],[40154],[]))
19693 : equality_type_dependancy((equality_type_status(unknown),[40175],[40175],[]))

the current problem i'm having right now might actually be quite
simple. an equality type error is generated because there aren't two
endpoint labels for the error it's currently working on, but i think
that the error that it's working on is actually not an equality type
error, and is being incorrectly generated because the code to put
equality type status values into the state is not correct in all
instances. hopefully this is indeed the case, as that would be quick
to fix.

(2012-08-27-16:14)

great, this example works now, and the slice looks fine. i'm going to
prod at it until it falls apart so i can find out if anything more
needs to be done in this respect.

(2012-08-27-16:37)

yeah, i'm happy with this. i've added this example to the analysis
engine test database, but i think it's affected something in
code2.sml. i'll have to run through the tests and check for
breakage.

(2012-08-27-17:09)

ah yes there is a bit of breakage here but it shouldn't be too tough
to fix, it's the case where two equality type variables are
constrained to be equal to one another which i changed while i was
debugging. i'll fix that up before merging and pushing.

(2012-08-27-18:47)

fixed the couple of tests that failed, it was due to a trivial
bug. going to commit and merge.

as far as i see it there are four items with respect to equality types
remaining.

-> generating equality constraints for non-accessor based code
-> detection of equality type error where 'eqtype' is in a signature
-> value declarations with ticks

i'll look at another one of these tonight, i'm hoping that value
declarations with ticks and generating equality constraints for
non-accessor based code will not be too complex, i think handling the
eqtype keyword might be a little more work in the sense of getting the
slices right. i'll play around with these a little more this evening.

*** 2012-08-28

(2012-08-28-10:55)

i've moved the text from the whiteboard into this research log file, i
need it to work on.

(2012-08-28-11:49)

did some more printing of the pgfmanual by binary chopping away to
find the pages which the printer silently fails on. the pages are
239,340,645,646. these pages fail to print both from g47 and from my
office. i'll maybe just print these at home or something. anyway,
on to other things.

(2012-08-28-12:03)

i'm going to take a quick look at the
function-type-specified-as-equality.sml test file. it looks like this:

let
    val id : ''a -> ''a = fn x => x
in
    id 5.0
end;

what currently happens is equality_type constraint values are
generated for the ''a terms, and the not_equality_type constraint is
assigned correctly to the 5.0 term, but there is nothing linking the
two up.

there are a few strange equality type variable constraints which are
coming from the basis, i'm not sure where they are coming from
precisely. the code is probably starting to include labels correctly
from the basis, that's something that i'll be looking at soon anyway.

(2012-08-28-12:57)

ok this doesn't look a million miles away from the
solution. currently, when solving the id accessor to the binder
located in the declarations section of the let expression, these
constraints are generated:

(equality_types) unification.sml: solving an equality type accessor. labels = [40165]
(equality_types) unification.sml: sem = equality_type_var(eqtv19693)

(equality_types) unification.sml: id = 1693

(equality_types) unification.sml: bind = type_dependancy(type_constructor((n1,other_cons,l40151),row_construction([field_construction((1,l40151):type_dependancy(type_var(t31861,(1694,40153),poly,equality_type_var(eqtv2233)),[40152,40153]
,[],[]),l40151),field_construction((2,l40151):type_dependancy(type_var(t31861,(1694,40153),poly,equality_type_var(eqtv2233)),[40153,40154,40155],[],[]),l40151)],-,l40151),l40151,equality_type_status(unknown)),[40147,40148,40149,40150,401
51],[],[])

(equality_types) unification.sml: label of binder = 40149

inside there is type variable 31861 which has label 40153, which is
the ''a expression, but it has equality type variable 2233, which is
an equality type variable which is generated from somewhere within the
basis. there's quite a few of the pieces floating around here, i think
i'll go through the constraint generation algorithm for each stage and
check that all equality type variables are being propagated correctly.

(2012-08-28-13:21)

ok yes i think i see the current problem here, these constraints show
the problem:

(equality_types) unification.sml: solving the case of type_var, which is this: type_var(t31855,-,poly,equality_type_status(unknown)) and something else, namely this: explicit_type_var(1694,t31861,l40153,unknown)
(equality_types) unification.sml: solving the case of type_var, which is this: type_var(t31853,-,poly,equality_type_status(unknown)) and something else, namely this: explicit_type_var(1694,t31861,l40153,unknown)
(equality_types) unification.sml: solving the case of type_var, which is this: type_var(t31854,-,poly,equality_type_status(unknown)) and something else, namely this: explicit_type_var(1694,t31861,l40153,unknown)
(equality_types) unification.sml: solving the case of type_var, which is this: type_var(t31857,-,poly,equality_type_status(unknown)) and something else, namely this: explicit_type_var(1694,t31861,l40153,unknown)
(equality_types) unification.sml: solving the case of type_var, which is this: type_var(t31856,-,poly,equality_type_status(unknown)) and something else, namely this: explicit_type_var(1694,t31861,l40153,unknown)
(equality_types) unification.sml: solving the case of type_var, which is this: type_var(t31854,-,poly,equality_type_status(unknown)) and something else, namely this: explicit_type_var(1694,t31861,l40153,unknown)

the explicit_type_var here has an equality type status of unknown,
which would be fine except fro the fact that its label is 40153, which
is the first ''a type variable. put short, equality type constraints
have not been written for explicit type variables yet, so i'll have to
tweak the constraint generator for that.

(2012-08-28-14:00)

note that explicit type variable accessors are only generated for 'a
and ''a terms. i'm adding in code now for the ''a term.

(2012-08-28-14:26)

this equality type variable 2233 that's reared its head is proving to
be confusing. i know it's been generated inside the basis but where or
why is a mystery. the labels associated with it are labels solely
inside the user file that i'm sending in, so why is the variable
generated inside the basis? it's a bit strange.

(2012-08-28-15:02)

i don't know what this label refers to, i tried to print out a
labelled basis file, but pdflatex exploded which isn't actually that
surprising as the file is huge.

(2012-08-28-17:19)

i noticed something in ty.sml which might explain why basic tuple
examples don't work yet, going to have a little look at that
(specifically, the constytuple construction in ty.sml). it's odd that
this works when using any accessor though, though i'm happy that
solution fell out of whatever i was working on at the time.

i'm changing constytuple to have status equality_type, just to see
what happens. perhaps this status will propagate through to where i
want it to go, and i can just set up a constraint to the tuple
components that way. maybe the best solution is to analyse how the
process works with accessors and try and change that solution to work
for tuples without the use of accessors.

(2012-08-28-17:49)

changing constytuple was a dead end, there's not really any solution
available there. i'm going to look at how the code with accessors
works, and see if that can be tweaked a little to accommodate code
examples without accessors.

(2012-08-28-18:06)

in this simple example:

val x = (1, 2.0); x=x

an equality type error is detected because when we look up the binding
of x, we strip all equality type variables that are present inside the
binding. in this case, the equality type variable that is there is
assigned to not_equality_type, which clashes with the equality type
variable passed through when solving the accessor, which is mapped to
equality_type in the state.

well in the case that i'm working on there aren't any accessors to
look up. but the accessor is equivalent to making an equality type
variable for the tuple as a whole, right? or perhaps having that
equality type variable stored in the type variable that represents the
whole term (where then equality type variables inside the tuple should
be stripped).

this is the binding of x for the basic example above.

(equality_types) unification.sml: bind = type_dependancy(type_constructor((n2,other_cons,l40148),row_construction([field_construction((1,l40148):type_dependancy(type_poly(row_dependancy(row_construction([field_construction((1,l39624):typ
e_dependancy(type_constructor((n3,declaration_cons(6),l29),row_dependancy(row_construction([],-,l30),[28,30],[],[]),l29,equality_type_status(unknown)),[0,3,4,5,6,27,29,1032,39625,39626,39627,39628],[],[]),l39624),field_construction((2,l3
9624):type_dependancy(type_constructor((n3,declaration_cons(6),l29),row_dependancy(row_construction([],-,l30),[28,30],[],[]),l29,equality_type_status(unknown)),[0,3,4,5,6,27,29,1032,6043,6044,6045,6046,6047,6048,6049,6050,6586,6587,6588,
6589,6590,6591,6592,6593,6594,6595,6597,6598,6599,39630,39631,39632,39633,39634,39635],[],[]),l39624),field_construction((3,l39624):type_dependancy(type_constructor((n272,declaration_cons(6),l6049),row_dependancy(row_construction([],-,l6
050),[6048,6050],[],[]),l6049,equality_type_status(unknown)),[0,6043,6044,6045,6046,6047,6049,6605,6606,6607,6608,6609,39637,39638,39639,39640,39641,39642],[],[]),l39624),field_construction((4,l39624):type_dependancy(type_constructor((n2
73,declaration_cons(6),l6049),row_dependancy(row_construction([],-,l6050),[6048,6050],[],[]),l6049,equality_type_status(unknown)),[0,6043,6044,6045,6046,6047,6049,6614,6615,6616,6617,6618,39644,39645,39646,39647,39648,39649],[],[]),l3962
4),field_construction((5,l39624):type_dependancy(type_constructor((n275,declaration_cons(6),l6049),row_dependancy(row_construction([],-,l6050),[6048,6050],[],[]),l6049,equality_type_status(unknown)),[0,6043,6044,6045,6046,6047,6049,6632,
6633,6634,6635,6636,39651,39652,39653,39654,39655,39656],[],[]),l39624),field_construction((6,l39624):type_dependancy(type_constructor((n270,declaration_cons(6),l5298),row_dependancy(row_construction([],-,l5299),[5297,5299],[],[]),l5298,
equality_type_status(unknown)),[0,5292,5293,5294,5295,5296,5298,6035,6036,6037,6038,6039,39658,39659,39660,39661,39662,39663],[],[]),l39624),field_construction((7,l39624):type_dependancy(type_constructor((n270,declaration_cons(6),l5298),
row_dependancy(row_construction([],-,l5299),[5297,5299],[],[]),l5298,equality_type_status(unknown)),[0,5292,5293,5294,5295,5296,5298,6035,6036,6037,6038,6039,6043,6044,6045,6046,6047,6048,6049,6050,6641,6642,6643,6644,6645,6646,6647,6648
,6649,6650,6652,6653,6654,6655,6656,39665,39666,39667,39668,39669,39670],[],[]),l39624)],-,l39624),[39621,39622,39623,39624,40150],[],[]),51,poly,constant(1,210,40150),l40150,equality_type_status(unknown)),[40149,40150],[],[]),l40148),fi
eld_construction((2,l40148):type_dependancy(type_poly(row_dependancy(row_construction([field_construction((1,l39728):type_dependancy(type_constructor((n5,declaration_cons(61),l784),row_dependancy(row_construction([],-,l785),[783,785],[],
[]),l784,equality_type_status(unknown)),[0,3,4,5,6,782,784,1032,39729,39730,39731,39732],[],[]),l39728),field_construction((2,l39728):type_dependancy(type_constructor((n5,declaration_cons(61),l784),row_dependancy(row_construction([],-,l7
85),[783,785],[],[]),l784,equality_type_status(unknown)),[0,3,4,5,6,782,784,1032,10084,10085,10086,10087,10088,10089,10090,10091,11132,11133,11134,11135,11136,11137,11138,11139,11140,11141,11143,11144,11145,39734,39735,39736,39737,39738,
39739],[],[]),l39728),field_construction((3,l39728):type_dependancy(type_constructor((n301,declaration_cons(61),l10090),row_dependancy(row_construction([],-,l10091),[10089,10091],[],[]),l10090,equality_type_status(unknown)),[0,10084,1008
5,10086,10087,10088,10090,11160,11161,11162,11163,11164,39741,39742,39743,39744,39745,39746],[],[]),l39728)],-,l39728),[39725,39726,39727,39728,40152],[],[]),52,poly,constant(2.0,373,40152),l40152,equality_type_var(eqtv19683)),[40151,401
52],[],[]),l40148)],-,l40148),l40148,equality_type_status(equality_type)),[40144,40145,40146,40147,40148],[],[])

the closest thing that we have here is an standard equality constraint
between a type_var and a type_poly:

(equality_types) unification.sml: solving the case of type_var, which is this: type_var(t31849,-,poly,equality_type_status(unknown)) and something else, namely this: type_poly(row_dependancy(row_construction([field_construction((1,l39728
):type_dependancy(type_constructor((n5,declaration_cons(61),l784),row_dependancy(row_construction([],-,l785),[783,785],[],[]),l784,equality_type_status(unknown)),[0,3,4,5,6,782,784,1032,39729,39730,39731,39732],[],[]),l39728),field_const
ruction((2,l39728):type_dependancy(type_constructor((n5,declaration_cons(61),l784),row_dependancy(row_construction([],-,l785),[783,785],[],[]),l784,equality_type_status(unknown)),[0,3,4,5,6,782,784,1032,10084,10085,10086,10087,10088,1008
9,10090,10091,11132,11133,11134,11135,11136,11137,11138,11139,11140,11141,11143,11144,11145,39734,39735,39736,39737,39738,39739],[],[]),l39728),field_construction((3,l39728):type_dependancy(type_constructor((n301,declaration_cons(61),l10
090),row_dependancy(row_construction([],-,l10091),[10089,10091],[],[]),l10090,equality_type_status(unknown)),[0,10084,10085,10086,10087,10088,10090,11160,11161,11162,11163,11164,39741,39742,39743,39744,39745,39746],[],[]),l39728)],-,l397
28),[39725,39726,39727,39728,40149],[],[]),52,poly,constant(2.0,373,40149),l40149,equality_type_var(eqtv19682))

equality type variable 19682 turns out to be mapped to
not_equality_type in the state, so if i can track where the generation
of type variable 31849 comes from, perhaps i can track it to a place
where i can insert an equality type variable which is mapped in the
state as an equality_type, causing an equality type error. that should
do the trick. this depends on where this type variable is generated,
if it's generated in some far away abstract place with no link to
expop then it's a dead end.

i see however in the constraint generation output there is this:

type_constraint(((type_var(t31850,-,poly,equality_type_var(eqtv19689)),type_var(t31849,-,poly,equality_type_status(unknown))),[40154],[],))

the problem here is that eqtv19689 is mapped as follows:

40154:  equality_type_constaint(((equality_type_var(eqtv19689),equality_type_var(eqtv19688)),[40154],[],))

where eqtv19688 is mapped to:

equality_type_constaint(((equality_type_var(eqtv19688),equality_type_status(not_equality_type)),[40155],[],))

label 40155 is the label of the second 2.0 term in the example, where the
example is: (1, 2.0) = (1, 2.0)

(2012-08-28-18:25)

the equality type variables which are mapped in the state to
not_equality_type include eqtv19688, eqtv19689, eqtv19682 and
eqtv19683.

if i'm to look for a similar solution to how it's done with accessors,
the only unification constraints to look at are those with those
numbers in them, as they are the values which are going to be
stripped.

equality type variables 19682 and 19683 are very closely related, as
the labels are right beside each other in the program. i'll just
consider these labels, as the other two equality type variables are on
the left hand side of the term, and a solution would be easily just
extended to cover those.

equality type variable 19683 is actually just inferred from 19682 and
there are no real constraints there, so i'm just going to look at the
19682 equality type variable number.

there aren't many constraints including that equality type variable
number, so here they are:

1. (equality_types) unification.sml: solving an equality type constraint of equality_type_var(eqtv19683) and equality_type_var(eqtv19682). deps = [] and labels = [40148]

2. (equality_types) unification.sml: solving the case of type_var, which is this: type_var(t31843,-,poly,equality_type_status(unknown)) and something else, namely this: type_poly(row_var(s10542),52,poly,constant(2.0,373,40149),l40149,equali
ty_type_var(eqtv19682))

3. (equality_types) unification.sml: solving an equality type constraint of equality_type_var(eqtv19682) and equality_type_status(not_equality_type). deps = [] and labels = [40149]

4. (equality_types) unification.sml: solving the case of type_var, which is this: type_var(t31850,-,poly,equality_type_status(unknown)) and something else, namely this: type_poly(row_dependancy(row_construction([field_construction((1,l39728
):type_dependancy(type_constructor((n5,declaration_cons(61),l784),row_dependancy(row_construction([],-,l785),[783,785],[],[]),l784,equality_type_status(unknown)),[0,3,4,5,6,782,784,1032,39729,39730,39731,39732],[],[]),l39728),field_const
ruction((2,l39728):type_dependancy(type_constructor((n5,declaration_cons(61),l784),row_dependancy(row_construction([],-,l785),[783,785],[],[]),l784,equality_type_status(unknown)),[0,3,4,5,6,782,784,1032,10084,10085,10086,10087,10088,1008
9,10090,10091,11132,11133,11134,11135,11136,11137,11138,11139,11140,11141,11143,11144,11145,39734,39735,39736,39737,39738,39739],[],[]),l39728),field_construction((3,l39728):type_dependancy(type_constructor((n301,declaration_cons(61),l10
090),row_dependancy(row_construction([],-,l10091),[10089,10091],[],[]),l10090,equality_type_status(unknown)),[0,10084,10085,10086,10087,10088,10090,11160,11161,11162,11163,11164,39741,39742,39743,39744,39745,39746],[],[]),l39728)],-,l397
28),[39725,39726,39727,39728,40149],[],[]),52,poly,constant(2.0,373,40149),l40149,equality_type_var(eqtv19682))

5. (equality_types) unification.sml: solving the case of type_var, which is this: type_var(t31849,-,poly,equality_type_status(unknown)) and something else, namely this: type_poly(row_dependancy(row_construction([field_construction((1,l39728
):type_dependancy(type_constructor((n5,declaration_cons(61),l784),row_dependancy(row_construction([],-,l785),[783,785],[],[]),l784,equality_type_status(unknown)),[0,3,4,5,6,782,784,1032,39729,39730,39731,39732],[],[]),l39728),field_const
ruction((2,l39728):type_dependancy(type_constructor((n5,declaration_cons(61),l784),row_dependancy(row_construction([],-,l785),[783,785],[],[]),l784,equality_type_status(unknown)),[0,3,4,5,6,782,784,1032,10084,10085,10086,10087,10088,1008
9,10090,10091,11132,11133,11134,11135,11136,11137,11138,11139,11140,11141,11143,11144,11145,39734,39735,39736,39737,39738,39739],[],[]),l39728),field_construction((3,l39728):type_dependancy(type_constructor((n301,declaration_cons(61),l10
090),row_dependancy(row_construction([],-,l10091),[10089,10091],[],[]),l10090,equality_type_status(unknown)),[0,10084,10085,10086,10087,10088,10090,11160,11161,11162,11163,11164,39741,39742,39743,39744,39745,39746],[],[]),l39728)],-,l397
28),[39725,39726,39727,39728,40149],[],[]),52,poly,constant(2.0,373,40149),l40149,equality_type_var(eqtv19682))

6. (equality_types) unification.sml: solving type constraint of two type_poly constructors (eq1=equality_type_var(eqtv19682), eq2=equality_type_var(eqtv19688))...

right, constraints 1 and 3 are not what i want, as they just bind that
variable to a status, which is well handled now. constraint 2 isn't
much use to me either, that's just extending the equality type status
to eqtv19683.

constraints 4, 5 and 6 are the ones with my focus.

constraint 6 is making sure that the two real numbers are of the same
type so that there isn't a type error in the comparison of the
tuple. the function which creates this constraint must know somehow
it's dealing with a tuple, so perhaps something simple could be added
to also check that each component also has a top level equality_type
constraint. this might be a good area to look at.

*** 2012-08-29

(2012-08-29-09:58)

i'm going to work on the sml equality types code tests for a while,
and then try to write something up about the way that equality types
work. i need to think some more about the constraints that i was
getting yesterday, it would be nice to be finding errors in that test
today.

(2012-08-29-10:31)

i still like the idea of looking to see where constraint 6 at the end
of yesterday's log comes from. i'm going to look into that, as that
should work well. essentially, when creating the (type_poly_1,type_poly_2)
constraint, make some constraints (eqtv, type_poly) and (eqtv,
type_poly_2) and check that they are satisfiable. i'll need to find
the point where these constraints are generated, that might take a
little time but the solution would be quite nice, so i'll take a look
at it.

(2012-08-29-13:30)

it looks like we have use the same type variable for each element in a
tuple, so if we have:

(1,2) = (3, 4)

then the type variable used to represent 1 also represents 3. i'm
getting this from the constraints below.

(equality_types) unification.sml: solving the case of type_var, which is this: type_var(t31849,-,poly,equality_type_status(unknown)) and something else, namely this: type_poly(row_dependancy(row_construction([field_construction((1,l39728
):type_dependancy(type_constructor((n5,declaration_cons(61),l784),row_dependancy(row_construction([],-,l785),[783,785],[],[]),l784,equality_type_status(unknown)),[0,3,4,5,6,782,784,1032,39729,39730,39731,39732],[],[]),l39728),field_const
ruction((2,l39728):type_dependancy(type_constructor((n5,declaration_cons(61),l784),row_dependancy(row_construction([],-,l785),[783,785],[],[]),l784,equality_type_status(unknown)),[0,3,4,5,6,782,784,1032,10084,10085,10086,10087,10088,1008
9,10090,10091,11132,11133,11134,11135,11136,11137,11138,11139,11140,11141,11143,11144,11145,39734,39735,39736,39737,39738,39739],[],[]),l39728),field_construction((3,l39728):type_dependancy(type_constructor((n301,declaration_cons(61),l10
090),row_dependancy(row_construction([],-,l10091),[10089,10091],[],[]),l10090,equality_type_status(unknown)),[0,10084,10085,10086,10087,10088,10090,11160,11161,11162,11163,11164,39741,39742,39743,39744,39745,39746],[],[]),l39728)],-,l397
28),[39725,39726,39727,39728,40149],[],[]),52,poly,constant(2.0,373,40149),l40149,equality_type_var(eqtv19682))

(equality_types) unification.sml: solving the case of type_var, which is this: type_var(t31849,-,poly,equality_type_status(unknown)) and something else, namely this: type_poly(row_var(s10544),54,poly,constant(2.0,373,40155),l40155,equali
ty_type_var(eqtv19688))

both of these type variable numbers are the same but the labels are
different, as i've already described. this is quite strange. this
might also be used for things other than the equality of row
variables, so i wouldn't be able to input extra constraints here to
handle this example.

(2012-08-29-14:29)

right, i see where that is happening, it's in the case where a type
variable is being constrained to a type_poly, but the type variable
already exists in the type variable state. in that case, the right
hand side of the state entry is constrained to the aforementioned
type_poly, which is this case leaves us with the constraint type_poly
and type_poly when we recurse to solve.

the best plan might be to track down the type variable which is
constrained to be both of the type_poly terms (tv31849) and make the
constraint there. i'll need to find out where that type variable is
created.

some notes on this type variable:

-> a constraint is made earlier using this type variable (t31850,
   t31849). note that t31850 has eqtv19689 (not_equality_type) attached to it.
-> a constraint is made from this type variable to a row variable
   (s10544), which has the 4.0 constant attached to it and
   eqtv19688 (not_equality_type)
-> this type variable appears in the cst2 variable of expop which
   holds the constraints for the right hand side. the label it's
   attached to is the 40154 label (the right hand side real number, 4.0)
-> type variable t31850 appears in the type constructor constraint
   below. i might need to look at this:

40151:  type_constraint(((type_var(t31846,-,poly,equality_type_status(unknown)),type_constructor (typename_construction(record,other_cons,l40151),row_construction([field_construction((1,l40151):type_var(t31848,-,poly,equality_type_status
(unknown)),l40151),field_construction((2,l40151):type_var(t31850,-,poly,equality_type_status(unknown)),l40151)],-,l40151),l40151,equality_type_status(equality_type))),[40151],[],))

label 40151 here is the tuple on the right hand side as a whole. i see
that the top level status, that is the tuple as a whole, has
equality_type status, this is correct. but each top level element in
the tuple should also have this status. it does however know that we
are dealing with a record (a tuple is just a record is disguise).

there are two field constructions, and each have equality type
variables. tv31848 and tv31850 which i've talked about already.

tv31848 should refer to the integer argument on the left hand side,
the first element of the tuple. i've checked and this is indeed the
case.

so what i should do then is when a record construction is seen on the
left or right hand sides of expop, go through all the field
constructions and constrain each of the type variables in the field
constructions to equality type status equality_type.

*** 2012-08-30
tags: {equality-types, write-up}

(2012-08-30-11:05)

i had a bit of a thought this morning that there would be something in
the constraint path which would help me solve this example, but
unfortunately it doesn't look like that is the case. i see that
atexptuple is called, which then maps over all its components:

val (tvl, eqtvs, csts, csss) = unzipfour (map (f_labexp "x") expl)

the equality type variables here are the equality type variables that
are at the top level that i wanted aren't they? these haven't been
programmed quite right yet, so this information is actually thrown
away. maybe just finding a way to create the constraints for this
function correctly will be enough to make these tests pass.

(2012-08-30-12:53)

i'm going to stop working on this example for a little while as i want
to look at how equality types could be written up (what is essentially
an extension of chapter 14 of vincent's thesis).

(2012-08-30-13:13)

it looks like i need to write possibly these sections:

external syntax
constraint syntax
constraint generation
constraint solving
constraint filtering
slicing

the external syntax section describes to the reader how the sml syntax
that we are handling has changed. so for example the section on
local declarations has a section 14.2.1 in vincent's thesis which
describes the change to the external syntax:

dec ::= local^l dec_1 in dec_2 end

so the external syntax changes that are relevant to describe for
equality types would be the addition of the eqtype keyword to
signature declarations. signatures are discussed in section 14.7, and
an extension to the external syntax is given there. i essentially just
want to extend this extension.

in section 14.7.1 (which shows the external syntax for signatures),
this is shown:

sigid  ∈ sigid      (signature identifiers)

sigdec ∈ sigdec ::= signature sigid \overset{l}{=} sigexp
		  | dot-d ( \overset{--->}{term} )

sigexp ∈ sigexp ::= sigid^l | sig^l spec_1 .... spec_n end
		  | dot-s ( \overset{--->}{term} )

spec   ∈ spec   ::= val vid :^l ty
		  | type dn^l
		  | datatype dn \overset{l}{=} cd
		  | structure strid :^l sigexp
		  | dot-d ( \overset{--->}{term} )

it looks like i would just extend 'spec' to be something like this:

spec   ∈ spec   ::= .... | eqtype dn^l

i can't think of any other external syntax changes apart from the
specification of the eqtype keyword. i need to check to see if ''a
appears in the external syntax as well, as it's possible that it may
have been omitted.

(2012-08-30-13:53)

ok, it doesn't look like ''a is mentioned anywhere in the thesis, so
i'll need to extend any external syntax a little further than that.

(2012-08-30-14:14)

the 'a definition seems to fall under this text:

an internal type τ μ is a type construction and is built from an internal type
constructor μ and its argument τ (such as the polymorphic list type ’a list, where
’a is an explicit type variable in sml). to simplify the formalisation of core-tes,
external (tc) and internal (μ) type constructors both take exactly one argument.

perhaps i would need to point out that τ can now take the form ''a as
well as just 'a.

(2012-08-30-14:29)

actually, i don't think i would have to extend the external syntax for
this. in figure 11.3, we have the definitions:

τ ∈ ity ::= α | τ μ | τ_1 -> τ_2 | <τ, \overset{-}{d} >

where α is defined as α ∈ ityvar  (internal type variables)

that should be sufficient to use ''a in the external syntax. that
said, i will need to be able to distinguish between ''a and
'a. perhaps something like this might be good to do?

α ∈ ityvar   (internal non-equality type variables)
β ∈ ieqtyvar (internal equality type variables)
τ ∈ ity ::= α | β | τ μ | τ_1 -> τ_2 | <τ, \overset{-}{d} >

something like that might come in handy.

(2012-08-30-15:17)

updated this document to have tags. it's about time that was
done. still need to do the rest of this month at some point because
sometimes searching backwards for things is awkward.
*** 2012-08-31
tags: {equality-types, write-up}

(2012-08-31-09:45)

my goal today is to get slices for equality type errors involving
tuples and do some more of the write-up. i'm hoping next week to
improve equality type reporting for signatures using ''a, as some
cases don't work yet, then handle the eqtype keyword.

(2012-08-31-10:12)

i see that the tuple-with-function-call-inside.sml example is working
correctly now, something else i did yesterday must have fixed that
example. i'll add it to the test case database.

(2012-08-31-11:19)

in the test 'signature-equality-constraint-on-tuple.sml', the reason
we don't get a slice is because we pass a tuple in. if the tuple is
made an accessor to a tuple, then the example works (well, three
endpoints appear, which is incorrect, but that's probably trivial to
fix). the most important example right now to fix is the one with
tuples.

(2012-08-31-11:40)

looking over the work that i did yesterday in terms of write-up, i
think some of the text that i wrote about what should be in the
external syntax section should actually be in the constraint syntax
section. so perhaps say that the only external syntax to change is the
addition of the eqtype keyword:

spec   ∈ spec   ::= .... | eqtype dn^l

then under constraint syntax changes perhaps something like this:

α ∈ ityvar   (internal non-equality type variables)
β ∈ ieqtyvar (internal equality type variables)
τ ∈ ity ::= α | β | τ μ | τ_1 -> τ_2 | <τ, \overset{-}{d} >

(2012-08-31-11:58)

there are no new environments, i guess something that i would be doing
would be extending figure 11.7, which contains the constraint
generation rules.

so to take an example, rule g4:

fn pat =>^l exp -|> <α, [(ev=1_1);ev^l;e2;(α \overset{l}{=} α_1 -> α_2)]> <= pat -|> <α_1, e_1>> /\ exp -|> <α_2, e_2>

is annotated with equality type information. anonymous functions, or
indeed any kind of function, is attributed with not_equality_type
status (or, in fact, they are attributed with an equality type
variable which has that status assigned to it in the state map).

(2012-08-31-14:02)

i've been thinking a bit how equality constraints for tuples could be
handled. the issue is basically that atexptuple gets a whole bunch of
equality type variables back from the functions that it calls to work
out constraints for each of the components of the tuple.

it would be nice if the equality type variable that is created at the
atexptuple level could somehow be assigned to all of the equality type
variables for each component. i think this would require a change in
the way that equality type information is represented in the state
though. i'll have to think about this, maybe the equality types in the
state map should be mapped to lists of equality types rather than just
a single equality type. either that, or atexptuple could return a list
of equality type variables? that way they all could be mapped to a
status in expop in a fairly straightforward manner?

** 2012-09
*** 2012-09-02
tags: {equality-types}

(2012-09-02-21:41)

just having a quick a look at things while i'm on a train. this
netbook might not be up to the task, but i'll have a look at the tuple
situation again.

(2012-09-02-21:47)

the mlb files aren't being generated from the .cm files
correctly. it's a bit poor that. there is a bug for it in the bugzilla
database i think, i'll check when i get an internet connection.

(2012-09-02-21:52)

hm yes, after some thought this whole list idea sounds like a good
plan. at the moment, this happens when we encounter a tuple (debug
print statement omitted).

| f_atexp indent (a.atexptuple (expl, _, lab, _)) =
let
  val indent = convertindenttospaces indent
  val tv = t.freshtypevar ()
  val neweqtypevar = t.freshequalitytypevar ()
  val (tvl, equalitytypevars, csts, csss) = unzipfour (map (f_labexp (indent^ss.bottomleftcurve^ss.straightline)) expl)
  val cst = e.unionconstraintslist csts
  val contextsensitivesyntaxerror = e.unioncontextsensitivesyntaxerrors csss
  val c   = e.inittypeconstraint (t.constype_var tv) (t.constytuple tvl lab) lab
in (tv, eqtypevar, e.consconstraint (lab, c) cst, contextsensitivesyntaxerror)
end

so we have a few things concerning equality type variables here:

1) the fresh equality type variable neweqtypevar
2) the equality type variables (equalitytypevars) that come back from
   mapping f_labexp over each of the components in the tuple.

the change i'm proposing would be to generate not just one type
variable, but one for each component in the tuple, then return a list
of them.

this solution would also be used for records (atexprecord), and lists
(atexplist).

by changing the return type of f_atexp i need to also change the
return type f_exp (as it calls f_atexp).

f_exp is called by f_quote, f_labexp, and f_progone. the equality type
variables returned to f_progone aren't used, so that's
irrelevant. f_quote is called only by f_atexp, so that's alright as
that would be changed anyway. and so much for my luck, f_labexp is
called all over the place, so rather a few changes would need to be
made.

right, i'm just going to get on with it and see what i can do before
this train arrives. here goes.

(2012-09-02-22:25)

there's a new function in the constraint generator called
createnewequalitytypevars, which takes as input a list of equality
type variables and a label, and will generate fresh equality type
variables and a constraint between the fresh variable and the one
existing in the list. it's being returned as a pair, so i'll return
from f_atexptuple a list of the left hand side of the pairs as the new
equality type variables, and put the list of the constraints on the
right hand side of the pairs in with the rest of the constraint values
that are being returned.

(2012-09-02-22:59)

alright this should work i think:

| f_atexp indent (a.atexptuple (expl, _, lab, _)) =
let
  val indent = convertindenttospaces indent
  val tv = t.freshtypevar ()
  val (tvl, eqtvs, csts, csss) = unzipfour (map (f_labexp (indent^ss.bottomleftcurve^ss.straightline)) expl)
  (* we can get a whole bunch of equality type varibles back when looking at tuples, because
  * there is an equality type variable for each component of the tuple. we need to create fresh
  * equality type variables for each component and return a list of the fresh variables and the
  * new constraints generated *)
  val (newequalitytypevars, newequalitytypeconstraints) = unziptwo(createnewequalitytypevars eqtvs lab)
  val cst = e.unionconstraintslist csts
  val contextsensitivesyntaxerror = e.unioncontextsensitivesyntaxerrors csss
  val c   = e.inittypeconstraint (t.constype_var tv) (t.constytuple tvl lab) lab
  val newconstraints = foldr (fn (x, xs) => (e.consconstraint (lab, x) xs))
			     cst
			     (c::newequalitytypeconstraints)
  in (tv, newequalitytypevars, newconstraints, contextsensitivesyntaxerror)
end

i don't think we'll lose any constraints using foldr like that, it
should be fine.

i'm going to go ahead and change the other functions to work with this
new return type.

(2012-09-02-23:03)

graargh it's everywhere, this is going to take a few hours. i'll
revert back to this point if everything explodes, though it should be
fine *touches wood*.

*** 2012-09-03
tags: {equality-types}

(2012-09-03-00:21)

leaving a note here for tomorrow. i'm currently changing the f_exp
function to return as its second parameter a list of equality type
variables. ignore the compilation warnings, they are incorrect. look
at the atexptuple case to see what sort of thing we should be doing to
get this list of equality type variables. don't forget to get all the
constraints that are generated for all the equality type variables
too, we're going to need everything.

(2012-09-03-09:31)

going to continue from where i left off yesterday, with any luck i'll
have equality type errors for tuples at the end of the day.

(2012-09-03-11:03)

this is probably going to take all day, but i'll try and stop sometime
around lunchtime and look over some of the text i wrote about writing up.

(2012-09-03-14:57)

what is going on with atexptuple? it gets lists of list of equality
type variables? why is that the case? i'm trying to figure out if
that's something that we want or not. i think it is in the event that
we have tuples inside tuples? hm.

(2012-09-03-15:37)

right it's compiling. i need to go back to atexptuple to sort out that
situation, as i just left it commented out for the moment, i'm going
to run all the tests again to check that they all still.

(2012-09-03-16:24)

the tests broke in some fun new ways but i've patched them back to
health now i think. i'm going to keep doing that until everything is
fine, then i'll go back and work on what to do about the tuple
constraints, then hopefully equality type errors should start
appearing when tuples are involved.

(2012-09-03-16:29)

the tests that are now broken are the ones involving datatype
constructors. i'll look through the log and figure out what's going on
there.

*** 2012-09-04

(2012-09-04-10:17)

didn't get around to any of the write-up yesterday, so i'm going to
look at that a bit now.

(2012-09-04-12:17)

i'm not sure what the deal is with the constraint syntax with respect
to the accessors, should they be extended? i have put in place a new
type of accessor. this will look confusing in the paper because there
is one more type of accessor than there is binder, so that either:

a) needs to be explained as it makes the code clearer (right?)
b) needs to be changed in the implementation (do we sacrifice code quality?)

(2012-09-04-13:05)

alright, enough playing with greek letters. going to try and fix up
the examples that broke yesterday

(2012-09-04-18:07)

had a meeting with joe instead. next steps are to finish the work on
tuples, then handle the eqtype keyword. the val tick tick stuff can be
left until later.

(2012-09-04-23:31)

hm, i can't find this bug which is causing failures in tests involving
equality types and datatypes. one of the constraints must be getting
lost, because no equality type errors are being generated for datatype
constructors. all the other tests seem to work fine... it must be just
one of the cases in the constraint generator for just one of the
abstract syntax tree nodes. question is which one... :/

*** 2012-09-05

(2012-09-05-09:52)

what i'm planning to do today is to find this bug where datatype
constructors no longer get equality type errors because of the new
list representation i'm using to pass things around, then attempt to
get equality type errors with tuples.

if i'm able to do both today, i'll stop and do a bit of writing and
tomorrow look at handling the eqtype keyword.

(2012-09-05-10:06)

the problem seems to be with the equality type variable that's
returned when solving the case of type_var where we get back the
type_poly expression which has the equality type variable inside:

(equality_types) unification.sml: solving the case of type_var, which is this: type_var(t31857,-,poly,equality_type_status(unknown)) and something else, namely this: type_poly(row_var(s10546),51,poly,constant(5.0,373,40164),l40164,equality_type_var(eqtv19689))
(equality_types) unification.sml: solving an equality type constraint of equality_type_var(eqtv19689) and equality_type_status(not_equality_type). deps = [] and labels = [40164]
(equality_types) unification.sml: solving an equality type constraint of equality_type_var(eqtv19690) and equality_type_status(not_equality_type). deps = [40164] and labels = [40163,40164]
(equality_types) unification.sml: solving an equality type constraint of equality_type_var(eqtv19691) and equality_type_status(not_equality_type). deps = [40164] and labels = [40162,40163,40164]
(equality_types) unification.sml: solving an equality type constraint of equality_type_var(eqtv19693) and equality_type_status(not_equality_type). deps = [40164] and labels = [40160,40162,40163,40164]
(constraint_solving) unification.sml: returning 'success' status from the unification algorithm

whereas in the case previously:

(equality_types) unification.sml: solving the case of type_var, which is this: type_var(t31857,-,poly,equality_type_status(unknown)) and something else, namely this: type_poly(row_var(s10546),51,poly,constant(5.0,373,40164),l40164,equality_type_var(eqtv19689))
(equality_types) unification.sml: solving an equality type constraint of equality_type_var(eqtv19689) and equality_type_status(not_equality_type). deps = [] and labels = [40164]
(equality_types) unification.sml: solving an equality type constraint of equality_type_var(eqtv19690) and equality_type_status(not_equality_type). deps = [40164] and labels = [40163,40164]
(equality_types) unification.sml: solving an equality type constraint of equality_type_var(eqtv19691) and equality_type_status(not_equality_type). deps = [40164] and labels = [40162,40163,40164]
(equality_types) unification.sml: solving an equality type constraint of equality_type_var(eqtv19692) and equality_type_status(not_equality_type). deps = [40164] and labels = [40160,40162,40163,40164]
(equality_types) unification.sml: solving an equality type constraint of equality_type_var(eqtv19688) and equality_type_status(not_equality_type). deps = [40164] and labels = [40160,40162,40163,40164]
(equality_types) unification.sml: status already exists in the map for equality type variable (equality_type)! checking for equaliy type error...
(equality_types) unification.sml: equality type error detected. label information: l = 40164, ls = [40154,40155,40156,40157,40158,40160,40161,40162,40163,40164], deps = [40158,40164]

the equality type variable numbers and label information should be
exactly the same because the example has not changed between these
runs. so i can see there is a difference towards the end of this
output.

when solving equality type variable 19691 with the new list
representation, we then move to solve 19693 which is successful and no
error is generated. previously, when solving 19691 we then move to
solve 19692, then 196988 and discover there is an error.

the output from both representations should be exactly the same
(right?), so this difference should be found and changed.

(2012-09-05-10:39)

there is no 19693 variable... so somehow extra equality type variables
must be being generated.

(2012-09-05-11:25)

the diff is proving hard to read, it's going to be easier if the
constraints are generated in the same order with the previous method
as they were with this list representation, not for any technical
reason but just because the diffs will be easier to follow.

(2012-09-05-11:31)

that turned out to be a good idea, there is are only a few differences
here. will bear that in mind for the future.

(2012-09-05-12:01)

i have discovered why the constraints for datatype constructors have
disappeared, and it's to do with the expapp case of the constraint
generation process. previously, the code worked like this with
respect to equality types:

get equality type variable from left hand side α
get equality type variable from right hand side β
make a new equality type variable γ
make constraint α -> γ
make constraint γ -> β
return equality type vairable γ (and new constraints, naturally).

it's now the case that the left hand side and the right hand side are
no longer single equality type variables but are now lists and the
code is currently doing this:

get equality type variables from left hand side α
get equality type variables from right hand side β
make new equality type variables γ_1 to γ_n and create the constraint
γ -> (current list item) over the list (α @ β).
return list of γ variables and list of new constraints.

this is not what used to happen. so now i have to think about what i
want to do. perhaps i want to do something like this:

get equality type variables from left hand side α
get equality type variables from right hand side β
for all α in α_1 to α_n, create constraint α_i -> (δ | δ ∈ β)
return list of γ variables and list of new constraints

this would certainly create at least the same constraints that were
created initially. i'll implement this and see what happens, we should
get the errors back.

(2012-09-05-12:46)

oh wait, i can't do that because the solving algorithm represents
constraints as functions, so an α_i value can't be mapped to two
different β_i values. hm. i'm going to find out if there can indeed be
multiple values in both lists by running through the test database,
that should tell me whether i need to update the constraint solving
algorithm or not.

(2012-09-05-13:00)

there are multiple equality type values on the left and right hand
sides of the application function, which makes things difficult.

i'm going to go back and look at precisely why tuples work when using
accessors but they don't if no accessors are used, otherwise i need to
change the constraint solving algorithm to handle one equality type
variable being constrained to multiple other equality type variables,
which is a headache that i don't want. maybe i can find another,
cleaner solution to this.

(2012-09-05-14:50)

the problem seems to be partially concerned with the way that equality
type variables are propagated with applications, which i don't like
the look of at all. it works well for datatype constructors, but it
doesn't work well in some cases for function application. i'm going to
take a look at it now.

(2012-09-05-16:34)

the application problem is a bug but i'll come back to that, and
continue the tuple work for now. atexptuple will get a list of
equality type variables for the top node of each component of the
tuple. i'll need a special constraint to handle this i think,
essentially just checking if any of the equality type variables it
gets end up mapped to not_equality_type, then the tuple itself cannot
be tested for equality.
*** 2012-09-06

(2012-09-06-12:06)

there are two ideas i have for handling tuples. the first is to just
create a binder for them, then solve the accessor, which might work,
but i still have to think about that some more.

the alternative is to take the fresh equality type variable that is
generated in atexptuple, and make an equality constraint between it
and a *list* of equality type variables that are received by mapping
f_labexp over the components of the tuple (a new constructor would be
needed to represent this). the type of the equality type state map
would have to change so that the right hand side is a list but i think
this would be not too difficult to accomplish.

i'm going to look a little into the binder/accessor idea though,
because that really does work just so well at the moment.

(2012-09-06-13:24)

utilising the way that binders and accessors are represented is a
no-go. i'm going to do it the way that i thought it should be done
anyway, by representing the right hand side of the equality type state
map as a list and allow one equality type variable to be mapped to a
list of items.

the equaltytype datatype in ty.sml is getting a new constructor,
equality_type_var_list, created in mind specifically for tuples and
records. this will allow one equality type variable to be constraint
to a whole list of other equality type variables. the constraint
solving algorithm will need to be extended so that:

a) it can handle and store lists instead of just values of status values
b) if an not_equality_type constraint is attributed to an equality
type variable inside a list on the right hand side of the equality
type state map, the entry is removed and the left hand side be put in
the map as not_equality_type.

(2012-09-06-14:59)

so it turns out that because the state map is of type equalitytypevar ->
equalitytype, and i extended the equalitytype datatype already, the
constraint solver will already handle a system where the right hand
side can be a list of equality type variables. so all i really need to
do is handle the constraint solving rules to include the following
scenarios:

let α, β_1... β_n be equality type variables, and state_eq be the
part of the state map responsible for holding equality type variables.

1. if solving α -> equality_type_var_list(β_1, ... β_n) then:
   - if α ∉ state_eq, insert mapping α -> equality_type_var_list(β_1, ... β_n)
   - if α ∈ state_eq and the right hand side is an
     equality_type_var_list, then raise an exception (i don't think
     this should ever happen). if it's a status, do nothing. if it is
     an equality type variable, raise an exception (surely this should
     never happen either).

2. if solving α -> .... (not_equality_type), then:
   - if α ∉ state_eq, then insert into state_eq: α -> not_equality_type
   - if α ∈ state_eq and the right hand side is an
     equality_type_var_list, then replace the entry in state_eq with:
     α -> not_equality_type. other cases remain the same

3. if solving β -> .... (not_equality_type), and β is in an
   equality_type_var_list for some α, then same procedure as normal
   but with additional constraint α -> not_equality_type in state_eq

(2012-09-06-20:32)

this is all very well and good but point three has a problem. how do we
check if β ∈ an equality_type_var_list for some α? we could look
through all the right hand sides of the map but is that really what we
want to do? isn't that inefficient?

it would be better to have some other component, so when looking up β
in the map part of the information we get back is a list of α values
that β is in the right hand side equality_type_var_list of.

*** 2012-09-07

(2012-09-07-09:52)

the constraint generation side of handling tuples, records, and so on
should be done (at least for tuples, but when this is working
extending it to records should be trivial as i just need to write the
same constraints but in the part of the constraint generator that
handles record abstract syntax tree nodes). all i should need to do is
write the constraint solving algorithm and that will be fine.

the way i'm going to handle the problem i was worrying about in log
entry (2012-09-06-20:32) is to have the right hand side of the state
map for equality types as a tuple, with the first component playing
the role of what the old right hand side used to do and the second
component storing information for the equality_type_var_lists the left
hand side is a member of.

(2012-09-07-12:25)

i've decided that extending the equalitytype datatype to hold this
information isn't the right way to go, there are going to be pattern
match changes everywhere and the only thing that can go on the right
hand side of the tuple state entry is a list of equality type
variables anyway. i'm just going to store that as a plain list and
lose the datatype extension.

(2012-09-07-13:10)

wait no we do need that datatype constructor, it just shouldn't make
its way through to constraint solving. at constraint solving time we
should just unwrap the constructor from the equality type variable
list and put that in the state.

(2012-09-07-13:57)

right that's compiling properly now. i'll write up the constraint
solving rules from the logs yesterday.

(2012-09-07-18:16)

i've had to think a little bit about one of the constraint rules, it's
often the case that a constraint can be made between some α and some
equality_type_list β but α already exists in the map, mapped to some
dependancy γ on an equality type variable. i think in this case the
correct thing is to do γ -> equality_type_list β?

in the case i have, the equality type variable in the dependancy γ i
think is mapped to an equality type status δ in the state. in that
case i should end up with δ -> equality_type_list β, at which point i
should create constraints β_1 -> δ, β_2 -> δ, ..., β_n -> δ?

(2012-09-07-23:36)

i have noticed a little optimisation that can be made to the way
equality types are stored in the state environment. if we currently
are solving some constraint (α, β), where α and β are equality type
variables, if β is not in the state environment then we currently put
the mapping β -> equality_type_dependancy(α) in the state environment.

we do not check however if α currently has an equality type status
assigned to it. i'm going to add in the change that if some mapping α
-> γ exists in the state where γ is an equality type status, then when
handling (α, β) allow the mapping β -> γ to go into the state
environment instead if γ is available. i'll implement this and run the
test framework to make sure this doesn't break anything.

(2012-09-07-23:43)

when i ran this against the test framework i got errors for some tests
because we didn't get multiple endpoint labels. this was a bug, which
has now been fixed. this change will therefore stay in place.

*** 2012-09-08

(2012-09-08-00:14)

i think the constraint solving rules are mostly written now. they might
not be perfect, i will have to test it, i'll try to find some time at
weekend for that. compiling now to test on basic-tuple-example.sml.

(2012-09-08-01:00)

there were a few bugs but i've ironed them out now. now we're getting
great type error slices for the basic-tuple-example.sml code file now,
great! i'll commit to the test framework now and update the master
test files at the remote end.

(2012-09-08-10:57)

i've done a little testing of the tuples and i'm happy with the slices
that i'm getting back, looks good.

i have also extended the solution to work for records (records are
technically a different node in the abstract syntax tree so a few
lines needed inserted in the constraint generation functions
associated with handling those nodes), so we're now getting slices for
these as well.

*** 2012-09-10

(2012-09-10-10:27)

plan is to look at the equality type stuff (the eqtype keyword), and
getting that information put into the slice if necessary.

i think i'm going to look at the theory again tomorrow, and focus on
this today.

(2012-09-10-13:28)

there are a lot of constraints in the basis.sml file, it's going to be
quite hard to debug the constraints that are generated for this
file. i'm not sure how i'm going to figure that one out, i'll need to
restrict the amount of constraints shown to be part of the basis file
somehow i guess.

(2012-09-10-14:50)

ahh, skalpel is being lovely again today. i think i'm going to find a
way to get skalpel to ignore undefined identifiers if the user
specifies they want this, because i for one would like to consider
only this file. i don't care about anything outside the constraint
generator, i just care about the constraint generator.

perhaps the solution is to persuade users to make .tes files rather
than have this option. but then skalpel is going to take ages and i
don't want that. no, that's not the solution, i really just want to
consider this file.

(2012-09-10-15:44)

i'm enhancing the debug options because using constraint_path on the
basis exposed some things that haven't been written yet. it's worth
noting that it's faster to use skalpel than the compiler, which is a
good sign (though it would be much faster if i didn't have to press f7
about 12 times to get past the undeclared identifiers).

(2012-09-10-16:46)

the -d constraint_path parameter has been enhanced so it covers much
more of the abstract syntax tree, i should be able to work with this
better now. there are still a few nodes which don't work correctly,
but it's perfect for the most part.

(2012-09-10-16:53)

quick note here about generating constraints for:

type <something>
type <something> = <something else>
eqtype <something>

i think each of these three cases has its own different abstract
syntax tree node. if this is indeed the case constraint generation
should be not too tricky to do at all (fingers crossed ;).

*** 2012-09-11

(2012-09-11-09:30)

going to look at the theory today and then move on to implementation
at some point, would be good to keep working on that.

(2012-09-11-11:48)

i've looked a little bit at the theory and made some notes on the
whiteboard but there's quite a lot here to parse with my eyes. i'm
going to take a look at this further.

(2012-09-11-17:28)

finished a meeting with joe, i'm going to focus more on the theory
than the implementation in the next few days. i think i might just
work solely on the theory in the day and then work on the
implementation in the evenings or something like that. hoping to do a
bit of the eqtype keyword stuff this evening and then have another
look at the theory tomorrow morning and figure out how i'm going to
play this.

*** 2012-09-12

(2012-09-12-13:54)

i'm going to put the theory that i'm working on in the jpirie-phd
repo. it's going to be probably easier to make edits just in the .tex
file.

*** 2012-09-14

(2012-09-14-23:30)

just leaving a note here for tomorrow, the constraint generation rules
that i'm mocking up for the equality types writeup i think should
contain something like 'l, <something>' above the equals sign in rule
g1 to denote an equality type variable is being used. i think that's
right way to do that. not sure what to do for the other rules yet but
i'll have a think about them.

*** 2012-09-15

(2012-09-15-01:32)

i also think that i am going to have to put some text in the
constraint syntax section after all, as i'm going to need to define
the set of equality type variables (and most likely the equality type
status values as well). i'm not sure how to write that yet but i'll
think about it tomorrow and write something up then.

*** 2012-09-17

(2012-09-17-16:23)

from the way the constraint generator is described in the paper, it
looks like equality type information can be carried around in standard
type constraints, but when i initially tried this idea it did not work
very well as:

- multiple type constraints needed to be created in some cases to have
  the correct labels for equality type errors
- code lost modularity, in constraint generation but particularly in
  constraint solving, as solving algorithm for equality type variables
  got stuffed in with all the type_var solving code
- extra information carried around in type_var constructor which is
  completely irrelevant to equality type error detection
- complex to debug

*** 2012-09-18

(2012-09-18-03:03)

note for tomorrow to find some of the definitions of variables and
write them down from the thesis. flipping backwards and forwards for
definitions is time consuming.

*** 2012-09-19

i'm going to start making a list of the terms in the thesis with odd
names and then maybe we can change them later. joe doesn't like them
either, so i guess they'll end up being changed in the paper.

*** 2012-09-20

(2012-09-20-11:15)

leaving here some notes from the meeting with joe yesterday.

anything of the form:

type <something>

means that <something> is *not* an equality type if the signature in
which this is currently being defined is opaque. if however we see
this:

type <something> = <something else>

then <something> *is* an equality type, provided that the 'where'
keyword does not appear in <something else>. if it does, i think it's
possible that <something> might be not an equality type.

if the signature is translucent, then:

type <something>

does not say anything about the equality type status of
<something>. however,

eqtype <something>

will always mean that <something> is an equality type.

i need to check these rules further with hamlet and by reading the standard.

(2012-09-20-13:51)

these rules don't seem to quite work as i expected. for example,
hamlet thinks this program is typable:

val s = 10;
structure s = struct val x = 10 end;
s = s;

however, by appending this line

s + s;

this would no longer typable under hamlet. skalpel states this is
typable, poly states this is typable also.

*** 2012-09-22

(2012-09-22-22:12)

a few notes on the way that signature constraint generation works (i'm
looking at this because i need to implement equality types for
signatures). i'm still working on the write-up but i'm going to take a
look at this while i am still storing most of the information related
to equality types in my head.

the basis file starts with:

structure basis :> sig

[definition]

end = _structbasis

this is what happens with respect to lexical analysis and parsing.

the ':>' symbol as picked up by the lexer is called 'seal'. it is used
in the first line of code above as the first case of the below ml.grm
fragment:


strbindone :
  strid seal labsigexp equalop labstrexp
    (fn (n, asc) =>
	let val (sid, masc) = strid (l.nextlabel n, asc)
	    val (si, pasc) = labsigexp masc
	    val (se, (q, asc')) = labstrexp pasc
	    val reg1 = r.consreg sealleft sealright
	    val reg2 = r.consreg equalopleft equalopright
	    val re   = getregion equalopright labstrexpleft
	    val ri1  = getregion sealright labsigexpleft
	    val ri2  = getregion labsigexpright equalopleft
	in (a.strbindoneop (sid, si (ri1 @ ri2), se re, [reg1, reg2], n, q), (q, asc'))
	end)
| strid colon labsigexp equalop labstrexp
    (fn (n, asc) =>
	let val (sid, masc) = strid (l.nextlabel n, asc)
	    val (si, pasc) = labsigexp masc
	    val (se, (q, asc')) = labstrexp pasc
	    val reg1 = r.consreg colonleft colonright
	    val reg2 = r.consreg equalopleft equalopright
	    val re   = getregion equalopright labstrexpleft
	    val ri1  = getregion colonright labsigexpleft
	    val ri2  = getregion labsigexpright equalopleft
	in (a.strbindonetr (sid, si (ri1 @ ri2), se re, [reg1, reg2], n, q), (q, asc'))
	end)
| strid equalop labstrexp
    (fn (n, asc) =>
	let val (sid, masc) = strid (l.nextlabel n, asc)
	    val (se, (p, asc')) = labstrexp masc
	    val reg = r.consreg equalopleft equalopright
	    val re   = getregion equalopright labstrexpleft
	    val _ = d.printdebugfeature d.mlgrm d.parsing (fn _ => "pattern detected: strid equalop labstrexp")
	in (a.strbindone (sid, se re, reg, n, p), (p, asc'))
	end)


the first rule is the rule that fires in the code fragment discussed
as it is an opaque signature. the second rule will fire for
translucent signatures, and the third rule will fire if no signature
is specified.

further along the line in constraint generation, we have three cases
for dealing with each of these three structure binding forms. i'll
just look at the first two cases here (using opaque or translucent
signatures).

(* structure binding using an opaque signature *)
and f_strbindone indent (a.strbindoneop (strid, labsigexp, labstrexp, _, lab, _)) =
    let val _   = d.printdebugfeature d.aze d.constraint_path (fn _ => "generating constraints for a.strbindoneop")
	val (ev1, cst1, css1) = f_labstrexp indent labstrexp
	val (ev2, cst2, css2) = f_labsigexp indent labsigexp
	val (ev3, strs, cst3, css3) = f_strid indent strid
	val c    = e.signature_constraint (ev2, none, ev1, some ev3, lab)
	val cst  = e.singleconstraint (lab, c)
	val css  = e.unioncontextsensitivesyntaxerrors [css1, css2, css3]
	val env  = e.row_env (e.constraint_env (e.unionconstraintslist [cst1, cst2]), e.constraint_env cst)
	val cst' = e.singleconstraint (l.dummylab, e.let_constraint env)
   in (strs, e.unionconstraintslist [cst3, cst'], css)
   end
   (* structure binding using a translucent signature *)
  | f_strbindone indent (a.strbindonetr (strid, labsigexp, labstrexp, _, lab, _)) =
    let val _   = d.printdebugfeature d.aze d.constraint_path (fn _ => indent^"a.strbindonetr")
	val indent = convertindenttospaces indent
	val (ev1, cst1, css1) = f_labstrexp (indent^ss.verticalfork^ss.straightline) labstrexp
	val (ev2, cst2, css2) = f_labsigexp (indent^ss.verticalfork^ss.straightline) labsigexp
	val (ev3, strs, cst3, css3) = f_strid (indent^ss.bottomleftcurve^ss.straightline) strid
	val c    = e.signature_constraint (ev2, some ev3, ev1, none, lab)
	val cst  = e.singleconstraint (lab, c)
	val css  = e.unioncontextsensitivesyntaxerrors [css1, css2, css3]
	val env  = e.row_env (e.constraint_env (e.unionconstraintslist [cst1, cst2]), e.constraint_env cst)
	val cst' = e.singleconstraint (l.dummylab, e.let_constraint env)
     in (strs, e.unionconstraintslist [cst3, cst'], css)
     end

constraint generation is very similar in both cases. the main
difference is in the definition of 'c', in which the second and fourth
arguments are reversed. a signature_constraint is:

signature_constraint of evsbind

where ensbind is defined as this:

(* 1st envvar: instantiated signature
 * 2nd envvar: signature matching
 * 3rd envvar: enriched structure
 * 4th envvar: resulting structure
 * the bool if false if we want to impose some restrictions based on the
 * structure env (where clauses). *)
(* warning: it is suspected the above comment may not be relevant to the below. read with caution! *)
type evsbind        = envvar        *
		      envvar option *
		      envvar        *
		      envvar option *
		      l.label

i'll need to really look in the constraint solving code to find out
what the real difference is i guess. i'll try and find some time
tomorrow for that.
*** 2012-09-25

(2012-09-25-21:12)

doing a bit of implementation this evening, might not get as far as
generating new constraints for signatures, depends how long it takes
me to figure out how environment variables are used in the
implementation.

(2012-09-25-22:03)

the difference between the opaque signature constraint generation and
the translucent constraint generation seems to be in the what is put
into the right hand side of the state environment for env3.

in the case of translucent signatures, this is is made on the right
hand side:

buildfenv (*justbuildenv*) env1 state true

and for opaque signatures:

freshenv' (renameenv' env0 state) (some o.empty) false

i had initially thought that buildfenv would be
'buildfreshenvironment', but the buildfreshenv' function call for
opaque signatures has me uncertain on that one.

(2012-09-25-22:36)

yeah, buildfenv looks like it builds a fresh environment:

fun buildfenv env state bstr = buildenv env state (some (f.finitstate ())) bstr

indeed yes, f is the structure fresh, and finitstate initialises a new
state.

(2012-09-25-23:36)

i'm being led off into a series of function calls, might not be able
to untangle this this evening...

*** 2012-09-26

(2012-09-26-00:23)

nope, i'm not able to untangle this right now. this is going to take a
while. will continue with this tomorrow evening if a meeting isn't on
the cards, maybe i'll be able to make sense of more then.

*** 2012-09-26

(2012-09-26-11:04)

i could really, really, really really, really, really, use a list of
all the definitions from vincent's thesis. i'm going to build one at
some point, i might have to do that today.,
*** 2012-09-28

(2012-09-28-17:31)

a short note on how a part of equality type solving with tuples works
because it's not obvious from the code.

we will always generate the constraint equality type variable =
equality type variable list after we have generated the constraints
for the individual tuple components. therefore when solving the
constraint equality type variable = equality type variable list, if
the equality type variable is mapped to a status at some point in the
constraint solving process this will already exist in the state
environment map. this is why the constraint solving code for solving
equality type status = equality type variable list is only present in
the equality type variable = equality type variable list constraint
solving case in the constraint solver.
** 2012-10
*** 2012-10-15

(2012-10-15-11:36)

i've made a basic example including an equality type error, which is below.

signature s =
sig
    eqtype t
end

structure t : s =
struct
    type t = real
end

i can't test this on skalpel at  the moment though because the real
keyword doesn't have equality type constraints attached to it which
come from the basis, so i'm going to have to do that first.

(2012-10-15-15:20)

i may need to make some sort of tiny basis which contains only the
definitions used in my small program, because the output for the basis
is not really practical to work with, it's just huge. i'll need to
take care though that i don't create some solution for my mini-basis
which doesn't actually work for the full basis, because that would be
the very definition of sadness.

(2012-10-15-17:36)

i have made a small basis which i should be able to work with, the
output that i'm getting for the constraint path and for the constraint
generation process is significantly reduced so there's much less
background noise.

the definition of real i believe to be basically a binder, with the
using of the keyoword real in the sml program being an accessor. if so
i should be able to reuse existing code that i wrote for writing other
parts of the equality type problem.

(2012-10-15-17:51)

i've extended the debugging feature information to include the
information for signatures correctly, as the output was buggy. it may
need a bit of tweaking but shouldn't be anything major.

(2012-10-15-22:32)

i've fiddled with the program i'm giving as input and with the cut
down version of the basis and i think i've managed to reduce it down
to about 5 lines or so i should be able to get something out of that.

(2012-10-15-23:44)

the constraints which come from the debugging output are for the
signature expressions and the structure expressions (that is, the body
of the signatures and structures).

*** 2012-10-16

(2012-10-16-00:47)

ah, i might continue to use a sort of mini-basis for debugging, as
i've realised that i'm actually able to print out state information
now without generating vast amounts of information, it might be easier
to do then add debugging mechanisms for printing out different parts
of the state environment.

the information that is coming out of the state environment isn't too
useful, i'm going to need to look at the constraint generator a little
more closely. it would also be useful to get a labelled version of the
basis so i can see which labels are associated with which
constraints. this should again be a minor modification on the existing
debugging framework.

(2012-10-16-01:02)

i'm going to leave this for the night and pick this up again
tomorrow. i need to figure out some way of generating constraints
dependent on whether the signature is translucent or opaque, i'm not
sure that the existing mechanism for doing that will be sufficient. i
think if i attach equality type information to the type variables, it
might be possible be able to use the existing framework, but it will
make the code hard to debug and maintain.

this is a bit difficult to break down easily, as numerous different
parts really need to be working before i can get equality type errors
reported in this way. i might try to attach equality type information
to the real type and get the real keyword in the basis included in a
user slice when the program is for example:

datatype mydt = firstcons of real
firstcons(5.0) = firstcons(5.0)

as currently the real keyword in the basis is omitted. writing
constraints so that keyword is included might be a stepping stone to
this problem, i'll have to think about whether that's worth chasing
after tomorrow.

(2012-10-16-11:13)

it looks like when types are looked up in the basis they are given
a type constructor accessor. i managed to trace one generated for the
type t = real part of the program (same program as yesterday), but i'm
not sure if this accessor will solve itself to a label which exists in
the basis and be able to draw conclusions from that. i'm guessing this
is the case but i'm looking into it now.

(2012-10-16-12:54)

i've added another option to the command line list called "-d
basis_labelling" which will export a labelled basis program. this
shouldn't really be used for the full basis, which may cause head
explosions, but rather for a smaller subset of a basis used for
debugging (which is what i'm using at the moment).

(2012-10-16-13:49)

i'm going to add θ information to the binders for type
constructors. i'll also need to create some mapping θ |-> σ to go into
the state environment (θ and σ are equality type variables and
equality type status values, respectively), but that will be handled
when the constraints for the basis structure are being generated.

(2012-10-16-15:36)

the right place to put this kind of constraint looks to be the
function which deals with type constructor bindigs, f_tyconbind. at
the moment, it does this:

[e.consbindpoly	{id = id, typeofid=(t.type_function_var typefunctionvar, e.type, ref (e.emvar, false)), classofid=(cl.constycon ()), labelofconstraint=lab}])

i'll need to get some θ information in there somehow. should i extend
this binder? or perhaps use the equality type accessor stuff?

(2012-10-16-16:18)

what i'm planning to do is to insert a θ into this point in the
code, then pass the θ back through to the higher level functions which
deals with the signature declaration (eg type xyz vs type xyz =
int). things will still change if the signature is translucent or
opaque though, so how is that going to work?

in truth, if the θ is stored there, then shouldn't the opaque vs
translucent solution work automatically? hm, i guess i'll see when
i've finished implementing this bit, but it seems the right way to go
for the moment.

*** 2012-10-17

(2012-10-17-11:28)

the way that i'm planning to work things out for the moment is that if
we're currently looking at the basis, and we see something of the form
'type x', then give x a not_equality_type status. i'm planning to do
this by putting a θ into the binding of the type constructor, and
passing the θ values back through from f_tyconbind where the type
constructor binding is made through to f_typdescone, and input (θ |->
σ; σ |-> not_equality_type) into the state environment at that
point.

this should at the very least add the basis definition of types into
the type error slice when the user makes an equality type error.

(2012-10-17-12:02)

one approach that i'm looking at is to actually changing the
definition of what a binder actually is. it could be this:

(* a binder is used for program occurences of id that are being bound*)
type 'a bind = {id    : i.id,                        (* identifier for which we generate this constraint *)
		eqaulitytypevar : t.equalitytypevar  (* holds an equality type variable                  *)
		bind  : 'a,                          (* type of the identifier                           *)
		class : cl.class,                    (* status/class of the identifier                   *)
		lab   : l.label,                     (* label of the contraint                           *)
		poly  : p.poly}                      (* constraint on the poly/mono binding if binding   *)

here the field 'equalitytypevar' is added to the bind record.

the other approach would be to put an equality type variable
into the 'bind' portion where the binder is constructed. i'll try
putting it in the bind portion first and see how that goes, then i
should be able to get access to that equality type variable easily
when solving accessors by just grabbing that field and stripping out
the variable.

(2012-10-17-12:44)

it looks like neither of the approaches i looked at are simple. the
first approach means changing the definition of a binder, which means
changes in quite a lot of places as binders are a fairly big part of
the system, on the other hand slotting the equality type variable into
the bind field of the bind record means changing the definition of a
type environment (currently (t.typefunction * t.equalitytypevar *
typenamekind * (varenv * bool) ref) genericenv), which isn't that
pretty either. the type errors are going to take some time to solve
either way, so i'm going to think about this a little more before i
make a decision on which route to go down.

(2012-10-17-16:04)

at..... last. i thought it would take a while, ah well i guess that's
alright. i have added the θ to the 'bind' field of the binder by
adding an extra component in the tuple which is assigned to that
field. hopefully i can play around with the constraints now and get
something working by the time i have to go on a search for something
tasty to eat.

i plan to take a look at the equality type variable that's being
passed around and make sure that's working properly, then constrain it
to be some σ in some higher-up function that the one that deals with
type constructor bindings, and then from there change the accessor so
that it too carries an equality type variable with it, and remove the
σ constraint that currently exists in sconreal. i doubt i'll plough
through all that today but i'll see what i can do.

(2012-10-17-17:40)

the equality type variable propagation has been done up to the point
of the function that deals with the binding of datatype names
(handling a.datname). the equality type variable still needs to be
passed through to the functions that handle a.typdescone, then
a.typdesc and finally a.spectype. it is at the a.spectype level that
the (θ |-> σ) mapping should be constructed. the alternative to
a.spectype is a.speceqtype, naturally, a mapping should occur there as
well but with an equality_type constraint rather than a
not_equality_type constraint. i'll do both at the same time before i
look into getting the accessors working with this equality type
variable to give the real endpoint location in the basis.

(2012-10-17-20:39)

everything should be done now apart from creating the mappings at the
level of spectype as i mentioned earlier. i need to think about what
is going to happen though with translucent signatures though, because
the constraints are different in that case. maybe this will already be
handled for me, perhaps not. i'll need to look and work that out.

*** 2012-10-18

(2012-10-18-02:42)

i've added in the relevant lines so that the mapping from the θ to the
σ values are made, so carrying a θ through from a type constructor
accessor should be the last step in getting the endpoint locations set
up in the basis. i'm going to do that tomorrow. from there, i'm going
to test what happens in the differences between opaque/translucent
signatures and check whether i get any functionality for free as i
suspect i will. assuming that all works tomorrow and i don't run into
any errors which are too crazy i'll just continue to look at the
eqtype x vs type x vs type x = y vs type x = y where ... cases, as
there are a number of options to consider with respect to type
declarations in signatures, and how the signature is used.

this will mean that types which the user cannot check for equality
(currently only real) will be extended to cover every type when this
is working (assuming everything works correctly), aside from the
function type (as functions not being equality types is not specified
in the basis, naturally).

(2012-10-18-11:54)

i foresee a possible problem coming up which i may to have to
fix. the creation of the σ valve is not until the point where we reach
the function that handles a.spectype. at that point the mapping
(θ |-> σ) is inserted into the state with the label attributed to the
current function that is being executed (f_spectype), which means that
it is the 'type' keyword which is held as the endpoint for the
equality type error. i think this is alright actually, this isn't a
problem? will the endpoint always be the 'type' or 'eqtype' keyword
(same goes for eqtype)?

(2012-10-18-12:13)

i'm looking at changing how the accessors hold information. currently,
the definition is this:

type 'a accessorid = {lid : i.lid, sem : 'a, class : cl.class, lab : l.label}

now either i can hold the equality type information for that accessor in the 'sem'
portion of the accessor, or i can give it a new slot in the accessorid
type.

note that accessorid used to be called 'accid', i'm changing this over
now because i don't think 'accid' is really clear enough.

(2012-10-18-12:34)

there's not much in the way of discussion here, the information has to
go into the record as a new field, and not sit in the 'sem' field of
the record (what does 'sem' even mean anyway?). the way that the*
accessors are defined is quite nice the way it is but integrating
equality type information into the sem field isn't practical given the
way accessors are defined in env.sml. i'm going to put the new field
in.

(2012-10-18-13:27)

hurray, skalpel went a long way to helping me solve a type error. my
skalpel-view-next-part of slice binding is broken though, though
perhaps there's something funny going on with my system. also, a
function like skalpel-highlight-slice-at-point would have been useful
here.

(2012-10-18-13:30)

i have made the modifications to accessors and the analysis engine is
compiling again. i should only now have to constrain the θ of the
accessor to be the same as the θ of the binder, and i should be able
to get endpoint locations in the basis for equality type errors.

(2012-10-18-15:43)

the equality type variable is now correctly propagated through a type
constructor accessor and a constraint is made from that to the
equality type variable associated with the binder with the correct
label.

now the same approach needs to be done but this time from the other
side. in this user code:

signature s =
sig
    eqtype t
end

structure t : s =
struct
    type t = real
end


the 'real' keyword has the correct σ attached to it with labels coming
from the basis. the 'eqtype t' also has the correct σ attached to
it. so what needs to be done from here is to get the accessor for the
type t to get the θ that comes from the signature, and then constraint
the θ from the accessor of t to be equal to the θ for the real
keyword, and i should get a type error slice.

(2012-10-18-16:32)

ah, it seems that in the 'type t = real' above, the 't' is not a type
constructor accessor at all, it is fact a binder, which means the
check between that and the type of t specified in the signature occurs
somewhere else. that makes sense i guess. the place where that is
checked is probably the same place that i need to write some equality
type variable information too.

i'm not sure exactly where to go to find where that connection is
made. i expect it's done somewhere in the unification algorithm
though.

(2012-10-18-17:26)

there is a function in the unification.sml file called "matchsigstr"
which has a name indicating it might be relevant to what i want. this
function is used when solving signature environments and when solving
functors, so this might be just the thing.

the whole process of solving signatures i might refamiliarise with to
get a handle on this. it's also worth noting that the matchkind
(signature or opaque) is checked in the solveenv function when
signature_env is pattern matched as an argument, and two different
things are done in each case. probably i want to integrate into that
somehow.

(2012-10-18-17:36)

it looks like i need to blast debug printouts into the matchsigstr so
i can actually figure out for sure whether the parameters env1 and
env2 and for the environments for the signature and structure, and to
find where i might need to insert my equality type constraints. the
function isn't enormous, so i might have got off lightly there.

these names aren't great so i might clean these up a bit, but there is
a function called componetyp, which might perhaps compare a type
declaration? this might be just the place i've been looking for.

(2012-10-18-19:38)

yes, componetyp is indeed the source of this:

| componetyp _ es bind1 =
  list.mappartial
  (fn bind2 =>
    if cl.classisany (e.getbindc bind1) orelse cl.classisany (e.getbindc bind2)
    then none
    else
	let
	    val (tyf1, eqtv1, tnkind1, cons1) = e.getbindt bind1
	    val (tyf2, eqtv2, tnkind2, cons2) = e.getbindt bind2
[.....]

i'm going to constrain the eqtv values here (θ values) to be equal to
one another and see what happens to the final state. i still don't
think i'll get an equality type error yet, i think there are still a
few functions that need propagation code written into them.

(2012-10-18-20:30)

i don't like the label getting used at the location. the whole
structure is probably going to be highlighted which shouldn't be the
case, i guess i'll have to fiddle with that later.

(2012-10-18-21:04)

hooray, i'm almost at the point where i'm done with this example. the
unification algorithm is throwing its usual error:

"error: error! the unification algorithm terminated in a success state,
 but an error was generated previously! hint: it has been found
 previously to be the case that this error is cased by a bug solely in
 the unification algorithm where some labels are not propagated
 correctly..."

i'm sure that's exactly what's happening here too, there's probably
one label that's just been left out along the way, or i have selected
one wrong label and one of the functions in the constraint path (or
during recursive calls in the constraint solver).

after fiddling around with labels, this example should be fine.

(2012-10-18-21:12)

i've had a quick look at the labels and it looks like all the ones
that i wanted to take are in fact there. there are perhaps extra
labels that i have to take because a signature is involved in the
error. i'll have to look into this.

*** 2012-10-19

(2012-10-19-10:14)

i think the labels that are missing are the ones dictating that 'we are
in the user structure', 'we are in the user signature', and 'we are in
the basis'. it'll take some fiddling but i should be able to get
this example working today.

(2012-10-19-12:42)

i have found the missing labels for the user program, which are the
labels for structure declarations and so on. i'm going to look for the
basis ones now, then i'll arrange things so that they get placed into
the state environment. from there i should have an equality type error
for this program.

(2012-10-19-13:04)

i have found the missing labels for the basis portion of the
program. the problem was really how labels are taken in equality type
constraints when solving accessors and signatures.

the question now is how to get these labels into the state environment
with the rest of the labels in the equality type constraints. i'll
look into this now and figure something out.

(2012-10-19-14:26)

these labels can be placed into the state environment by using
t.equality_type_dependancy instead of t.equality_type_var for the
second component of the equality type constraint, then putting the
labels for the structure information inside that dependancy. the
constraint solving rules *should* handle this, but i'll do some
testing now to see whether that will hold up alright.

(2012-10-19-14:48)

wooooo done it. there's a lovely error for the user program:

signature s =
sig
    eqtype t
end

structure t : s =
struct
    type t = real
end

i have checked this with the full basis and i also get the same
result. i'm running the test database to check i didn't blow anything
else up but i expect it to be fine.

(2012-10-19-15:45)

this example also works with any other non-equality type in place of
real, such as 'exn' or 'substring'. the endpoint is highlighted to be
the 'type' keyword in the basis, perhaps that should be 'type real'?
anyway, changing that should be trivial.

(2012-10-19-18:35)

i'm going to take a stab at another of the equality type tests
(value-declaration-with-type.sml) and i need to change the type of a
binder that's used (e.consbindpoly in f_identpat). it'll take a while
but i need to do it anyway because i'm going to need it in another of
the tests i think.
*** 2012-10-26

(2012-10-26-10:15)

a little more on the implementation today. i'm changing the way that
equality type variables are carried through in binders so that the
variable is part of the record itself rather than sitting in the
'bind' field of the declaration of bind. it'll make it easier to pass
the couple of tests that i have left which aren't supported yet and
it'll make understanding the code a little cleaner.

i committed a little work on this last night also, it's sitting in the
devel branch but it won't compile at the moment, i'm going to fix that
up now.

(2012-10-26-11:21)

oh, that didn't take as much time as i thought it was going to, was
expecting another hour of debugging at least.

i'm going to run the test database through and check nothing has
broken, then check the code for constructing the bindings is correct
with the record field, and then remove the old values and run the test
database again. hopefully i should be able to do all that and still
have hours to spare afterwards, i've been through these type errors
before so i should be able to work through these quickly...

(2012-10-26-11:48)

no tests failing, moving on to making sure that the equality type variables
are coming from the record field and not from the 'bind'.

(2012-10-26-12:58)

right i've moved everything over but one of the tests is no longer
passing (basic-eqtype-translucent, a test which uses the eqtype
keyword in a signature). i suspect one of the equality type variables
got lost along the way or something, but i'll find it again :o).

(2012-10-26-13:17)

alright, that's done. i needed to create a new function to grab the
equality type field from a given binder, then use it on two separate
binders and create a constraint that the equality type variables
should be equal. good, glad that didn't take long.

all the tests which currently do not work are the tests with type
annotations, which i believe to be not handled at the moment at
all. those tests and finishing off the use of the eqtype keyword
(errors can be detected incorrectly in user signatures if i remember
correctly) are all that's left, the rest should be 'bugs' rather than
'unsupported features'.

(2012-10-26-13:41)

i'm looking at the value-declaration-with-type.sml example, a simple
example. it looks like there are two problems:

1. the equality type variable associated with the identifier to the
   left hand side of the type annotation is lost

2. when solving valueid_accssor constructors, equality type variables
   are ignored.

with any luck this might be fairly straightforward? all i should have
to do in the first case is go over the constraints and find where one
is getting lost, and in the second case just create a constraint θ_1
=^l θ_2, then the test should pass. i think that's all there is to it
(at least for this test).

(2012-10-26-14:26)

i have a type error slice for this program now, but one of the labels
is wrong. that's fine, should be easy to fix.

(2012-10-26-15:12)

done! this test looks fine now.

*** 2012-10-29

(2012-10-29-12:28)

i'm looking at the test that isn't passing which is relating to
datatype constructor names.

while looking at this i've noticed that the consbindof constraint
generation code isn't using the best way of carrying around type
variables, and it embedding that inside the information which is
already being passed around. i tried this approach because it's
usually the sensible one, but in this case i found it to be
horrendously confusing to debug.

i think it's ok to leave for the moment but i'm going to add a warning
to the top of the file. i might need to fix it up to pass this test.

(2012-10-29-16:50)

i've passed about another three of the tests today which is pretty
good, the three that are left are all really variants on the same
underlying language feature so i'm going to take a stab at that
tonight and see how far i get. if i manage to get some of those done
then the only thing left to do will be finishing the spec eqtype up,
then a bit of testing and development for equality types should be
done i guess.

i've been thinking a little about the constraint generation rules of
the writeup though that i've got in the other repository, and what to
do if the rules have been redefined. maybe i want to present the
equality type feature in all variants of such rules, hrm.

(2012-10-29-21:44)

i'm going to work on the function-type-specified-as-equality.sml test
because it's similar to the other two that are in the folder so if i
can get this one passing i should be able to apply the solution to the
other tests and finish these off.

(2012-10-29-22:03)

this example requires the arguments to a function to be matched with
the signature, and if the signature is ''a then i need to care when it
comes to equality types.

(2012-10-30-00:17)

in the case of thee tests that are remaining in the folder, they are
going to be hard to solve. the way that information is represented
when it comes back from a binders when solving an accessor is not
easy to manipulate and extract information from. i'm not sure how i'm
going to solve these yet. binder information from the test i made
today is below, this is useless to anyone but me.

type_constraint(((type_var(t31890,-,poly,equality_type_status(unknown)),type_dependancy(type_constructor
(typename_construction(arrow,other_cons,l40151),row_construction([field_construction((1,l40151):type_dependancy(type_constructor
(typename_construction(record,other_cons,l40155),row_construction([field_construction((1,l40155):type_dependancy(type_var(t46189,-,poly,equality_type_status(unknown)),[40156,40157],[],[]),l40155),field_construction((2,l40155):type_dependancy(type_var(t46189,-,poly,equality_type_status(unknown)),[40157,40158,40159],[],[]),l40155)],-,l40155),l40155,equality_type_status(unknown)),[40152,40153,40154,40155],[],[]),l40151),field_construction((2,l40151):type_dependancy(type_constructor
(typename_construction(arrow,other_cons,l40161),row_construction([field_construction((1,l40161):type_dependancy(type_var(t46190,-,poly,equality_type_status(unknown)),[40162,40163],[],[]),l40161),field_construction((2,l40161):type_dependancy(type_constructor
(typename_construction(record,other_cons,l40165),row_construction([field_construction((1,l40165):type_dependancy(type_var(t46189,-,poly,equality_type_status(unknown)),[40157,40166,40167],[],[]),l40165),field_construction((2,l40165):type_dependancy(type_var(t46189,-,poly,equality_type_status(unknown)),[40157,40168,40169],[],[]),l40165)],-,l40165),l40165,equality_type_status(unknown)),[40164,40165],[],[]),l40161)],-,l40161),l40161,equality_type_status(unknown)),[40160,40161],[],[]),l40151)],-,l40151),l40151,equality_type_status(unknown)),[40147,40148,40149,40150,40151],[],[])),[40149,40185],[],1693))

if i actually need to read into these field constructions to get the
labels associated with the type annotation portion of the signature
value of the value binding, then it's not going to be nice. hopefully
there is some nicer way the information is represented internally,
i'll have to look around the unification algorithm tomorrow to see if
that's the case.

*** 2012-10-31

(2012-10-31-11:27)

some of the equality type information is going to have to be moved
into the type so that propagation works better. i kept slots in the
types because i thought i might have to come back and use this
method.

(2012-10-31-11:32)

i'm changing the constytuple function to accept something of type
equalitytype so that it can be passed through to the
type_constructor. i'm testing this in the expop function at the
moment so each type variable from the left and right hand side of
expressions have an equality type variable, but they have to get the
same one apparently because of the way type variables are constructed
with constytuple. the equality type variable should end up next to the
type constructor this way.

(2012-10-31-22:04)

still debugging this program. this is going to be unbelievably hard to
follow for any moderate size of program. i can't actually make this
program any smaller though or the error i want to test will disappear,
so i guess i'm going to have to make do. i think i can get something
by modifying the way that equality type variables are generated for
the last component of the different type_var value constructor tuples...

(2012-10-31-23:17)

at the moment i've arranged things so that i face constraints:

(tv1,...,eqtv) |-> (tv2,...,unknown) where (tv2 |->
type_dependancy(tv3,...,unknown)) ∈ stateenv and (tv3 |->
(.....,eqtv2)) ∈ stateenv. in the case where we have two type
variables constrained and the right one has an unknown status but the
left one has a value, the right hand side will acquire that variable
and then go back through the map to make its dependants have that
variable. eventually it should find eqtv2 and cause a type error.

(2012-11-01-00:12)

maybe i can propegate θ values upward through 'tv' values. i'm not
sure, i'll need to work that out somehow.

** 2012-11
*** 2012-11-01

(2012-11-01-10:34)

building on what i had in the last log entry, if i change the second
entry in the state map for tv2 so that the entry have eqtv in it, then
that change should be propagated correctly.

(2012-11-01-14:33)

oh goodie, infinite loops. the above worked, but in the case where the
type variable doesn't exist, if i so much as touch that part of the
state the analysis engine will go into an infinite loop. i suppose
it's nice to know that can happen.

(2012-11-01-15:02)

i managed to get around the infinite loop issue by using a fresh type
variable instead of the one i wanted, which i guess is fine, but there
is a label missing from the error that's reported.

(2012-11-01-18:45)

this is too difficult to debug, there is just far more information
here than there is time for me to read and parse, and then act on,
regenerate, and repeat. i'm going to see what i can do to cut this
down somehow, there is just no way i can go on reading this amount of
information or this is going to take forever.

(2012-11-02-02:01)

i think i've fixed the bug where type bindings in structures aren't
recorded correctly if they are tuples. i'll have to debug that
tomorrow, but it should be alright i think.

*** 2012-11-02

(2012-11-02-12:12)

the test i'm working on at the moment is the same one as yesterday
night. i thought this would be an easier example to debug but it turns
out to be not the case. don't know what's messing this up, hopefully
i'll be able to make some sense of these number.

(2012-11-02-20:51)

the test that's been running is passing now but it's caused a possible
deadbranch in another test if the test is ran forever until all
solutions have been found. i haven't seen this kind of error before,
i'll need to look into it to see if there is an actual problem with
this test.
*** 2012-11-04

(2012-11-05-23:54)

leaving a note for tomorrow:

(constraint_solving) unification.sml: solving the following valueid_accessor accessor:
valueid_accessor(({id(7,52),eqtv34,type_var(t34,-,poly,equality_type_var(eqtv35)),clvar(1),52},[52],[],))
(constraint_solving) unification.sml: new type constraint =   type_constraint(((type_var(t34,-,poly,equality_type_var(eqtv35)),type_dependancy(type_constructor (typename_construction(arrow,other_cons,l29),ro
w_construction([field_construction((1,l29):type_dependancy(type_var(t43,-,poly,equality_type_status(unknown)),[31,32,33,34,35,36,37,38],[],[]),l29),field_construction((2,l29):type_dependancy(type_constructor
 (typename_construction(arrow,other_cons,l28),row_construction([field_construction((1,l28):type_dependancy(type_var(t43,-,poly,equality_type_status(unknown)),[38,39,40,41,42,43,44,45,46],[],[]),l28),field_co
nstruction((2,l28):type_dependancy(type_var(t43,-,poly,equality_type_status(unknown)),[26,27,34,35,36,37,38,47,48],[],[id(8,36)]),l28)],-,l28),l28,equality_type_status(unknown)),[28],[],[]),l29)],-,l29),l29,
equality_type_status(unknown)),[29,30],[],[])),[30,52],[],))

the first field construction looks useful because it contains type
variable 43, which is later checked with the type_poly.

- why is this the case?
- where is variable 43 checked?
- how to print debug information on field constructions?

*** 2012-11-06

(2012-11-06-12:07)

i'm getting a type error for the buried constraints program test now,
but the minimiser is throwing an error after it has generated a slice
for some reason. i haven't looked at the minimiser is much detail so
that's something that may become necessary. i've noticed that some of
the other tests have also started working too which is nice.

the anonymous function with arrow type example doesn't work yet, but
adding a value binding makes the test work correctly which is strange,
i put this down to the different way that types are represented
internally when used as a binder and without the use of a binder but i
shall look into it.

(2012-11-06-23:29)

firstly, the anonymous function works the same without the binder at
all and it's irrelevant thankfully. hopefully that bug has gone away.

there are some more test cases which are passing now which i dealt
with today, which means i have currently 11 equality type tests which
do not pass including the two that joe created
(anonymous-functions-with-arrow-type.sml, and burried-constraints.sml)
which i've been looking at a bit.

in the case of burried-constraints, a type error slice is generated
for that but the minimiser throws some sort of problem. i expect that
somehow a label is not being carried correctly in one of the
constraints, so i'm not overly worried about that for the moment.

in the case of the anonymous-functions-with-arrow-type.sml test, i've
managed to follow the type variables around and see what's
happening. it looks like it shouldn't be difficult to get this test to
pass, so i'm going to work on that this evening.

*** 2012-11-07

(2012-11-07-00:46)

i have extended the definition of the equality type datatype:

and equalitytype = equality_type_var of equalitytypevar
		 | equality_type_var_list of equalitytypevar list
		 | equality_type_status of equalitytypestatus
		 | equality_type_dependancy of equalitytype extlab.extlab
		 | equality_type_on_type of ty

the equality_type_on_type constructor has been added to allow me to
constrain an equality type variable over another type constraint,
which i'll then recurse on. this should allow the
anonymous-functions-with-arrow-type test case to pass, as the equality
type variable from the m = m portion of the problem will be carried
through the type constraints and assigned to them until it reaches the
type_poly constraint, which is not_equality_type, and so the analysis
engine will deduce there is an error.

(2012-11-07-02:02)

i've added the necessary solving rules to support
equality_type_on_type. the rule hasn't been fully written but there's
red warning text that comes up when debugging with the constraint
solving flag if a rule is fired which hasn't been written up yet.

(2012-11-07-02:36)

i'm getting equality type errors for
anonymous-functions-with-arrow-type.sml now, the labels are incorrect
but the essence of the error is certainly there. i'll do the labels
next.

(2012-11-07-11:26)

some of the tests broke with this solution failing with 'not enough
slices'. this isn't anything to worry about, there are a few cases
where some constraints get lost because the recursive call doesn't
contain the correct constraints, i'll fix this up now.

(2012-11-07-11:48)

done that, so that's working fine.i also notice there are some slices
for a few other tests in the not handled pile so i'll look into that
today. i still need to fix the labels for this current test, then
after that i guess i'll move on to the other tests that are in the
not-handled/ folder.

(2012-11-07-14:11)

the basis-anonymous-function.sml test is now passing. i guess that's
not surprising as i'm working on passing another test with anonymous
functions which is more complex. i'll add a solution file for that
soon.

(2012-11-07-18:09)

the labels for the current test that i was talking about isn't quite
as straightforward as i thought. it seems the labels that aren't being
handled are in state ge (which i believe has something to do with
monomorphism, but who really knows). in state ge there is a mapping
from type variable 65 to type variable 10, and in that mapping there
seems to exist all the labels that i want to become part of this
error.

i guess that when solving type var vs type var cases i should look up
this state ge and drag labels out of that that i need along my
journey? i'm not certain about that but it looks like the most likely
explanation for the missing labels at this time.

*** 2012-11-08

(2012-11-08-10:09)

plan is to look into this state ge thing that i was talking about in
the last log. it might be a bit awkward to get if the entry to state
ge for type variable 65 is made at some point after i've finished
dealing with it though. hrm.

(2012-11-08-14:57)

still haven't been able to chase the type variables down, it's quite
tangled in there. some type variable seem to be getting lost along
the way for some reason as some constraints are made on type variables
that don't show up in the state map. will look into this....

(2012-11-08-16:10)

i fixed some of the type variables not showing up, that was a just a
small bug. i found that this state ge is updated when updating a type
variable sometimes, so that must indeed be where my labels keep
disappearing off to. added some debug statements to print that out and
if that's the case i'll think of some way to keep those labels tracked
right through the error.

(2012-11-08-22:57)

hrm this is still not easy. i can't just add these labels into the
constraint because that might blow up other tests, so i guess the
solution is to grab the labels from the state ge map and then put
those in with the equality type variable that's available. i'm going
to try that now.

(2012-11-09-23:57)

after this effort to drag the labels through clumsily into this error
the minimisation algorithm has swiftly dispensed with them. so now
what? i guess i'll sleep on it. hm.

*** 2012-11-09

(2012-11-09-09:24)

well i found out why the label were disappearing, they were actually
irrelevant to the error. a pair of parenthesis somehow got lost in the
test file and that screwed everything up and changed the error result
completely, so the type error slice that i've been getting has been
correct all along. -.-
*** 2012-11-12

(2012-11-12-12:52)

i just had a look at the test involving refs, which incorrectly
generates type error slices.

ref 5.0 = ref 5.0

the definition of ref is this:

datatype 'a ref = ref of 'a

this is a problem, because i think this datatype definition is magical
in the sense that it is only the specific datatype constructor 'ref'
can be compared for equality, irrespective or its argument. for
example, this program is supposed to be typable:

datatype 'a ref = ref of 'a  (* from the basis *)
ref 5.0 = ref 5.0

but this is not:

datatype 'a myref = myref of 'a (* defined anywhere *)
myref 5.0 = myref 5.0

hrm, i'll need to ask joe what to do about that. the choices are
either to have another keyword in the basis which we can parse for
ourselves (eqdatatype or something), or to look for datatypes defined
with the name 'ref' in the basis and do something special for them.

*** 2012-11-13

(2012-11-13-12:39)

i'm working on the test where the equality type status of the argument
to a datatype needs to be taken into account to know the equality type
status of the variable which is of that type. what isn't correct is to
do this:

datatype 'a mydt = a of int
val x : real mydt = ...

and then constrain the equality type variable of 'real' to be of the
same status as that of 'mydt', which is what i have at the
moment. this causes errors to be incorrectly found in the basis. what
actually needs to happen here is that the equality type variable
representing 'real' need to be constrained to be the same as x.

what might work is to have the equality type variable of x dependant
on an equality type variable list which contains the equality type
variables for both 'real' and 'mydt'. that should make sure that x
gets the correct equality type status, because if either the type
constructor or the datatype itself is not an equality type, then x
won't be either.

(2012-11-13-22:08)

type variable 43 in the test argument-test.sml needs to have an
equality_type constraint attached to it somehow, maybe it could be put
in the map with that equality type status somehow? i'm getting this
from:

(constraint_solving) unification.sml: solving constraint:   accessor_constraint(overloading_classes_accessor(({id(12,53),eqtv36,row_var(s4),oc,53},[53],[],)))
(constraint_solving) unification.sml: solving constraint:   type_constraint(((type_var(t35,-,poly,equality_type_status(unknown)),type_poly(row_var(s4),0,poly,constant(5.0,12,53),l53,equality_type_var(eqtv36)
)),[53],[],))
(constraint_solving) unification.sml: solving constraint:   type_constraint(((type_var(t43,-,poly,equality_type_status(unknown)),type_poly(row_var(s4),0,poly,constant(5.0,12,53),l53,equality_type_var(eqtv36)
)),[29,30,31,32,33,34,35,36,37,38,51,52,53],[],))

i think type variable 43 is the type variable that represents the
first field as part of the row constraint on the type of the function
that is being called. it will therefore need to have some kind of
equality type variable attached to it, right?

(2012-11-13-22:39)

it's worth noting that the labels for type variable 43 are for the
(y:'a) part of the program, which is exactly what i'm looking for.

*** 2012-11-15

(2012-11-15-12:16)

going to get rid of some of this equality type accessor stuff if i can
because it's getting in the way of some of the other tests, and
equality type variables are correctly placed in binding expressions
now without having to have a special kind of accessor for it.

i'm not sure what effect this will have on the test framework if i
just take this code out, i think i have solved all the problems which
involved that but i'm not sure yet. i'm going to take that out and see
what happens with respect to the test results.

(2012-11-15-16:44)

type variable 35 in the argument-test seems to be specifically related
to not equality type 5.0 expression in the code, so trying to get an
equality type status on that seems futile. instead, notice how when
valueid_accessor (7,52) is looked up we create this constraint:

new type constraint (equality types) =   equality_type_constaint(((equality_type_var(eqtv34),equality_type_on_type(type_dependancy(type_constructor((n1,other_cons,l29),r
ow_construction([field_construction((1,l29):type_dependancy(type_var(t43,-,poly,equality_type_status(unknown)),[31,32,33,34,35,36,37,38],[],[]),l29),field_construction((2,l29):type_dependancy(type_constructo
r((n1,other_cons,l28),row_construction([field_construction((1,l28):type_dependancy(type_var(t43,-,poly,equality_type_status(unknown)),[38,39,40,41,42,43,44,45,46],[],[]),l28),field_construction((2,l28):type_
dependancy(type_var(t43,-,poly,equality_type_status(unknown)),[26,27,34,35,36,37,38,47,48],[],[id(8,36)]),l28)],-,l28),l28,equality_type_status(unknown)),[28],[],[]),l29)],-,l29),l29,equality_type_status(unk
nown)),[29,30],[],[]))),[30,52],[],))

new type constraint =   type_constraint(((type_var(t34,-,poly,equality_type_var(eqtv35)),type_dependancy(type_constructor (typename_construction(arrow,other_cons,l29),ro
w_construction([field_construction((1,l29):type_dependancy(type_var(t43,-,poly,equality_type_status(unknown)),[31,32,33,34,35,36,37,38],[],[]),l29),field_construction((2,l29):type_dependancy(type_constructor
 (typename_construction(arrow,other_cons,l28),row_construction([field_construction((1,l28):type_dependancy(type_var(t43,-,poly,equality_type_status(unknown)),[38,39,40,41,42,43,44,45,46],[],[]),l28),field_co
nstruction((2,l28):type_dependancy(type_var(t43,-,poly,equality_type_status(unknown)),[26,27,34,35,36,37,38,47,48],[],[id(8,36)]),l28)],-,l28),l28,equality_type_status(unknown)),[28],[],[]),l29)],-,l29),l29,
equality_type_status(unknown)),[29,30],[],[])),[30,52],[],))

type variable 43 comes up there, and given the labels i think that
comes directly from the binder. also, type variable 35 is dependant
on 43. so if there were a not_equality_type constraint on t35 and an
equality_type constraint on t43 then that should make this example
work.

tricky bit is going to be in doing this, t43 is burried under a lot of
constructions. perhaps the θ could have been inserted earlier in the
constraint generation process? unfortunately, 43 < 35 so i think that
might not be the case, either that or the variable numbers have been
regenerated which is possible (though that would be worrying, because
i bet any information attached to those numbers was also scrapped).

(2012-11-15-17:15)

when looking up the binder for label 52 in this example the 'bind'
that is received back when solving value id accessors does contain
type variable 43. but then the fun begins - all of the type variables
are renumbered, so what happens to the equality type information is
anyone's guess.

(2012-11-15-17:49)

the equality type information should now be preserved. before θ_43 was
renamed its number was 31. i'll have to follow that to reach the real
pot of gold, where i can insert a θ which has mapping θ |->
eqaulity_type in the state.

*** 2012-11-16

(2012-11-16-01:25)

i have done all the necessary following of type variables and i think
this should do the trick. the problem with this test was that in some
cases when an explicit type variable was detected of the form
''<letter>, in some cases the equality_type constraint wasn't attached
correctly. also when creating field constraints, the θ values were not
carried through correctly. these should be fixed now, though i've
still got to check this test passes then run it through the test
database.

(2012-11-16-01:53)

i'm changing the ty datatype a little:

	 and ty = type_var          of typevar  * extv  * poly * equalitytype
		| explicit_type_var of id.id  * typevar * label.label * equalitytype

it seems that explicit_type_var cannot carry an equalitytypestatus at
the end and now must carry an equalitytype instead. this is so that it
can hold an equality type variable, which can be constrained to a
status and a label can be put on it, which needs to be kept for
endpoints to work (currently only getting one endpoint on this test).

(2012-11-16-02:27)

this test is passing now, i have to take care of a few nonexhaustive
match exceptions which i raise that come up on other tests but apart
from that this test should be fine.

the datatype-constructor-in-structure-with-sig is now passing also, so
i can add that to the database.

also, function-type-specified-as-equality is partially working,
it looks like a problem with tuples is stopping that from fully
working, but i can look into that.

note that when the problem with tuples is fixed then
the functor-with-tuples.sml test should also pasesd, i changed that
and took the tuples out and put in a single value and we get the
equality type error slice generated from the code i just put in.

the problem with tuples is not fixable by adding the θ to the type_var
representing the tuple, we really need to find the connection with the
variables inside the tuple and the ''a that's in the signature, or the
slice will not be correct.

(2012-11-16-14:25)

i've been working away at passing other tests and the
burried-constraint.sml test started to work properly without the
minimization algorithm breaking down, bonus. a few exceptions are
being raised though and causes four more tests are failing so i'm
going to take a look at that first, then add the tests i have to the
test database and then work out what to do from there.

(2012-11-16-15:08)

fixed the exceptions that were being raised, it's because we don't
know what to do when an equality type variable list is constrained to
another equality type variable list, it's a bit strange that. i don't
think we need to do anything in that case but i'll have a think about
it.

(2012-11-16-15:37)

these results look fine, going to add tests to test database and
commit, then figure out what to do from there.

(2012-11-16-16:42)

all committed and added tests, going to look at another test now or
perhaps do some writeup.

(2012-11-16-18:40)

i'm looking at the tests where tuples are involved in matching against
signatures, there's a piece of the puzzle missing and hopefully it
won't take too long to find out what that missing piece is.

(2012-11-16-20:58)

the missing piece is constytuple, because it takes typevar values and
then constructs ty datatype constructors using constype_var. i have
added a variation on that called constytuplewiththeta which takes ty
values, which i've pre-built with the correct theta in the constraint
generator in the a.atexptuple case.

this should allow the θ values to be carried through correctly in
cases involving tuples.

(2012-11-16-21:05)

and indeed it does! that passes a further 4 tests in the unsolved pile
which is pretty great. going to run the test database and check
nothing else broke and commit this now, i'll add the newly working
tests to the test database tomorrow.

*** 2012-11-17

(2012-11-17-02:15)

newly working tests have been added to the test database. i'm going to
continue to work on these over the weekend as i have some spare
time. hopefully i'll be able to get through the functor signature
related tests, perhaps the op-equals test, define functions as
not_equality_type and have a stab at the datatype leftover problems
too. if i get through all that i'll have 2 tests left in the
not-handled pile, plus tests to fix which used to work but have been
broken (there are about 4 of these if i remeber correctly).

(2012-11-17-12:38)

working on the functor-with-signature-of-structure-visible test
example. this should be easy to pass i think, as i'm getting things
of this form:

(constraint_solving) unification.sml: solving constraint:   type_constraint(((type_var(t20,-,poly,equality_type_var(eqtv32)),type_constructor (typename_construction(real,declaration_cons(3),l15),row_dependan
cy(row_construction([],-,l16),[14,16],[],[]),l15,equality_type_status(unknown))),[0,3,4,5,6,13,15,22,25,27,28,29,30,31,32,34,35,36,38,39,40,41,42,43,44,62,63,64],[],))

equality type variable 32 is set to equality_type, which must have
come from the = expression on the second line of the test. i should
just be able to insert an equality type variable into the
type_constructor for real and then this test will pass.

(2012-11-17-13:11)

added in the appropriate constraint but the minimiser is dying. there
must be a missing label somewhere i guess. hrm. ah well, getting used
to it now so i'm sure i'll find it.

(2012-11-17-13:24)

ah i've made the constraint in the wrong place i think. the constraint
of not_equality_type is made in typdescone, but it cannot be made
here, because that handles things of the form:

type t
and
eqtype t

in the case of eqtype t, obviously the type can be checked for
equality, and putting the not_equality_type constraint here would
violate. instead i'll try and use the equality type variable that i
had coming from there before and put that in the type constructor
constraint.

(2012-11-17-13:43)

ah nice, it seems that a lot of the tests that are failing are failing
for this specific problem. i'll look at this more in-depth in a few
hours, but i hope this solution will make up to 50% of the currently
unhandled/buggy tests pass properly.

at the moment the functor-with-signature-of-structure-visible test is
dying in the minimiser because the link between

val x : t

and

type t = real

isn't made correctly with respect to θ propagation. if this link is
made correctly, then i think it should be the case that these tests
will start to pass.

(2012-11-17-18:42)

i found this in the constraint solving output (for the same test)

(constraint_solving) unification.sml: solving constraint:   type_constraint(((type_var(t12,-,poly,equality_type_status(unknown)),type_constructor (typename_construction(real,declaration_cons(3),l15),row_depe
ndancy(row_construction([],-,l16),[14,16],[],[]),l15,equality_type_var(eqtv7))),[0,3,4,5,6,13,15,22,30,31,32,34,35,36,43,44],[],))

these labels cover everything right up to the 't' portion of 'x :
t'. if these labels could be included in the error along with what i'm
currently getting, i don't think the minimiser would fail any
longer. i'll see if type variable 12 there plays a role in the
constraints, if it does then i should probably be using that.

(2012-11-17-18:48)

type variable 12 isn't used again.. but:

20 : type_dependancy(type_constructor((n5,declaration_cons(3),l15),row_dependancy(row_construction([],-,l16),[14,16],[],[]),l15,equality_type_var(eqtv7)),[0,3,4,5,6,13,15,22,25,27,28,29,30,31,32,34,35,36,38,
39,40,41,42,43,44,62,63,64],[],[])

type variable 20 there contains the same information w.r.t. the real
type but contains _all_ of the labels associated with the
not_equality_type part of the problem. perhaps i can use this.

(2012-11-17-18:51)

and now this:

(constraint_solving) unification.sml: solving constraint:   type_constraint(((type_var(t20,-,poly,equality_type_var(eqtv32)),type_constructor (typename_construction(real,declaration_cons(3),l15),row_dependan
cy(row_construction([],-,l16),[14,16],[],[]),l15,equality_type_var(eqtv7))),[0,3,4,5,6,13,15,22,25,27,28,29,30,31,32,34,35,36,38,39,40,41,42,43,44,62,63,64],[],))

this has all of the labels which relate to the error with the only
problem θ_32 does not exist in the state environment (though
surrounding numbers are all bound to equality_type). if i can find
where this equality type variable got lost and get that added in to
the state environment, perhaps this test will pass correctly.

(2012-11-17-19:06)

found the missing link i think. when solving value id accessors
equality type variables 31 and 32 are in the same scope so some sort
of constraint should be made there. θ_31 has the right status and
labels that i want too, so i'll go for that.

(2012-11-17-19:27)

i've adding in that constraint but there is still a problem where
labels from the not_equality_type portion of the problem still get
lost. i'll take a look at it now but this is definitely better.

(2012-11-17-19:35)

i think i may be trying to solve the equality type variable constraint
too early when we're solving a valueid_accessor. if i wait a few lines
longer i will have access to labs1, which i believe is an enhanced set
of labels attributed to the binding expression. after printing these
out if they look like the labels that i want, i'll take these labels
instead and that might fix things up.

(2012-11-17-19:41)

that didn't work, the labels there are not what i'm looking for. what
i'm actually looking for are the labels that exist in sem, which seems
to be type dependancy in this case. perhaps i can take the labels from
that, that would work but i'm not sure it would work for all
cases. i'll try it and if it works i'll run some tests.

(2012-11-17-20:37)

i got a slice for the test, but it broke the burried-constraints
test. i'm going to have to re-think the solution of this test. i'll
need to make sure that the labels are correct some other way.

(2012-11-18-23:58)

hrm, i might have been looking in the wrong place to find the labels
that i'm looking for. this constraint looks like more what i want i
think:

(constraint_solving) unification.sml: solving constraint:   type_constraint(((type_var(t20,-,poly,equality_type_var(eqtv32)),type_constructor (typename_construction(real,declaration_cons(3),l15),row_dependan
cy(row_construction([],-,l16),[14,16],[],[]),l15,equality_type_var(eqtv7))),[0,3,4,5,6,13,15,22,25,27,28,29,30,31,32,34,35,36,38,39,40,41,42,43,44,62,63,64],[],))

θ_32 and θ_7 are mapped to equality_type and not_equality_type
respectively. also, the full labels are available. i'll look into
this.

*** 2012-11-18

(2012-11-18-00:35)

the idea that i've been looking in the wrong place isn't accurate
because the work that i've done has led to the constraint in the
previous entry being made correctly, as previously equality type
variable 32 did not exist in the state map.

perhaps it should be all downhill from here then, i should be able to
just constrain those equality type variables with those labels and a
new error should come out of it.

on the downside the burried-constraints.sml program i believe is
broken. it's possibly something to do with this partially generated
error. i'll need to look bag at the git diffs to find out what might
have caused such a change.

(2012-11-18-00:51)

this seemed to work though for some strange reason i have three
endpoint labels. i'll need to look at the labelled basis to find out
which labels are the correct ones to take.

just fixed a bug where the -d basis_labelling debug option did nothing
instead of doing what it was supposed to, this should work fine now.

(2012-11-18-01:02)

this test is passing now, so i'm going to run it against the database
and see what the deal is with the burried-constraints.sml test that is
now failing.

(2012-11-18-02:18)

ooft i've finally figured this one out. the problem was that two
equality type variables were being constrained θ_1 = θ_2 and not θ_2 =
θ_1, which it needed to be in this case, because it involved a type
variable which already had its equality type information all worked
out and an accessor, which didn't know what was going on and the label
got mixed up in the type variable's equality type variable constraint,
which it shouldn't have.

in any case, that's another test passed without breakage, i'll add the
test to the test database after i've got some sleep.

(2012-11-18-02:25)

quick note for tomorrow: check out
non-eqtype-in-signature-used-outside-as-eqtype.sml. this test is
failing now, but the solution file looks like it might not be as good
as the slice that we're now getting. take a look at that. actually
maybe not, we don't have a structure slice currently but we have one
for the signature... hmm.

(2012-11-18-11:13)

functor-signature-test is what i'm looking at now, as i there are about
4 tests failing because this problem isn't handled correctly. a type
error slice is generated incorrectly for this variation on the
problem:

functor f (s : sig type t = real end) =
struct
   fun x (y:s.t) z =
       (y=z)
end;

here a type error slice is generated but the z is included in the
error. this should not be the case. it seems that this problem has
something to do with this state entry:

22 : type_dependancy(type_var(t42,-,poly,equality_type_var(eqtv37)),[61,69],[],[])

α_42 is compared with α_7 later on, which is the type variable
assigned to the real type constructor, and then θ_37 is checked
against another equality type variable incorrectly. θ_37 has the
correct labels in it:
37 : (equality_type_dependancy((equality_type_status(equality_type),[45,46,47,60,61,65,68,69],[65],[])), )

with 65 as the endpoint which is the right hand side of the =
operator, so that looks fine. to stop this problem, either α_42
shouldn't be checked with α_7 later on, or α_42 shouldn't have θ_37
attached to it. or perhaps something about the mapping α_22 |-> α_42
will change.

so in this constraint:

(constraint_solving) unification.sml: solving constraint:   type_constraint(((type_var(t22,-,poly,equality_type_status(unknown)),type_constructor (typename_construction(real,declaration_cons(3),l15),row_depe
ndancy(row_construction([],-,l16),[14,16],[],[]),l15,equality_type_var(eqtv7))),[0,1,3,4,5,6,13,15,22,25,27,28,29,30,31,32,34,35,36,51,52,53,54,55,56,57,58,61,65,66,67,68,69],[],10,
11))

we notice that α_22 is mapped to α_42 in the map and then call a new
constraint based on that. perhaps we shouldn't look at the new
equality type variable in the map? the label here doesn't
include 61, the 'z', and i'm not sure we want that.

(2012-11-18-11:49)

i think i know why this this happening. the 'z' is being compared
against the real type constructor so that the analysis engine can
determine that z is of the correct type. however, while it is true
that z has to be of type real, because the left hand side is of type
real, the equality type information should be destroyed. it is not the
case that the equality type variable for z should be checked against
the equality type information for the real type constructor, because
that will generate incorrect error slices.

i think i see a way to fix this by using some of the little-documented
fields at the end of type constraints. i'll need to have a look at
this now but if i can check that they are empty before making the θ
constraints, perhaps this will solve the problem.

(2012-11-18-11:59)

that worked... great. i'm not getting errors for the test when there
should be, but at least i'm not getting incorrect program
slices. going to document that a bit now before proceeding.

(2012-11-18-14:21)

documented that up now. if i can make sure that equality type variable
28 gets an equality type variable attached to it which ends up being
mapped to status not_equality_type then i should be fine. perhaps the
reason for this failing test might be in the constraint generator
rather than the constraint solver.

i made this change in f_labexp, which makes this test pass:

val c   = e.inittypeconstraint (t.constype_varwitheq tv' (t.equality_type_var(eqtypevar'))) (t.constype_varwitheq tv (eqtv)) lab

here the α on the right hand side is constrained with an equality type
var that it got back from the function which returned tv. while this
makes the test pass, it breaks all the other tests, and a variation on
this test under a similar theme also breaks, so we don't want this,
but perhaps something a bit like this.

(2012-11-18-14:40)

might be able to solve this test using the type_on_type constraint
that i made earlier. at the moment it's ignoring a constraint because
i haven't written a pattern match for it. i'll try completing these
pattern match cases, i'm pretty sure that will make this test pass but
it might break others. hrm.

(2012-11-18-14:57)

it doesn't break the others and it solves a lot of problems, this look
like the right way to go. the only problem with it is that there is
_one_ label missing, and it's causing the minimiser to die. when this
label gets into the error that's generated, this test should have a
nice solution.

this might be just a simple case of incorrect label propagation in the
unification algorithm (well, i say simple.. ^^).

(2012-11-18-15:05)

yeah, that worked, good stuff. i also fixed another test which was
not passing which is already in the test database so that's great.

(2012-11-18-17:15)

i've moved on to adding the necessary constraints so that arrow types
are considered types which cannot be tested for equality. the basic
case of just adding a not_equality_type status to the type_constructor
seems simple enough, it's getting the equality_type constraint on the
left hand side that's the difficult part. it's got to be one of these
type variables.

(2012-11-18-19:28)

it seems that there are mappings getting into the state environment
α_1 |-> α_2 where the θ in α_1 and the θ in α_2 would cause an
equality type error. i'm not sure how that is happening, so i'm adding
a constraint so that when we lookup α_1 and get α_2, we check θ_1 and
θ_2 also.

(2012-11-18-22:17)

looking also at the op-equals test.

    let fun gettybinaryop "=" l =
	    let val tv = t.freshtypevar ()
		val tl = t.constype_var tv
		val tr = t.constype_var tv
		val to = t.constybool' l t.builtin_basis_cons
	    in (tl, tr, to)
	    end

this looks useful, where the type variable of = is actually
built. i'll try building these with a θ and see how it goes.

(2012-11-18-23:17)

that worked out just fine, getting an equality type error for that
test now.

*** 2012-11-19

(2012-11-19-09:31)

currently looking at way to get the equality type error slice from
structures to the user in cases where the structure and the signature
combined are an equality type error. there's a problem with this
because i don't see any connection between the labels for a type
declaration in a structure and a variable of that type outside of the
structure. it looks like it checks its type against the signature
alone, though actually that might make sense because variables can't
be used outside of the structure unless they are defined correctly in
the signature.

nevertheless i do need to look inside the structure, so what now? i
could force the type variables to be constrained inside the structure,
but that could affect a number of other tests.

(2012-11-19-22:20)

hrm managed to look at a few tests today but didn't manage to get
through the debug information that was spat out. getting the structure
slice for the test i was working on originally proved to be quite
difficult, so i'm taking a break from that test and i'll come back
around to it, perhaps another test will provide a stepping stone to
solving that problem.

(2012-11-19-23:35)

working on removing bogus slices that sometimes show up, would be good
to get that cleared up. i'm changing the internal representation a
bit, so i've removed part of the old mechanism and am adding something
new in. as a result this test doesn't pass:

(fn x => x) 5.0 = (fn x => x) 5.0

once it does the application equality type constraints will sit in the
type constraints, which is something i've been meaning to get around
to. hopefully i can finish that this evening.

at the moment i'm looking at this constraint:

(constraint_solving) unification.sml: solving constraint:   type_constraint(((type_var(t26,-,poly,equality_type_status(unknown)),type_poly(row_var(s4),0,poly,constant(5.0,8,35),l35,equality_type_var(eqtv18))
),[1,24,25,26,27,28,29,30,31,32,33,34,35,36],[], contextdependancies=7))

if type variable 26 inherited the status of equality_type from
somewhere then this test would be fine... aside from one thing. label
36 represents the right hand side of the = operator, because... um oh
wait. won't the minimiser get rid of that label?

i think it will actually, in which case that's fine, i can just work
on propagating the right equality type variable to t26 and hopefully
this test (and the ones i just broke in the analysis engine by
removing the old constraints) will also pass.

*** 2012-11-20

(2012-11-20-01:43)

i managed to get a solution going, but it only works on the left hand
side of the test! this is pretty odd, i must have added the
constraints to one type variable and not the other, or
something. hopefully easy to fix... *ahem*.

(2012-11-20-03:27)

ugh these numbers. leaving a note. eqtv 17 is constrained with that
which has not_eqaulity_status but 17 has a label from expop =, see
state eq for ref test. maybe that should be possible, i'm not sure i
need to look at this after some sleep.

(2012-11-20-12:50)

just working on an example to get application working perfectly.

(constraint_solving) unification.sml: solving constraint:   type_constraint(((type_var(t14,-,poly,equality_type_status(unknown)),type_var(t16,-,poly,equality_type_status(unknown))),[1,24,25,36],[], contextde
pendancies=))

here is a constraint from this test:

(fn x => 1) 5.0 = 1

this constraint is actually constraining the left and right type
variables, as the labels here are 24, 25 and 36, where 24 is the
equals operator, 25 is the left hand side, and 36 is the right hand
side.

this means that:

- type variable t14 should have equaltiy type status equality_type in the
  type variable because the 5.0 is thrown away and we get 1.

- type variable t16 should have equality type status eqaulity_type for
  this constraint because there is no not_equality_type constraint to
  be gained here.

at the moment they are both unknown. when the left hand side type
variable t14 is not an equality type or an equality type when the
function throws away the 5.0 and when it doesn't (respectively,
i.e. the identity function), then this should be working correctly.

*** 2012-11-21

(2012-11-21-01:30)

both type variable 16 and 18, the two type variables from expop, are
constrained to type variable 30. the equality type variable attributed
to 30 (in both cases, as is correct).

need to check these three constraints

val ti  = t.constytuplewiththeta [t.constype_varwitheq tv1 (t.consequality_type_var eqtv1), t.constype_varwitheq tv2 (t.consequality_type_var eqtv2)] lab
val tvo = t.freshtypevar ()
val c   = e.inittypeconstraint ty (t.constyarrowty ti (t.constype_var tvo) lab t.other_cons) lab

as tvo, which i think is the type variable that all of ti are being
constrained to, and so probably should be the cause as such error, is
not constructed with an equality type variable. if that's the case
then why does tv30 have a θ attached to it, it must be derived? i'll
look into this.

(2012-11-21-10:37)

while both α_16 and α_18 are being constrained to be both equal to
α_30, it seems that tvo in the previous entry actually turns out to be
α_20. i'm not sure where the 30 comes from. interesting though.

this is what α_20 turns out to be constrained to:

(constraint_solving) unification.sml: solving constraint:   type_constraint(((type_var(t20,-,poly,equality_type_status(unknown)),type_constructor (typename_construction(bool,other_cons,l28),row_construction(
[],-,l28),l28,equality_type_status(unknown))),[1,28],[], contextdependancies=))

i'm not entirely sure whether i should be looking at α_20 or α_30
here. while α_20 is tvo, aside from the connection that α_20 is a
record with two fields α_16 and α_18 i don't see where i can make a
good equality type constraint here.

(2012-11-21-10:49)

by removing the tvo constraint, the engine becomes unable to detect
differences in types. i'm not sure why though, because i thought that
would have been done with α_30.

hrm i have just checked that and taving away tvo also makes α_30
disappear, so i'm guessing that α_30 is produced as a result of the
constraint listed in the previous entry.

given this, i think looking at α_30 is probably the way to go.

(2012-11-21-18:52)

hrm still working on this problem but i think i know what's going on,
i must be losing a constraint somewhere either in labexp expressions
or in perhaps expfn. some of the other tests have failed as well which
do not have equality types in them so i'm thinking that it's probably
a missing constraint.

*** 2012-11-22

(2012-11-22-03:53)

finished this problem and cleaned up all the bugs i think that relate
to it, application-related bugs should hopefully now be all gone.

i'm going to move onto datatype constructors tomorrow and get them
working again, after which i've only got a few more tests in the
current database to play around with which don't pass yet.

(2012-11-22-11:54)

just going to commit and push the changes for yesterday (and maybe the
day before), i've still got to update the test database with the tests
that are passing now but for the moment that's fine.

(2012-11-22-15:22)

i'm going to change a little bit what happens when two θ values are
constrained. if we have θ_1 = θ_2 and θ_2 ∈ stateev with mapping
(θ_2 |-> σ), we make consraint θ_1 = σ. this isn't what we should do
though, because if the σ is an unknown equality type status then we
haven't really gained any information. we should instead make θ_2
dependant on θ_1. i'll making this change now, hopefully it won't
break other tests.

(2012-11-22-22:12)

ugh, still reading this output. we have to have some nicer way of
doing this one day, it's taking far too long to do anything. i've
noticed that in untypable programs where we have a type constructor
which takes an int and a type constructor usage where a real is taken
as input, the program will generate an equality type error. i want to
do something very much like this so i'm going to try and follow the
type variables involved in that error around and see what changes when
i add the ''a condition.

*** 2012-11-23

(2012-11-23-11:58)

managed to get that bug fixed after a bit more reading. going to sort
out the test database out now and see what more still has to be done.

(2012-11-23-18:26)

test database all sorted out and passing more tests which is nice. a
test though has broken due to a change in the constraint generation
file, i'm going to binary chop out the changes i've just made until i
find the one that breaks the test, and see if there's a way to keep
all the tests happy. hopefully just turns out to be something simple
that i can fix.

(2012-11-23-19:06)

it was something simple so i've just fixed that up, change committed.

*** 2012-11-24

working a little more on datatype constructors, which account for most
of the tests that don't work correctly at the moment. on this test:

datatype 'a mydt = firstcons of 'a;

fun x y =
firstcons 5.0 = y

there is this constraint:

(constraint_solving) unification.sml: solving constraint:   type_constraint(((type_var(t23,-,poly,equality_type_var(eqtv28)),type_constructor (typename_dependancy(typename_construction(a user type,declaratio
n_cons(6),l29),[28,29],[],[]),row_dependancy(row_construction([field_construction((1,l30):type_var(t42,-,poly,equality_type_status(unknown)),l30)],-,l30),[28,29,30],[],[]),l28,equality_type_status(unknown)))
,[28,32,33,34,49,50],[], contextdependancies=))

it's important to note tv42 here, which is:

(constraint_solving) unification.sml: solving constraint:   type_constraint(((type_var(t42,-,poly,equality_type_var(eqtv26)),type_poly(row_var(s9),0,poly,constant(5.0,12,51),l51,equality_type_var(eqtv26))),[
31,32,33,34,35,36,49,50,51],[], contextdependancies=))

the solution here looks like to add an equality type variable in the
last unknown field of the first constraint which is mapped to a list
of the field construction equality type variables. that's probably a
good way to go about it. note that also that type variable 42 should
have its equality type variable in the type construction there too,
which seems to have fallen off there for some reason.

(2012-11-24-03:10)

i've made an equality type variable for t42 and it's carried around
now, i'll check to make sure it doesn't break any tests.

(2012-11-24-12:15)

there was a case where type variable 42 goes through a function and
comes out as a different type variable but the equality type variable
is getting dropped off, i'm going to attempt to fix that first. after
the equality type variable is carried around everywhere correctly, i
can look at building new constraints.

(2012-11-24-12:23)

hm, it turns out that the constraint i was looking at in the first
entry i made today is not relevant. the type variable 42 that i'm
looking at is the type variable assigned to the explicit type variable
that sits next to the typename in datatype declarations. this isn't
useful to me because i need to have the equality type status of the
5.0 term in play, and not (at the moment) the value of 'a expression
(i think this might be useful in another test however). so the
constraint up above, repeated here:

type_constraint(((type_var(t42,-,poly,equality_type_var(eqtv17)),type_poly(row_var(s9),0,poly,constant(5.0,12,51),l51,equality_type_var(eqtv26))),[
31,32,33,34,35,36,49,50,51],[], contextdependancies=))

this is just checking that 5.0 and 'a are unifiable, which they
are. i'm looking for another constraint to make this test work
correctly.


(2012-11-24-12:33)

i think this is the constraint that i've actually been looking for:

(constraint_solving) unification.sml: solving constraint:   type_constraint(((type_var(t25,-,poly,equality_type_var(eqtv32)),type_constructor (typename_dependancy(typename_construction(a user type,declaratio
n_cons(6),l29),[28,29],[],[]),row_dependancy(row_construction([field_construction((1,l30):type_var(t42,-,poly,equality_type_var(eqtv17)),l30)],-,l30),[28,29,30],[],[]),l28,equality_type_status(unknown))),[1,
28,32,33,34,47,48,49,50,52],[], contextdependancies=))

θ_32 is mapped to equality_type is it's the θ responsible for
representing the equals operator. θ_17 doesn't have the right σ
attached to it so i'm going to work on that first.

(2012-11-24-13:08)

that's been done now, but there is going to be an issue with equality
type variable freshening.

the status i'm assigning to θ_17 shouldn't actually be assigned to
θ_17 but to some other θ which is fresh but still represents that part
of the program. for example:


datatype 'a mydt = firstcons of 'a;
firstcons 5.0;
firstcons 5

an equality type error would be generated incorrectly in this case. if
θ_17 represents the left hand 'a, then the 5.0 will constrain that
θ to have σ not_equality_type, then when 5 is applied to it in line 3
we would get a clash between equality_type (int) vs not_equality_type
('a), where the non-equality type status of 'a has been derived from
the 5.0. i'm going to look into to freshening this now with each use,
i suspect this will have something to do with accessor lookup.

(2012-11-24-13:17)

working on the freshening now, but there may be the problem in that
freshening the θ variables will loose equality type information
expressed by explicit type variables representing an equality type
(''a). i think what needs to happen here is that when freshening the
equality type variable we take the entry that's assigned to it in the
map, and copy that to a fresh equality type variable. the issue with
that however is that this would need to be done recursively to handle
equality type dependancies!

work needs to be done on the freshty function then, to make sure that
equality type variables are freshened safely.

some sort of 'freshequalitytype' function is nedeed which will take an
equality type variable, and generate a fresh one where all the
information is preserved but re-numbered, so for example if freshening
θ_1 and θ_1 -> θ_2 ∈ stateeq, then we generate θ_3, where mapping θ_3
-> θ_4 is in stateeq and the information of θ_3 and θ_4 match the
information about θ_1 and θ_2 respectively and perfectly.

*** 2012-11-25

(2012-11-25-13:02)

i have managed to make use of a function that i had written before
which strips equality type variables from a given type. i'm hoping
that i'll be able to use this to strip the equality type variables
from a type constructor's row dependancy's row constructor's field
constraints, which will allow me to find errors where arguments of
datatype constructors are involved against a σ that is
equality_type. hopefully this won't cause problems where there are
irrelevant equality type variables, that's the main problem that i can
see.

(2012-11-25-14:29)

having a problem with labels, where the analysis engine thinks that
the datatype constructor is not relevant to the error when in fact it
is. i think the way that equality type variables are being stripped
means that the minimiser can throw away lots of information. perhaps
what is needed is some kind of much more general mechanism, for
example pattern matching on a longer phrase of the constraint that is
generated which will stop the minimiser from throwing information we
need away, for example:

(constraint_solving) unification.sml: solving constraint:   type_constraint(((type_var(t25,-,poly,equality_type_var(eqtv32)),type_constructor (typename_dependancy(typename_construction(a user type,declaratio
n_cons(6),l29),[28,29],[],[]),row_dependancy(row_construction([field_construction((1,l30):type_var(t42,-,poly,equality_type_var(eqtv17)),l30)],-,l30),[28,29,30],[],[]),l28,equality_type_status(unknown))),[1,
28,32,33,34,47,48,49,50,52],[], contextdependancies=))

at the moment the process is descending into this constraint and
stripping the equality type variables of the type constructor out and
constraining them to be equality to the equality type variable of the
type_var expression. perhaps instead might be to pattern match on this
entire expression aside from the field_constructions values, then
strip the equality type variables from that.

(2012-11-25-14:50)

great, that worked. i still need to do the freshening though otherwise
we'll get bogus errors in some cases, eg

datatype 'a mydt = firstcons of 'a;

firstcons 5.0;

fun x y =
firstcons 5 = y

the code above will be marked as untypable if freshening isn't done
correctly, as firstcons is deemed to be not an equality type forever,
so when compared with the equals operator an error is generated. i'll
hope to have this finished today also.

*** 2012-11-26

(2012-11-26-20:13)

Have been working on a few tests today involving testing functions for
equality and the ref test, both of which are now passing. i'm working
on one of the datatype tests at the moment but the solution that i
have generates a slice for clashes in status between type
constructors and basis definitions not only for datatype constructors
but for type functions too, which is incorrect. i cannot however check
at generation time whether we're currently dealing with a type or a
datatype in a PatTyped expression.

There is some kind of identifier constraint that comes up during
constraint solving time but I don't think I'm going to be able to use
this to my advantage. Finding a way to pass this test while checking
the identifier class of the typename though might be tricky.

*** 2012-11-27

(2012-11-27-00:17)

Having a quick look at this test again. Not sure how I can pass this
easily without generating errors for the basis types as well as user
types erroneously. I can think of a couple of solutions but I don't
really like them.

(2012-11-27-01:08)

For the moment I've commented out the line that generates the correct
slice for the datatype-argument-test but that generates incorrect
slices for the basis. I still can't see any nice way to do that for
the moment, I'll have to take another look at this later.

(2012-11-27-13:02)

I just found out that the commit last night contained a bug that
fails another test, going to take a break looking at some of the
theory to fix this because that test shouldn't be breaking.

Some constraints were removed that I thought were now irrelevant, but
one of them was obviously still being useful.

(2012-11-27-14:04)

Found it, going to commit that now so it doesn't get lost in the mist
of whatever I'm going to work on this afternoon.

(2012-11-27-14:49)

Ah, excellent! Found a test that was actually passing but the solution
was incorrect, must have happened sometime in the last couple of
days. Ah well that's good, 4 left currently.

Perhaps it's time to move onto this test about opaque and translucent
signatures. At the moment the opaque signature constraint blocks any
equality type constraints from appearing inside the signature or
structure, whereas the opaque signature should really put a
NOT_EQUALITY_TYPE constraint on all type variables. I'll look into
this now.

(2012-11-27-14:56)

I think I've worked out what to do when we see an opaque
signature. At the moment what happens is the structure is entirely
hidden from the type constraints outside but the signature is still
valid. The trick is going to be to set all of the type variables to
status NOT_EQUALITY_TYPE inside the signature with the non-equality
endpoint being the opaque signature label.

This might be more difficult to pull off, but hopefully I should have
an idea how long it's going to take to change that around in the next
hour or so.

(2012-11-27-15:18)

I had briefly considered the idea of changing the constraint
generation rules for signatures to be different when being used
translucently or opaquely. This is not possible because signatures can
be defined on their own (signature S = sig ... end) and then used
opaquely or translucently. Just something worth noting because I need
to bear that in mind, the differences in constraint generation must
happen somewhere like for example f_strbindone.

(2012-11-27-15:35)

It is ONLY in the case of 'type <something>' that we want to generate
a Σ of NOT_EQUALITY_TYPE with the label of the opaque signature. If it
has a 'type <something> = <something else>' syntax then we have
equality type information that we can use.

(2012-11-27-16:21)

Right I think I have a plan of action for this test. When seeing a
SpecType we don't know if the signature is being used opaquely or not,
so I'm going to put the label for the SpecType at the end of the
equality constraint that will now be generated. Then when generating
an opaque structure constraint I will look inside the constraints for
the signature environment for equality type constraints with such
labels (no other labels will exist). If they are found, I will
generate a fresh equality type variable mapped to NOT_EQUALITY_TYPE
with the endpoint label of the opaque structure expression, put that
in place of the old equality type constraint, and pass the updated
environment through to the structure, where the type will not be an
equality type.

This will mean that outside the structure, and in other structures
using other kinds of signatures, this equality type status will be
unique and will not break any other tests, and will still work when
being used translucently.

(2012-11-27-17:15)

Changed my mind with this a bit, instead of using the context
dependancies to store the label I'm going to use the dependancy set of
labels and then remove the label after the constraint has been
replaced.

(2012-11-27-18:07)

I have done the constraints for SpecType to match what I mentioned in
the last entry and have just run the test database, and none of the
other equality type tests were affected, which is great. The only
thing left to do now is to go through the environment returned when
using a signature opaquely, find the equality type variables that are
highlighted in this way, and constrain them to be NOT_EQUALITY_TYPE,
with the endpoint label as the opaque signature (:>) expression label.

(2012-11-27-22:08)

The code needed to be written for this test to pass is finishedand the
test passes... but there is a problem. When using an opaque signature,
the types become non-equality... but then they can be part of equality
type errors between themselves and types which are later defined in
structures to have an EQUALITY_TYPE status e.g. type t = int!

This is very annoying. I have a solution to fix this which I'm working
on now, which is to make sure that there cannot be equality type error
clashes between signatures and structures. I can do this because this
should never be the case, if they differ in equality type status then
they will also differ at the type level so we'll generate an error for
that anyway.

(2012-11-27-23:25)

The solution I had didn't work because of complication involving the
'where' keyword, so I'm back to thinking about how to stop structures
and signatures clashing when used opaquely. Hmmm.

(2012-11-28-00:28)

Still no solutions on this, it doesn't seem I can do anything with the
environment variables to try and restrict the structure to only seeing
the unmodified constraints. I might need to do something with the
status assignments to set some kind of flag.

*** 2012-11-28

(2012-11-28-13:50)

I've thought about this and the only real solution to this should be
to edit the state mappings of the environment variables I think. For
this test (opaque-and-translucent-signatures, with first typable
section commented out), three environment variables are generated when
generating the opaque signature:

-------------------------------------
ev1 - comes from f_labstrexp:

{valueIds:8:[((8,TYPE_DEPENDANCY(TYPE_CONSTRUCTOR((n5,DECLARATION_CONS(4),l19),ROW_DEPENDANCY(ROW_CONSTRUCTION([],-,l20),[18,20],[],[]),l19,EQUALITY_TYPE_VAR(eqtv10)),[0,3,4,5,6,17,19,26,39,40,42,43,44,49,50,51,52,53,54],[],[]),eqtv21,PO
LY,51,VID(VAL)),[0,51],[], contextDependancies=8)]
 typeNames:7:[((7,(TYPE_FUNCTION_DEPENDANCY(TFC(ROW_DEPENDANCY(ROW_CONSTRUCTION([],-,l41),[39,41],[],[]),TYPE_DEPENDANCY(TYPE_CONSTRUCTOR((n5,DECLARATION_CONS(4),l19),ROW_DEPENDANCY(ROW_CONSTRUCTION([],-,l20),[18,20],[],[]),l19,EQUALITY_
TYPE_VAR(eqtv10)),[0,3,4,5,6,17,19,26,39,42,43,44],[],[]),l40),[40],[],[]),,TYPE,(,false)),eqtv12,POLY,40,TYCON),[0,40],[], contextDependancies=)]
 explicitTypeVars:
 structs:
 sigs:
 overloadingClasses:
 info:(0,true,[],false)}

Notable information is the equality type variable on the type
constructor, which is eqtv10, and mapped to NOT_EQUALITY_TYPE in
StateEQ. This makes sense, as in the structure, the type constructor
is set to a real with type t = real
-------------------------------------

-------------------------------------
ev2 - comes from f_labsigexp:

{valueIds:
 typeNames:7:[((7,(TYPE_FUNCTION_DEPENDANCY(TFC(ROW_DEPENDANCY(ROW_CONSTRUCTION([],-,l35),[33,35],[],[]),TYPE_DEPENDANCY(TYPE_CONSTRUCTOR((n18,DECLARATION_CONS(7),l34),ROW_DEPENDANCY(ROW_CONSTRUCTION([],-,l35),[33,35],[],[]),l34,EQUALITY
_TYPE_VAR(eqtv35)),[34],[],[]),l34),[34],[],[]),,TYPE,(,false)),eqtv33,POLY,34,TYCON),[0,32,34],[], contextDependancies=)]
 explicitTypeVars:
 structs:
 sigs:
 overloadingClasses:
 info:(0,true,[(7,34,TYPE,n18)],false)}

Notable information is that the equality type variable here is eqtv35,
mapped to EQUALITY_TYPE in the state environment. Also the labels on
the type constructor are only 32 and 34, which are the labels for
'type t' and for the 't' in type t.
-------------------------------------

-------------------------------------
ev3 - comes from f_strid:

{valueIds:
 typeNames:7:[((7,(TYPE_FUNCTION_DEPENDANCY(TFC(ROW_DEPENDANCY(ROW_CONSTRUCTION([],-,l35),[33,35],[],[]),TYPE_DEPENDANCY(TYPE_CONSTRUCTOR((n21,DECLARATION_CONS(7),l34),ROW_DEPENDANCY(ROW_CONSTRUCTION([],-,l35),[33,35],[],[]),l34,EQUALITY
_TYPE_VAR(eqtv35)),[34],[],[]),l34),[34],[],[]),,TYPE,(,false)),eqtv33,POLY,34,TYCON),[0,28,30,31,32,34],[], contextDependancies=)]
 explicitTypeVars:
 structs:
 sigs:
 overloadingClasses:
 info:(0,true,[(7,34,TYPE,n21)],false)}

Notable information is that this is the same as ev2, but with more
labels, namely 28, 30 and 31. 30 and 31 are labels for the signature
expression sig ... end and 28 is everything from S :> sig ... all the
way to what must be the end of the structure definition, which is
quite a distance. I'm not sure which one I want.
-------------------------------------

Perhaps editing these mappings rather the constraint (cst2) will
provide a way to generate this error without affecting the constraints
inside the structure. When solving an opaque structure we do not put
ev3 into the signature constraint, therefore constraints there I would
think would be invisible to the outside. The only place possible to
make the change then, is to the environment variable representing
f_labsigexp. The relationship between that and cst2 I do not yet know,
I expect cst2 contains all constraints from the signature which are
perhaps checked against the structure.

(2012-11-28-15:04)

No, that didn't work either. Turns out I am actually changing env2,
because env2 is derived from cst2, which is what I'm editing at the
moment anyway.

(2012-11-28-15:33)

I think I might have found something. In the constraint solving
process for signatures, there is a function called matchSigStr, which
I guess matches signatures up with their structures. If I could supply
another environment variable which was mapped to the new set of
constraints that I have built and passed that in to the process, I
could pass the old set of constraints to matchSigStr, and the new set
of constraints could be put into the map for the outside to know
about. Something like this might work.

(2012-11-28-15:36)

I just found six ref values which are toggled on and off during
constraint solving of signatures with a comment next to them 'What is
that?'. I expect these will cause issues. These probably should go
away...

(2012-11-28-15:46)

Perhaps I can use the sigVsStr ref toggles to my advantage by simply
suppressing equality type errors when it is enabled. Might work if the
refs aren't still set when solving structure constraints irrespective
of the signature.
