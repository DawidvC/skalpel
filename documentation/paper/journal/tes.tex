% -*-LaTeX-*-


%% TODO:
%% - Get rid of the section on the initially generated forms. - DONE.
%% - Add an environment component to the constraint solver and get rid
%% of diff.


\input{jbw-switch}


% my switches


\DeclareSwitch{jbw}
\IfFileExists{my-name-is-jbw.tex}
  {\jbwtrue}
  {\jbwfalse}

\DeclareSwitch{final}
\DeclareSwitch{incolor}  % true to have colors such as comments in color
\DeclareSwitch{comm}     % true to print display the comments
\DeclareSwitch{new}
\DeclareSwitch{nnew}
\DeclareSwitch{ieee}

\incolortrue
\commtrue
\finaltrue
\ifjbw
%  \appendixfalse
\fi
\newfalse
\nnewfalse
\ieeefalse


% If we want comments then notes have to be enable otherwise they have
% to be disable
\iffinal\commfalse\fi


%% DOCUMENT CLASS


\let\originalvec=\vec
\documentclass{jfp1}
\let\vec=\originalvec


% changes footnotesize
\makeatletter
\def\footnotesize{%
  \@setfontsize\footnotesize\@viiipt{9.5}%
  \abovedisplayskip 6\p@ \@plus2\p@ \@minus4\p@
  \abovedisplayshortskip \z@ \@plus\p@
  \belowdisplayshortskip 3\p@ \@plus\p@ \@minus2\p@
  \def\@listi{\leftmargin\leftmargini
    \topsep 3\p@ \@plus\p@ \@minus\p@
    \parsep 2\p@ \@plus\p@ \@minus\p@
    \itemsep \parsep}%
  \belowdisplayskip \abovedisplayskip
}%
\makeatother


%% PACKAGES


\usepackage{bsymb}
\usepackage{proof}
\usepackage{jbw-thm}
\usepackage{jbw-arrow}
\usepackage{ifthen}
\usepackage{url}
\usepackage{color}
\usepackage{pstricks,pst-node,pst-tree}
\usepackage{graphicx}
\usepackage{float}
\usepackage{changepage}
\usepackage{wrapfig}
\usepackage{amsmath}
\usepackage{subfig}
%\usepackage{multibbl}
%\usepackage{chapterbib}
%\usepackage{bibunits}
%\usepackage{url}
%\usepackage{longtable}
%\usepackage{rotating}
%\usepackage{hyperref}
%\usepackage{amsmath}
%\usepackage{pifont}
%\usepackage{rotating}


%% MARGIN


%% \ifconf
%% \else
%%   \newenvironment{changemargin}[2]{%
%%     \begin{list}{}{%
%%         \setlength{\topsep}{0pt}%
%%         \setlength{\leftmargin}{#1}%
%%         \setlength{\rightmargin}{#2}%
%%         \setlength{\listparindent}{\parindent}%
%%         \setlength{\itemindent}{\parindent}%
%%         \setlength{\parsep}{\parskip}%
%%       }%
%%     \item[]}{\end{list}}
%% \fi


%% FLOATINGS


%\makeatletter
%\renewcommand{\floatc@ruled}[2]{{\@fs@cfont #1.}\ \ #2\par}
%\makeatother

\floatstyle{ruled}
\restylefloat{figure}

\let\originalfigure=\figure
\newcommand{\myfigure}{figure}


% TABLE SIZES


%\newcommand{\sizetables}{normalsize}
\newcommand{\sizetables}{scriptsize}
%\newcommand{\sizetables}{footnotesize}
\newcommand{\sizeintablesp}{footnotesize}
\newcommand{\sizeintables}{small}
%\newcommand{\sizetables}{scriptsize}


% COLORS


\definecolor{mygray}{gray}{0.4}
\definecolor{fkgray}{gray}{0.2}

\ifincolor
  \definecolor{myred}{cmyk}{0, 0.7, 0.7, 0.0}
  \definecolor{myorange}{cmyk}{0, 0.5, 0.8, 0.0}
  \definecolor{myred2}{cmyk}{0, 0.9, 0.7, 0.1}
  \definecolor{myblue}{cmyk}{0.6, 0.4, 0, 0}
  \definecolor{mygreen}{cmyk}{0.6, 0, 0.6, 0.2}
  \definecolor{myplum}{cmyk}{0,0.56,0.14,0.29}
  \definecolor{inboxcol}{cmyk}{0,0,0,0}
  \definecolor{mycolempha}{cmyk}{0, 0.7, 0.7, 0.0}
  \definecolor{mycolemphb}{cmyk}{0.0, 0.56, 0.14, 0.29}
  \definecolor{mybluetext}{cmyk}{0.9, 0.6, 0.2, 0.2}
\else
  \definecolor{myred}{cmyk}{0, 0, 0, 0.2}
  \definecolor{myorange}{cmyk}{0, 0, 0, 0.28}
  \definecolor{myblue}{cmyk}{0, 0, 0, 0.4}
  \definecolor{mygreen}{cmyk}{0, 0, 0, 0.28}
  \definecolor{myplum}{cmyk}{0,0,0,0.5}
  \definecolor{inboxcol}{cmyk}{0,0,0,0}
  \definecolor{mycolempha}{cmyk}{0, 0, 0, 0.6}
  \definecolor{mycolemphb}{cmyk}{0, 0, 0, 0.4}
  \definecolor{mybluetext}{cmyk}{0, 0, 0, 0.4}
\fi



% TABLES


\newcommand{\syntaxtab}{tabular}
\newcommand{\typestab}{tabular}
\newcommand{\envtab}{tabular}
\newcommand{\typsystab}{tabular}
\newcommand{\unifalgotab}{tabular}
\newcommand{\enumtab}{tabular}
\newcommand{\typsysslicetab}{tabular}
\newcommand{\consgenslicetab}{tabular}
\newcommand{\consgentab}{tabular}
\newcommand{\slicertab}{tabular}
\newcommand{\syntslicetab}{tabular}

\setlength{\doublerulesep}{\arrayrulewidth}

\setlength{\tabcolsep}{1.0pt}
\setlength{\arraycolsep}{1.0pt}


% BIBLIOGRAPHY


%\bibliographystyle{alpha}
%\usepackage{jbw-bib-settings}
%\bibsettings{\tinybibsettings}
\bibliographystyle{jfp}



% MACROS


\input{macros}


\renewcommand{\tabular}{\oldtabular}


% NOTES


\input{notes}


% NAMES


\newcommand{\brael}{Bra{\ss}el}


% tricks


\let\originalsection=\section
\let\originalsubsection=\subsection
\let\originalsubsubsection=\subsection
\let\originalparagraph=\sectionparagraph
%% %% Removes spaces after a section title for example.
%% \iflncstricks
\makeatletter
  \ifieee
    %\def\section{\@startsection{section}{1}{\z@}{1\baselineskip plus 0.25\baselineskip minus 0.25\baselineskip}%
    %{1\baselineskip plus 0.25\baselineskip minus 0.25\baselineskip}{\normalfont\large\bfseries}}%
    \def\section{\@startsection{section}{1}{\z@}{-0.2\baselineskip plus -0.1\baselineskip minus -0.1\baselineskip}%
    {0.5\baselineskip plus 0.1\baselineskip minus 0.1\baselineskip}{\normalfont\large\bfseries}}%
    %\def\subsection{\@startsection{subsection}{2}{\z@}{1\baselineskip plus 0.25\baselineskip minus 0.25\baselineskip}%
    %{1\baselineskip plus 0.25\baselineskip minus 0.25\baselineskip}{\normalfont\sublargesize\bfseries}}%
    \def\subsection{\@startsection{subsection}{2}{\z@}{-0.2\baselineskip plus -0.1\baselineskip minus -0.1\baselineskip}%
    {-0.5em \@plus -0.22em \@minus -0.1em}{\normalfont\normalsize\bfseries}}%
    %\def\subsubsection{\@startsection{subsubsection}{3}{\z@}{1\baselineskip plus 0.25\baselineskip minus 0.25\baselineskip}%
    %{0ex}{\normalfont\normalsize\bfseries}}%
    \def\subsubsection{\@startsection{subsubsection}{3}{\z@}{-0.2\baselineskip plus -0.1\baselineskip minus -0.1\baselineskip}%
    {-0.5em \@plus -0.22em \@minus -0.1em}{\normalfont\normalsize\bfseries}}%
    %\def\paragraph{\@startsection{paragraph}{4}{2\parindent}{0ex plus 0.1ex minus 0.1ex}%
    %{0ex}{\normalfont\normalsize}}%
    \def\paragraph{\@startsection{paragraph}{4}{2\parindent}{-0.01ex plus -0.1ex minus -0.1ex}%
    {-0.5em \@plus -0.22em \@minus -0.1em}{\normalfont\normalsize\itshape}}%
  \else
     \renewcommand\section{\@startsection{section}{1}{\z@}%
                            %{-18\p@ \@plus -4\p@ \@minus -4\p@}%
                            {-9\p@ \@plus -2\p@ \@minus -2\p@}%
                            %{12\p@ \@plus 4\p@ \@minus 4\p@}%
                            {6\p@ \@plus 2\p@ \@minus 2\p@}%
                            {\normalfont\large\bfseries\boldmath
                             \rightskip=\z@ \@plus 8em\pretolerance=10000 }}
     \newcommand{\sectiontitledot}[1]{#1.}
     \renewcommand\subsection{\@startsection{subsection}{2}{\z@}%
                            %{-18\p@ \@plus -4\p@ \@minus -4\p@}%
                            {-6\p@ \@plus -1\p@ \@minus -1\p@}%
                            %{8\p@ \@plus 4\p@ \@minus 4\p@}%
                            {-0.5em \@plus -0.22em \@minus -0.1em}%
                            {\normalfont\normalsize\bfseries\boldmath
                             \rightskip=\z@ \@plus 8em\pretolerance=10000\sectiontitledot}}
     \renewcommand\subsubsection{\@startsection{subsubsection}{3}{\z@}%
                            %{-18\p@ \@plus -4\p@ \@minus -4\p@}%
                            {-6\p@ \@plus -1\p@ \@minus -1\p@}%
                            {-0.5em \@plus -0.22em \@minus -0.1em}%
                            {\normalfont\normalsize\bfseries\boldmath\sectiontitledot}}
     \renewcommand\paragraph{\@startsection{paragraph}{4}{\z@}%
                            {-12\p@ \@plus -4\p@ \@minus -4\p@}%
                            {-0.5em \@plus -0.22em \@minus -0.1em}%
                            {\normalfont\normalsize\itshape}}
     \setlength\textfloatsep%{8mm\@plus 2\p@ \@minus 4\p@}
                             {4mm\@plus 1\p@ \@minus 2\p@}
     \setlength\floatsep    %{12\p@ \@plus 2\p@ \@minus 2\p@}
                             {6\p@ \@plus 1\p@ \@minus 1\p@}
  \fi
\makeatother

% jbw: commented lines are defaults from 10pt in class file, we switch
% them for defaults for 9pt in class file:
%
%\abovedisplayskip 1.5ex plus4pt minus2pt%
\abovedisplayskip 0.7ex plus1.5pt minus0.5pt%
%
\belowdisplayskip \abovedisplayskip%
%
%\abovedisplayshortskip 0pt plus4pt%
\abovedisplayshortskip 0pt plus0.5pt%
%
%\belowdisplayshortskip 1.5ex plus4pt minus2pt
\belowdisplayshortskip 0.7ex plus1.5pt minus0.5pt

% jbw: commented lines are from class file:
%
%\floatsep 1\baselineskip plus  0.2\baselineskip minus  0.2\baselineskip
\floatsep 0.5\baselineskip plus  0.1\baselineskip minus  0.1\baselineskip
%
%\textfloatsep 1.7\baselineskip plus  0.2\baselineskip minus  0.4\baselineskip
\textfloatsep 0.9\baselineskip plus  0.1\baselineskip minus  0.2\baselineskip
%
%\dblfloatsep 1\baselineskip plus  0.2\baselineskip minus  0.2\baselineskip
\dblfloatsep 0.5\baselineskip plus  0.1\baselineskip minus  0.1\baselineskip
%
%\dbltextfloatsep 1.7\baselineskip plus  0.2\baselineskip minus  0.4\baselineskip
\dbltextfloatsep 0.9\baselineskip plus  0.1\baselineskip minus  0.2\baselineskip

\makeatletter
  %\def\@IEEEauthorblockconfadjspace{0.75\@IEEEnormalsizeunitybaselineskip}
  \def\@IEEEauthorblockconfadjspace{0\@IEEEnormalsizeunitybaselineskip}
\makeatother

%% \fi


\begin{document}


\title{A constraint system for a type error slicer}
\author{Vincent Rahli and J.\ B.\ Wells and Fairouz Kamareddine}
\date{\today}
%\institute{ULTRA group, Heriot-Watt University, \url{http://www.macs.hw.ac.uk/ultra/}}
\maketitle



\begin{abstract}
 Existing compilers for many languages have confusing type error
 messages.
 %%
 \emph{Type error slicing} (TES) helps the programmer by
 isolating the part of a program contributing to a type error, but
 %%%
 %(1)~It identifies all program points that contribute to a type error
 %rather than blaming just one point.
 %%%
 %(2)~It exhibits a slice of the original program's syntax instead of
 %showing an internal representation of some program subtree which may
 %have been substantially transformed.
 %%%
 %(3)~It avoids showing internal details of inferred types which were
 %not written by the programmer.
 %%
 unfortunately TES was initially done for a tiny toy language.
 %%
 Extending TES to a full programming language is extremely
 challenging, and for SML we needed a number of innovations and
 generalisations.
 %%
 Some issues would be faced for any language, and some are
 SML-specific but representative of the complexity of
 language-specific issues likely to be faced for other languages.
 %%
 We solve both kinds of issues and present a simple, general
 constraint system for providing type error slices for ill-typed
 programs.
 %%
 \newtext{Our constraint system elegantly and efficiently handles
   features like the intricate \emph{open} SML feature.}
 %%
 %written in
 %typed functional languages like SML.
 %%
 We show how the simple clarity of type error slices can
 demystify language features known to confuse users.
 %

%%  We also provide in an appendix case studies on how to use our TES to,
%%  e.g., help modifying user data types.  We also extend the core
%%  language presented in the main body of this document to handle more
%%  of the implementation of our system.  These extensions allow
%%  handling, amongst others things, local declarations, type
%%  declarations, some uses of signatures, functors, and type
%%  annotations.
%% % (these features and many more are handled by our implementation).
\end{abstract}


%\tableofcontents


\section{Introduction}

\subsection{Background of type error slicing}


%As explained in Sec.~\ref{sec:mlprogs},
\SML\ is a higher-order
function-oriented imperative programming language and Milner's
\walgo\ algorithm~\cite{Damas+Milner:1982} is the original
type-checking algorithm of the functional core of \ML.
%
\walgo\ implementations generally locate errors
at or near the syntax tree node being visited when
unification fails, and this is unsatisfactory.



\mynote{2009-07-14}{Maybe we can move the next paragraph in the
  related work section.}

\mynote{2009-07-14}{We could replace the three next paragraphs by:
  Since then many algorithms have been developed, intending sometimes
  to give better locations for errors.  \malgo~\cite{Lee+Yi:1998},
  \walgop~\cite{McAdam:1999} or \uaealgo~\cite{Yang:2000} are such
  algorithms.  However, all these algorithms suffer from the same
  problem: they blame only one node for the failure of type inference
  when a set of nodes should be blamed.  Most of the implementations
  of these algorithms are biased too in the sense that they report
  only one error location (the failing node) often merely depending on
  the traversal of the abstract syntax trees.  This is now well known
  to lead to poor error reports that are often confusing because the
  unique error location identified by these implementations is
  generally not enough to understand the error.  Moreover...}

\hidden{More precisely, Lee and Yi~\cite{Lee+Yi:1998} report that \walgo\
``fails only at an application expression where its two subexpressions
(function and argument) have conflicting types''.}
%
%
%


\subsubsection{Moving the error spot}
%
Following \walgo, other algorithms
% have been developed that
try
to get better locations by arranging that untypability will be
discovered when visiting a different syntax tree node.
%
%% For example, the folklore algorithm \malgo~\cite{Lee+Yi:1998}
%% differs from \walgo\ primarily by taking as input partial
%% information on the
%% % result
%% type of the analysed expression.\mynote{old}{Lee and
%%   Yi claim that \malgo\ is a ``top-down'' algorithm, and that
%%   \walgo\ is a ``bottom-up'' algorithm.}
% Both \walgo\ and \malgo\ are proved sound and complete.
For example, Lee and Yi proved the folklore algorithm
\malgo~\cite{Lee+Yi:1998} finds errors ``earlier'' (this measure is
based on the number of recursive calls of the algorithm) than
\walgo\ and claimed that their combination ``can generate strictly
more informative type-error messages than either of the two algorithms
alone can''.  Similar claims are made for
%Other \walgo\ variants are
\walgop~\cite{McAdam:1999} and \uaealgo~\cite{Yang:2000}.  McAdam
observes that \walgo\ suffers a left-to-right bias and tries to
eliminate it by replacing the unification algorithm used in the
application case of \walgo\ by another operation called ``unification
of substitutions''.
%
%\hidden{
McAdam explains that the left-to-right bias in \walgo\ arises because
in the case of applications, ``the substitution from a left-hand
subexpression is applied to the type-environment before traversing the
right-hand side expression''~\cite{McAdam:1999}.  His ``unification of
solutions'' allows one ``to infer types and substitutions for each
subexpression independently''~\cite{McAdam:1999}.  ``Unification
of substitutions'' is then used to combine the inferred
substitutions.
%}
%
Yang claims that \uaealgo's primary advantage is that it also
eliminates this bias.
%
%% Yang claims that \uaealgo\ also eliminates this left-to-right
%% bias.
%
However, all the algorithms mentioned above retain a left-to-right bias in
handling of let-bindings and they all blame only one syntax tree node
for each type error when in fact a node set is at fault.

When only one node is reported as the error site, it is often far away
from the actual programming error.  The situation is made worse
because the blamed node depends on internal implementation details,
i.e., the tree node traversal order and which constraints are
accumulated and solved at different times in the traversal.  The
confusion is worsened because these algorithms usually exhibit in
error messages (1) an internal representation of the program subtree
at the blamed location which often has been transformed substantially
from what the programmer wrote, and (2) inferred type details which
were not written by the programmer and which are anyway erroneous and
confusing.

\subsubsection{Other improved error reporting systems}
%
Constraint-based type inference
algorithms~\cite{Odersky+Sulzmann+Wehr:1999,Pottier:2005,Pottier+Remy:2005}
separate \emph{constraint generation} and \emph{constraint solving}.
% the
%generation of type constraints for a given term and their unification.
%% of the generated constraints.
Many works use this idea to improve error reporting.  A probably
incomplete list
includes~\cite{Haack+Wells:2003,Haack+Wells:2004,Gast:2004,Heeren+Jeuring+Swierstra+Alcocer:2002,Heeren+Hage+Swierstra:2003a,Hage+Heeren:2005a,Heeren:2005,Hage+Heeren:2009,Stuckey+Sulzmann+Wazny:2003,Stuckey+Sulzmann+Wazny:2004,Stuckey+Sulzmann+Wazny:2006}.
%
Independently from this separation, there exist
% ways to improve
% error reporting.  As explained by Yang et
% al.~\cite{Yang+Wells+Trinder+Michaelson:2000}, there exist
other approaches toward improving
errors~\cite{Yang+Wells+Trinder+Michaelson:2000}: error explanation
systems~\cite{Beaven+Stansifer:1993,Duggan+Bent:1996,Duggan:1998,Yang+Michaelson+Trinder:2002}
which focus on explaining the reasoning steps leading to a type error,
and error reporting systems~\cite{Wand:1986,Tip+Dinesh:2001} which
focus on trying to precisely locate errors in pieces of code.
%
%% \ifvv
%% The type error reporting systems can then be divided further into
%% subgroups.
%% \fi
%
There are also approaches that report type errors together with
suggestions for changes that would solve the
errors~\cite{Hage+Heeren:2006,Chambers+Grossman+Flower+Lerner:2007}.
%
Some of these approaches are discussed in
Ch.~\ref{sec:allrelatedwork}.


\subsection{Type error slicing}


Haack and Wells~\cite{Haack+Wells:2004} developed a type error
reporting method called \emph{type error slicing} (\TES).
%
Haack and Wells~\cite{Haack+Wells:2004} noted that ``\emph{Identifying
  only one node or subtree of the program as the error location makes
  it difficult for programmers to understand type errors. To choose
  the correct place to fix a type error, the programmer must find all
  of the other program points that participate in the error.}''  They
locate type errors at \emph{program slices} which include all parts of
an untypable piece of code where changes can be made to fix the error
and exclude the parts where changes cannot fix the error.

We shall refer to the method of Haack and Wells as \HWTES\ in this
document (the slicer of Haack and Wells as presented in their
papers~\cite{Haack+Wells:2003,Haack+Wells:2004} and not its
implementation).  \HWTES\ generates a constraint set for a program,
enumerates minimal unsatisfiable subsets of the constraint set, and
computes type error slices.  Generation and solving of constraints are
not interleaved.  To identify slices responsible for type errors, each
constraint is labelled by the location responsible for its generation.
Error slices are portions of a program where all blameless subterms
are elided (e.g., replaced by dots).  Slices can be shown by
highlighting the source code.

\HWTES\ makes use of intersection types and its handling of
polymorphism involves heavy constraint and type environment
duplications which leads to a combinatorial constraint size explosion
at constraint generation.

\HWTES\ meets the following seven criteria of
Yang et al.~\cite{Yang+Wells+Trinder+Michaelson:2000} for good type
error reports:
%
it reports only errors for ill-typed code (\emph{correct}),
%
it reports no more than the conflicting portions of code
(\emph{precise}),
%
it reports short messages (\emph{succinct}),
%
it does not report internal information such as internal types
generated during type inference (\emph{a-mechanical}),
%
it reports only code written by the programmer
which has not been transformed as happens with existing
\SML\ implementations (\emph{source-based}),
%
it does not privilege any location over the others (\emph{unbiased}),
%
and it reports all the conflicting portions of code
(\emph{comprehensive}).


\subsection{Contributions}


Unfortunately, \HWTES\ is not practical on real programs and works
only for a tiny \SML\ subset barely larger than the
$\lambda$-calculus.  Our goal is a \TES\ method that (1)~covers full
\SML, (2)~is practical on real programs, and (3)~has a simple and
general design.  As would happen for any programming language, we
faced challenges.

An initial challenge was avoiding a combinatorial constraint size
explosion.
%
The naive approach in \HWTES\ duplicated constraints for code that
gets a polymorphic type (e.g., in \SML's let-expressions), and thus is
unusable beyond small examples.
%
Instead, at constraint solving we simplify constraints before copying
them, and copy them as late as possible.  We retain compositional
initial generation of constraints, but unlike in \HWTES\ we solve
constraints in a strict left-to-right order.  Our solution is related
in part to earlier constraint systems for \ML-style
let-bindings~\cite{Pottier:2005,Pottier+Remy:2005,Muller:1994,Gustavsson+Svenningsson:2001,Odersky+Sulzmann+Wehr:1999},
which Pottier explains ``allow building a constraint of linear
size''~\cite{Pottier:2005}.
%
Unfortunately, the earlier ideas are inadequate for module systems, so
we needed a new constraint representation.


The next challenge was to scale constraint generation while also
handling advanced module system features.  Like many languages, \SML\
can manipulate namespaces, e.g., with structures (modules), signatures
(module types), functors (functions from modules to modules), etc.  We
achieve this with our novel hybrid \emph{constraint/environments}
(metavariable $\METAcsenv$ in Fig.~\ref{fig:syntaxOpen} in
Sec.~\ref{sec:syntax}).  They are constraints because they are
satisfiable (or not) depending on variable values, and environments
because they bind program names to information.
%
Some bindings are \emph{polymorphic} to support some the
kinds of polymorphism in \SML: polymorphic functions, datatype
constructors, named structure signatures, and functors.
%% Furthermore, these
%% bindings are \emph{polymorphic}, and support all the kinds of
%% polymorphism in \SML: polymorphic functions, datatype constructors,
%% type functions/abbreviations (e.g., \inexamplebody{type 'a pair = ('a
%%   * 'a)}), named structure signatures, and functors.


%% %
%% \hidden{We faced significant challenges in making a fast and compatible
%% minimisation algorithm for let-like-constraints.
%% \mynote{(2010-04-26)}{We don't present these challenges.}}
%% %
%% %% The fact that we have to solve the constraints associated to the
%% %% left-hand-side of a let-binding before any other constraints
%% %% interferes with a naive approach for a minimisation algorithm that
%% %% consists of starting from a type error and building a unifier
%% %% containing the type information about the locations that
%% %% %
%% %% \textit{have to be}
%% %% %
%% %% in the currently built minimal error.  These locations cannot be
%% %% picked as the last locations treated before the failure of the
%% %% unification algorithm.
%% %
%% % However, a unifier cannot be reused from one computation to another
%% % during the minimisation process because...
%% %
%% %%We designed a new minimisation algorithm that uses another approach.
%% \ifvv
%% Roughly speaking, in a piece of code, it usually turns out that not all the
%% declarations are involved in a type error.  Thus, our minimisation
%% algorithm tries to unbind declarations through the code to test
%% if they have to be part of the error currently being minimised.
%% \fi
%% %
%% \mynote{2009-07-15}{What seems to be the main difference between their
%%   unification and ours is that we duplicate types when they duplicate
%%   constraints.  However it seems that the earlier work by
%%   R\'emy~\cite{Remy:1992} duplicates only types even though it is does
%%   not use constraints.  R\'emy solves the problem of a free variable
%%   with a ``large'' monomorphic type using ranks.  Basically, what he
%%   seems to say is that my way of computing these variables can be
%%   inefficient.}%
%% %

%compositional analysis.%
%One of the major differences with Haack and Wells' method is that ours
%is based on the use of type schemes rather that on the use of
%``intersection-like'' types.  As explained below, type schemes were
%required to solve scalability issues.  When adopting a type scheme
%based method we lost the compositionality of our approach but more
%importantly gained its scalability on real size programs.

%% \mynote{(2010-05-07)}{
%% Another challenge was to provide reasonable slices for each
%% and every untypable \SML\ syntactic form.
%% %
%% Unexpectedly, we faced many special cases which needed special care.
%% % to be handled correctly by our slicer.
%% %
%% Some of these cases are specific to \SML\ such as:
%% functions defined with the \inexamplebody{fun} feature,
%% %records,
%% value polymorphism, binding of explicit type variables, etc.
%% %
%% Some of them are generic such as:
%% %
%% representing if it is important for a piece of code to be a direct
%% subtree of its context (which we do when carefully highlighting
%% white spaces),
%% %
%% indicating when a syntax tree node which contributes no symbols is part of
%% an error (e.g., for function application we highlight the space and
%% put a box around the argument), etc.
%% %
%% \hidden{ handling of white spaces so that one
%% knows immediately if it is important for a piece of code to be a
%% direct subtree of its context, handling of arguments so that one knows
%% if it is important for an argument to occupy a certain position or
%% to be present at all, etc.}
%% %
%% For each of these cases we had to modify or introduce new ground rules
%% for our \TES\ to generate useful slices and at the same time
%% stay as general as possible for later reuse for other languages.
%% %
%% \hidden{Some of these cases are illustrated in the next section.}
%% %
%% \mynote{(2010-04-26)}{We don't discuss the previous paragraph in the
%%   paper anymore.  We could maybe get rid of this paragraph and only
%%   mention this contribution in the contribution section at the end of
%%   the paper.}
%% }

The remaining challenges were using the novel constraint machinery for
a full programming language, with all its features and warts.
Sec.~\ref{sec:technicalities} presents full details for a core of
language features large enough to show the essence of the mechanism.
This core includes polymorphic functions, datatypes and pattern
matching, and structures (including the difficult \inexamplebody{open}
operation).
%
We call this core system,
%
\index{TES@\TES!Core-TES@\CORETES}%
%
\emph{\CORETES}.
%
%
We have achieved a larger formalisation which we refer to as
%
\index{TES@\TES!Form-TES@\FORMTES}%
%
\emph{\FORMTES}~\cite{Rahli:2011}.
%
\FORMTES\ aims towards
%
\index{TES@\TES!Full-TES@\FULLTES}%
%
\emph{\FULLTES}, which is the \TES we are aiming at to handle full
\SML\ but which we have not yet achieved.
%
%% The larger set of features/warts we present includes \SML's
%% value/constructor identifier-status ambiguity, local declarations,
%% type functions/abbreviations, structure signatures, functors, type
%% annotations, and the value polymorphism restriction.
%
%% We generally refer to this formalised \TES\ as
%
%
Even though the implementation of our \TES\ covers nearly full \SML,
it is not quite \FULLTES.  Some \TES\ features have not yet been
implemented and some \SML\ features are not yet supported.
%
We generally refer to the implementation of our \TES\ as
%
\index{TES@\TES!Impl-TES@\IMPLTES}%
%
\emph{\IMPLTES}.
%
\IMPLTES\ is usable via a web demo and installable packages~\cite{TypeErrorSlicingProject:2010}.
%% at
%% \begin{footnotesize}\url{http://www.macs.hw.ac.uk/ultra/compositional-analysis/type-error-slicing}\end{footnotesize}.
%
Note that neither \IMPLTES\ is a superset of \FORMTES\ and nor is
\FORMTES\ a superset of \IMPLTES\ because \IMPLTES\ supports some
features that are not supported by \FORMTES\ (e.g., many cases of
records or the \inexamplebody{fun} \SML\ forms to write recursive
functions) and vice versa (e.g., \FORMTES\ has a better support for
functors).  We plan to have both \FORMTES\ and \IMPLTES\ converge with
\FULLTES\ in the future.
%
We will often write \emph{our \TES} to encompass both \FORMTES\ and
\IMPLTES.

The most challenging feature for full \SML\ was the \inexamplebody{open}
declaration, which splices another structure into the current
environment (example in Sec.~\ref{sec:openerrorexample}), and has been
criticized in the
literature~\cite{Appel:1993,Blume:1997,Blume:1999,Harper:2009}.
Harper writes~\cite{Harper:2009}:
% Another problem with open is that
``\emph{it is hard to control its behaviour, since
  it incorporates the entire body of a structure, and hence may
  inadvertently shadow identifiers that happen to be also used in the
  structure}''.
%
Blume~\cite{Blume:1997} shows that certain automatic dependency analyses
become NP-complete in the presence of \inexamplebody{open}, and writes:
% in Sec.~7.2 of his thesis:
``\emph{Programs are not only read by analysis tools; human read them
  as well.  A language construct like open that serves to confuse the
  analysis tool is also likely to confuse the human reader}''.
%
We believe \inexamplebody{open} is one of the most difficult programming language
features to analyze, but our constraint/environments make it easy and
simple, and we believe this highlights the generality of our
machinery.
Our \TES\ clarifies otherwise obscure type errors involving \inexamplebody{open}
and enhances its usability.

%% To the best of our knowledge, our constraint system is more
%% expressive than and goes well beyond the constraint systems
%% developed to help reporting type errors.

%% We also improve the notions of highlighted pieces of code and slices
%% so that, for example, a programmer immediately knows if it is
%% important for a piece of code to be a direct subtree of its context.
%% In the code written by the programmer, our solution is to provide a
%% meaningful highlighting of white spaces.

%% Other challenges include handling \SML\ features (e.g., value
%% polymorphism or the implicit binding of explicit type variables) in
%% order that type error slices involving these features contain enough
%% information to be understandable.


\hidden{
Another challenge is \SML's value identifier statuses.
In \SML, a value identifier can be a value variable (the only
status considered by Haack and Wells), a datatype constructor,
or an exception constructor (omitted in this paper's formalism).
%
For example, if identifier \inexamplebody{c}
has value variable status in the context, \inexamplebody{fn c => (c 1, c())}
has a unique minimal error
which is that \inexamplebody{c} has a monomorphic type
but is applied to two expressions with different types: \inexamplebody{int} and
\inexamplebody{unit}.
%
However, this error would not exist if the code was preceded by, e.g.,
\inexamplebody{datatype t = c} because the
fn-binding would not bind \inexamplebody{c},
%
but instead there would be a minimal error that
\inexamplebody{c} is declared as a nullary datatype constructor
and is applied to an argument in \inexamplebody{c 1}.
%%
%%
To compute correct type error slices, we annotate constraints by
context dependencies on identifier statuses.  For the
\inexamplebody{fn}-binding presented above we generate at constraint
solving, constraints relating the
% different
occurrences of \inexamplebody{c}
annotated by the dependency that \inexamplebody{c} is a value variable
and not a datatype constructor.  These
constraints are not generated if a context confirms that
\inexamplebody{c} must be a datatype constructor.
The constraints but not the context dependency are generated if a
context confirms that \inexamplebody{c} cannot be a datatype
constructor.
\hidden{ (i.e., if \inexamplebody{c} is
bound by a recursive declaration which, as defined in
\DStML~\cite{Milner+Tofte+Harper+Macqueen:1997}, can overwrite
the status of an identifier).}
%
When handling incomplete programs,
we report conditional errors (warnings) that assume
a sensible default truth status for the dependencies.
\hidden{that unbound identifiers are considered to be value variables and
%% unbound identifiers???
not datatype constructors.}
%
\hidden{  We do not  report errors assuming that
these identifiers are datatype constructors because
most of the time these identifiers are value variables and we would
cause a great increase in unhelpful reported slices.}
%% Doing otherwise would cause a great increase in unhelpful reported
%% slices.
}

%% Later sections detail solving these and other challenges.

%% \nnewtext{Other challenges are described in an appendix, such as designing a
%% compositional initial constraint generation algorithm while dealing
%% with \SML's ambiguity on identifiers' statuses, or handling features
%% such as type definitions, signatures, functors, type annotations or
%% the value polymorphism restriction.}

%% TODO: say that this is in appendix.
%% mention the other features handled in appendix, such as the
%% functors for which we had to reintroduce intersection types but
%% used differently than Haack and Wells.


%%% \newtext{This paper is self-contained but assumes some knowledge on \ML\
%%% programming languages and on constraint based type inference algorithm
%%% from the reader.}
%


%Our contributions are summarised in Sec.~\ref{sec:contributions}




%% In addition to overcoming challenges like those above, we also use
%% slicing for all
%% % extend the method to cover
%% context-sensitive syntax errors.
%% This
%% % extension
%% comes naturally from handling identifier statuses and
%% % from a
%% doing context-independent type checking.
%% For example,
%% % if a piece of code is studied out of its context then an
%% %identifier can generate a syntax error depending on its status if it occurs twice
%% %in a pattern.  In
%% in \inexamplebody{fn (x, x) => x},
%% \inexamplebody{x} occurring twice in the pattern is an error only if
%% \inexamplebody{x} is a value variable but not if \inexamplebody{x}
%% is a datatype constructor.
%% %  Reporting an error assuming the status of
%% %\inexamplebody{x} to be value variable would be conflicting with a
%% %context-independent analyse.


%% \ifvv
%% Moreover, our approach is fully compositional: the slicing operation
%% can be operated on a piece of code containing free variables and
%% context dependencies always have the potential to be discarded.
%% \fi




%% \intitle{Outline of the paper.}
%% %
%% In Sec.~\ref{sec:mathdefs} we present some mathematical notations
%% used throughout the paper.
%% %
%% In Sec.~\ref{sec:syntax} we introduce the fragment of \SML\ on which
%% the subset of our type error slicer presented in this paper is
%% defined.
%% %
%% In Sec.~\ref{sec:constraintsystem} we define our constraint
%% system.
%% %
%% In
%% Sec.s~\ref{sec:constraintgen},~\ref{sec:unification},~\ref{sec:minimisation},~\ref{sec:enumeration}
%% and~\ref{sec:slicing}
%% we present the different modules of our type error slicer: constraint
%% generation, unification, minimisation, enumeration and slicing
%% algorithms.
%% From a piece of code, first constraints are generated.  Then the
%% enumeration enumerates all the type errors of the enumerated
%% constraint set.  When an error is enumerated, the enumeration
%% algorithm minimises it using the minimisation algorithm.  Both, the
%% enumeration and minimisation algorithms make use of the unification
%% algorithm.
%% Finally, slices are obtained from the enumerated errors and the
%% original piece of code using the slicing algorithm.
%% %
%% In Sec.~\ref{sec:minimality}
%% we discuss the minimality of our approach.
%% %
%% In Sec.~\ref{sec:examples} we provide some concrete examples of
%% type error reports using our slicing method.
%% %
%% In Sec.~\ref{sec:implementation} we discuss some implementation
%% issues of our type error slicer.  Our slicer is implemented for a much
%% larger fragment of \SML\ than the one presented in this paper.
%% %
%% We present the related work in Sec.~\ref{sec:relatedwork} and
%% conclude in Sec.~\ref{sec:conclusion}.


%% \ifvv
%% To guide the design
%% of our constraint generator,
%% we have developed an alternate type system for \SML\ in which polymorphism is not expressed using the
%% ``for all'' ($\forall$) quantifier as it is usually done in the
%% literature~\cite{Milner+Tofte+Harper:1990,Milner+Tofte+Harper+Macqueen:1997,Girad+Taylor+Lafont:1989}.
%% Instead, the way we deal with polymorphism is inspired by intersection
%% types~\cite{Coppo+Dezani:1978}.
%% Because the type error slicer does not need the type system (it is
%% only used in guiding its design), we do not present it except in our
%% technical report.
%% \personal{  There are many advantages for
%% intersection types such as: type inference is decidable for many
%% powerful type systems, in some systems the principal typing property
%% can be recovered~\cite{Wells:2002}, and type inference in the presence
%% of polymorphic recursion can be decidable~\cite{Damiani:2007}.}
%% \fi




\subsection{Key motivating examples}
\label{sec:examples}


\input{included/examplesOpen}



%% \section{Mathematical definitions and notations}
%% \label{sec:mathdefs}


%% \ifthesis
%% Let $i, j, n, m$ be
%% metavariables ranging over $\SETnat$, the set of natural numbers.
%% \fi
%% %
%% If a metavariable $v$ ranges over a class $\METAclass$, then the
%% metavariables $v_{x}$ (where $x$ can be anything) and the
%% metavariables $v', v''$, etc., also range over
%% $\METAclass$.
%% %
%% Let $\METAset$ range over sets.  If $v$ ranges over $\METAset$,
%% then let $\METAtoset{v}$ range over $\MEMpowset{s}$,
%% the power set of $s$.
%% %Let $\MEMsize{s}$ be the cardinality of a set $s$.
%% %
%% Let $\MEMdisj{s_1,\dots,s_n}$ (``disjoint'') hold iff for all
%% $i,j\in\{1,\dots,n\}$, if $i\not=j$ then $s_i\cap{s_j}=\emptyset$.
%% %
%% Let $s_1\dunion{s_2}$ be $s_1\cup{s_2}$ if $\MEMdisj{s_1,s_2}$ and
%% undefined otherwise.
%% %
%% Let $\mypair{x}{y}$ be the pair of $x$ and $y$.
%% %Let $\METArel$ range over binary relations (pair sets).
%% If $\METArel$ is a binary relation (a pair set), let
%% $\MEMdom{\METArel}=\{x\mid\mypair{x}{y}\in\METArel\}$, let
%% $\MEMran{\METArel}=\{y\mid\mypair{x}{y}\in\METArel\}$, and
%% %
%% %% Let
%% %% %$\MEMrestrictin{\METArel}{s}=\{\mypair{x}{y}\in\METArel\mid{x}\in{s}\}$,
%% let $\MEMrestrictout{\METArel}{s}=\{\mypair{x}{y}\in\METArel\mid{x}\not\in{s}\}$.
%% %
%% Let $\METAfun$ range over functions (a special case of binary relations),
%% let $\func{s}{s'}=
%% \{\METAfun\mid\MEMdom{\METAfun}\subseteq{s}\wedge\MEMran{\METAfun}\subseteq{s}'\}$,
%% %% let $\funci{s}{s'}$ be $\func{s}{s'}$ restricted to
%% %% injective functions,
%% and let $\asgn{x}{y}$ be
%% an alternative notation for $\mypair{x}{y}$ used when
%% writing some functions.
%% %
%% %$\MEMuplus{\METAfun_1}{\METAfun_2}=\METAfun_2\cup(\MEMrestrictout{\METAfun_1}{\MEMdom{\METAfun_2}})$
%% %% Let
%% %% $\MEMfdunion{\METAfun_1}{\METAfun_2}=\METAfun_1\cup\METAfun_2$
%% %% if $\MEMdisj{\MEMdom{\METAfun_1},\MEMdom{\METAfun_2}}$
%% %% and undefined otherwise.
%% %
%% A tuple $\METAtup$ is a function such that $\MEMdom{\METAtup} \subset
%% \SETnat$ and if $1 \leq k \in \MEMdom{\METAtup}$ then $k - 1
%% \in \MEMdom{\METAtup}$.
%% Let $\METAtup$ range over tuples.
%% If $v$ ranges over $s$, then let $\METAtoseq{v}$ range
%% over $\MEMfintuple{s}=\{\METAtup\mid\MEMran{\METAtup}\subseteq{s}\}$.
%% We write
%% the tuple
%% $\{\asgn{0}{x_0},\dots,\asgn{n}{x_n}\}$ as
%% $\mytuple{x_0,\dots,x_n}$.
%% %% We say that
%% %% $\mytuple{x_1,\dots,x_n}$ is a
%% %% % finite
%% %% tuple of length $n$.
%% Let $@$ append tuples:
%% \(
%%     \mytuple{x_1,\dots,x_i}@\mytuple{y_1,\dots,y_j}
%%   = \mytuple{x_1,\dots,x_i,y_1,\dots,y_j}
%% \).
%% %% $\mytuple{x_1, \dots, x_n}$ and
%% %% $\mytuple{y_1,\dots,y_m}$
%% %  Given a set $s$, let $\MEMfintuple{s} =
%% % \{\METAtup \mid \MEMran{\METAtup} \subseteq s\}$.
%% %Given a set $s$, let
%% %$\MEMfintuple{s}=\{\METAtup\mid\MEMran{\METAtup}\subseteq{s}\}$.
%% % \wedge \METAtup \mbox{ is a
%% %   finite tuple }\}$.
%% %% We use $\mytuple{}$ for
%% %% the empty tuple, i.e., $\mytuple{}$ is an alternative notation for
%% %% $\emptyset$ used when writing tuples.
%% %% We sometimes write $x\in\METAtoseq{v}$ for $x\in\MEMran{\METAtoseq{v}}$.
%% %
%% %% Given $n$ sets $s_1, \dots,
%% %% s_n$, let $s_1 \cprod \cdots \cprod s_n$ stand for
%% %% the set of all the tuples $\mytuple{x_1, \dots, x_n}$
%% %% such that $x_i \in s_i$ for all $i \in \{1,
%% %% \dots, n\}$.






\section{Mathematical definitions and notations}
\label{sec:mathdefs}


%\smallintitle{Natural numbers}
%
Let $i, j, m, n, p, q$ be
metavariables ranging over $\SETnat$, the set of natural numbers.
%
%
%\smallintitle{Metavariables}
%
If a metavariable $v$ ranges over a class $\METAclass$, then the
metavariables $v_{x}$ (where $x$ can be anything) and the
metavariables $v', v''$, etc., also range over $\METAclass$.
%
%
%\smallintitle{Sets}
%
Let $\METAset$ range over sets.  If $v$ ranges over $\METAset$, then
let $\METAtoset{v}$ range over $\MEMpowset{\METAset}$, the power set
of $\METAset$.
%Let $\MEMsize{\METAs}$ be the cardinality of a set $\METAs$.
%
%
%
%\smallintitle{Disjunction}
%
Let $\MEMdisj{s_1,\dots,s_n}$ (``disjoint'') hold iff for all
$i,j\in\{1,\dots,n\}$, if $i\not=j$ then $s_i\cap{s_j}=\emptyset$.
%
Let $s_1\dunion{s_2}$ be $s_1\cup{s_2}$ if $\MEMdisj{s_1,s_2}$ and
undefined otherwise.
%
%
%\smallintitle{Relations}
%
Let $\mypair{x}{y}$ be the pair of $x$ and $y$.
%
If $\METArel$ is a binary relation (a pair set),
%
let $(\MEMbrel{x}{\METArel}{y})$ iff $\mypair{x}{y}\in\METArel$,
%
let the inverse of $\METArel$ be
$\MEMinverse{\METArel}$ defined as
$\{\mypair{x}{y}\mid\mypair{y}{x}\in\METArel\}$,
let $\MEMdom{\METArel}=\{x\mid\mypair{x}{y}\in\METArel\}$,
let $\MEMran{\METArel}=\{y\mid\mypair{x}{y}\in\METArel\}$,
%
let
$\MEMrestrictin{\METArel}{s}=\{\mypair{x}{y}\in\METArel\mid{x}\in{s}\}$,
and let
$\MEMrestrictout{\METArel}{s}=\{\mypair{x}{y}\in\METArel\mid{x}\not\in{s}\}$.
%
%
%\smallintitle{Functions}
%
Let $\METAfun$ range over functions (a special case of binary relations),
let $\func{s}{s'}=
\{\METAfun\mid\MEMdom{\METAfun}\subseteq{s}\wedge\MEMran{\METAfun}\subseteq{s'}\}$,
%% let $\funci{\METAs}{\METAs'}$ be $\func{\METAs}{\METAs'}$ restricted to
%% injective functions,
and let $\asgn{x}{y}$ be
an alternative notation for $\mypair{x}{y}$ used when
writing some functions.
%
Let $\MEMuplus{\METAfun_1}{\METAfun_2}=\METAfun_2\cup(\MEMrestrictout{\METAfun_1}{\MEMdom{\METAfun_2}})$.
%
%Let $\METAfun_1,\METAfun_2\in\func{s_1}{s_2}$.
Let
$\MEMequnion{\METAfun_1}{\METAfun_2}$ be $\METAfun_1\cup\METAfun_2$ if
$\METAfun_1\cup\METAfun_2$ is a function
and undefined otherwise.
%
If $\METAfun_1,\METAfun_2\in\func{s_1}{\MEMpowset{s_2}}$ then let
$\MEMuenv{\METAfun_1}{\METAfun_2}
=\{\asgn{x}{\METAfun_1\cup\METAfun_2}\mid{x}\in\MEMdom{\METAfun_1}\cap\MEMdom{\METAfun_2}\}
\cup
\MEMrestrictout{\METAfun_1}{\MEMdom{\METAfun_2}}
\cup
\MEMrestrictout{\METAfun_2}{\MEMdom{\METAfun_1}}$.
%
%% Let
%% $\MEMfdunion{\METAfun_1}{\METAfun_2}=\METAfun_1\cup\METAfun_2$
%% if $\MEMdisj{\MEMdom{\METAfun_1},\MEMdom{\METAfun_2}}$
%% and undefined otherwise.
%
%
%
%\smallintitle{Tuples}
%
A tuple $\METAtup$ is a function such that $\MEMdom{\METAtup} \subset
\SETnat$ and if $1 \leq j \in \MEMdom{\METAtup}$ then $j - 1
\in \MEMdom{\METAtup}$.
%
Let $\METAtup$ range over tuples.
%
If $v$ ranges over $s$ then let $\METAtoseq{v}$ range
over $\MEMfintuple{s}=\{\METAtup\mid\MEMran{\METAtup}\subseteq{s}\}$.
%
We write the tuple
$\{\asgn{0}{x_0},\dots,\asgn{n}{x_n}\}$ as
$\mytuple{x_0,\dots,x_n}$.
%% We say that
%% $\mytuple{\METAx_1,\dots,\METAx_\METAn}$ is a
%% % finite
%% tuple of length $n$.
Let $@$ append tuples:
$\mytuple{x_1,\dots,x_i}@\mytuple{y_1,\dots,y_j}
=\mytuple{x_1,\dots,x_i,y_1,\dots,y_j}$.
%% $\mytuple{\METAx_1, \dots, \METAx_\METAn}$ and
%% $\mytuple{\METAy_1,\dots,\METAy_\METAm}$
%  Given a set $\METAs$, let $\MEMfintuple{\METAs} =
% \{\METAtup \mid \MEMran{\METAtup} \subseteq \METAs\}$.
%Given a set $\METAs$, let
%$\MEMfintuple{\METAs}=\{\METAtup\mid\MEMran{\METAtup}\subseteq\METAs\}$.
% \wedge \METAtup \mbox{ is a
%   finite tuple }\}$.
%% We use $\mytuple{}$ for
%% the empty tuple, i.e., $\mytuple{}$ is an alternative notation for
%% $\emptyset$ used when writing tuples.
%% We sometimes write $x\in\METAtoseq{\METAv}$ for $x\in\MEMran{\METAtoseq{\METAv}}$.
%
Given $n$ sets $s_1,\dots,s_n$, let $s_1\cprod\cdots\cprod{s_n}$ be
$\{\mytuple{x_1,\dots,x_n}\mid\forallexp{i\in\{1,\dots,n\}}{x_i\in{s_i}}\}$.
Note that
$s_1\cprod\cdots\cprod{s_n}\subseteq\MEMfintuple{s_1\cup\cdots\cup{s_n}}$.
%
%
%\smallintitle{Inference rules}
%
%% We often write our inference rules as follows:
%% $\MEMinferdd{x}{y_1}{\cdots}{y_n}{(r)}$, instead of the more
%% traditional form:
%% \begin{center}
%%   \begin{\sizeintables}
%%     $\infer[\MEMalgorule{r}]{x}{y_1 & \cdots & y_n}$
%%   \end{\sizeintables}
%% \end{center}
%
%% An inference rule is a pair premises/conclusion which states that if
%% the premises are true then the conclusion must be true as well.
%% %
%% In the literature, an inference rule is often written as follows:
%% \begin{center}
%%   \begin{\sizeintables}
%%     $\infer[\MEMalgorule{r}]{x}{y_1 & \cdots & y_n}$
%%   \end{\sizeintables}
%% \end{center}
%% which means that if $y_i$ for all $i\in\{1,\dots,n\}$ are true then
%% $x$ is true.
%% %
%% This rule is named $\MEMalgorule{r}$.
%% %
%% Such a rule is sometimes written as follows:
%% \begin{center}
%%   \begin{\sizeintables}
%%     $\MEMinferddr{x}{y_1}{\cdots}{y_n}{(r)}$
%%   \end{\sizeintables}
%% \end{center}
%% In this document we also sometimes write such a rule as follows:
%% \begin{center}
%%   \begin{\sizeintables}
%%     $\MEMinferdd{x}{y_1}{\cdots}{y_n}{(r)}$
%%   \end{\sizeintables}
%% \end{center}
%% %% or as follows:
%% %% \begin{center}
%% %%   \begin{\sizeintables}
%% %%     $(r)$ if $y_1$ and $\cdots$ and $y_n$ then $x$
%% %%   \end{\sizeintables}
%% %% \end{center}
%% The rule name is sometimes omitted in such rules.




%\section{\SECtechnical}
\section{\SECtechnical}
\label{sec:technicalities}



This section introduces \CORETES\ modules: initial
constraint generator (Sec.~\ref{sec:constraintgen}),
constraint solver (Sec.~\ref{sec:unification}),
minimiser (Sec.~\ref{sec:minimisation}),
enumerator (Sec.~\ref{sec:enumeration}),
and slicer (Sec.~\ref{sec:slicing}).
%
The reader might (or might not) want to peek ahead at
Sec.~\ref{sec:whyminimisation} which motivates the need of a
minimiser.
%
Sec.~\ref{sec:overallalgo} defines the overall algorithm.
%
Sec.~\ref{sec:syntax} presents a fragment of \SML\ syntax handled by
\CORETES.
%
Sec.~\ref{sec:constraintsystem} defines the constraint syntax of
\CORETES\ and Sec.~\ref{sec:semantics-constraint-envs} their
semantics.
%
Sec.~\ref{sec:principles} discusses the principles of our approach.
The reader might (or might not) want to peek ahead at
Sec.~\ref{sec:principles} while reading the sections below.


\subsection{\TES' overall algorithm}
\label{sec:overallalgo}


\begin{\myfigure}[t]
  \begin{\sizeintablesp}
    \begin{center}
      \includegraphics[width=0.9\textwidth]{sml-tes-diagram}
    \end{center}
    \caption{Interaction between the different modules of our \TES}
    \label{fig:smltesdiagram}
  \end{\sizeintablesp}
\end{\myfigure}

Fig.~\ref{fig:smltesdiagram} informally presents how the different
modules of our \TES\ interact with each other.  We use different
colours to differentiate different parts of our \TES.  The green parts
are user interface related.  The red parts are related to slicing.
The purple parts are related to constraint generation.  These parts
are external language related.  The blue parts are related to the
enumeration of type errors.  These parts are external language
unrelated.


Formally, given a \SML\ structure declaration $\METAstrdec$ (see
Fig.~\ref{fig:unifSyntaxOpen}), the initial constraint generation
algorithm defined in Fig.~\ref{fig:consGenAlgo}
%and extended in
%Fig.~\ref{fig:dotterms} to dot terms (see Sec.~\ref{sec:dotterms}),
generates a constraint/environment $\METAcsenv$ (see
Fig.~\ref{fig:constraintterms}).
%
Then, the enumerator defined in Fig.~\ref{fig:enumalgo} enumerates the
type errors of $\METAcsenv$.  Each error found by the enumerator is
minimised by the minimiser also defined in Fig.~\ref{fig:minalgo}.
%
From each minimised error and $\METAstrdec$, the slicing algorithm
defined in Sec.~\ref{sec:slicing} computes a type error slice.
%
Both enumeration and minimisation rely on the constraint solver
defined in Fig.~\ref{fig:unifAlgoOpen}.
%
The computed type error slices are finally reported to the user.
%
A type error report includes a type error slice, a highlighting of the
slice directly in the \SML\ user code, and a message explaining the kind of the
error (see Fig.~\ref{fig:unifSyntaxOpen}).
%and a set of identifier status context dependencies.
%
Formally, our overall algorithm $\MEMtesSYMB$ is defined as follows
(the undefined relations, functions, and other syntactic forms used in
this definition of \TES' overall algorithm are all defined in the
remaining sections):
\begin{center}
  \begin{\sizeintables}
    \begin{tabular}{lll}
      $\MEMtes{\METAstrdec}
      =\{\mytuple{\METAstrdec',\METAuniferrorkind}$
      & $\mid$
      & $\MEMgena{\METAstrdec}=\METAcsenv$
      \\
      & $\wedge$
      & $\MEMenum{\METAunifstate}{\METAcsenv}\ffenum\MEMerrorset{\METAerrorset\cup\{\CONSerror{\METAuniferrorkind}{\METAlabset}\}}$
      %% \\
      %% & $\wedge$
      %% & $\CONSerror{\METAuniferrorkind}{\METAlabset}\in\METAerrorset$
      %% \\
      %% & $\wedge$
      %% & $\CONSerror{\METAuniferrorkind}{\METAlabset\cup\METAidset}\in\METAerrorset$
      \\
      & $\wedge$
      & $\MEMslice{\METAstrdec}{\METAlabset}=\METAstrdec'\}$
    \end{tabular}
  \end{\sizeintables}
\end{center}

%% Note that \CORETES\ does not have value identifier dependencies.
%% These dependencies are introduced in Sec.~\ref{sec:idstatuses}.  We
%% anticipate this addition in the definition of our overall algorithm
%% above (see the computation of the $\METAidset$ sets).







%%% External syntax of analysed programs.
\subsection{\SECsyntax}
\label{sec:syntax}


\begin{\myfigure}[t]
\begin{\sizeintables}

    \mytitle{external syntax} \hspace{0.05in} (what the programmer sees, plus labels)

\begin{tabular}{rclrll}
$\METAlab$         & $\in$ & $\SETlab$         & \multicolumn{3}{l}{(labels)}\\
$\METAtypevar$     & $\in$ & $\SETtypevar$     & \multicolumn{3}{l}{(type variables)}\\
$\METAtypename$    & $\in$ & $\SETtypename$    & \multicolumn{3}{l}{(type constructors)}\\
$\METAstrid$       & $\in$ & $\SETstrid$       & \multicolumn{3}{l}{(structure identifiers)}\\
$\METAvvar$        & $\in$ & $\SETvvar$        & \multicolumn{3}{l}{(value variables)}\\
$\METAdcon$        & $\in$ & $\SETdcon$        & \multicolumn{3}{l}{(datatype constructors)}\\
\end{tabular}
\hspace{0.1in}
\begin{tabular}{rclrll}
$\METAid$          & $\in$ & $\SETid$          & $::=$  & $\METAvvar\mid\METAdcon$&\\
$\METAlabtypename$ & $\in$ & $\SETlabtypename$ & $::=$  & $\LABlabgen{\METAtypename}{\METAlab}$&\\
$\METAlabdcon$     & $\in$ & $\SETlabdcon$     & $::=$  & $\LABlabgen{\METAdcon}{\METAlab}$&\\
%$\METAlabstrid$    & $\in$ & $\SETlabstrid$    & $::=$  & $\LABlabgen{\METAstrid}{\METAlab}$&\\
%% \end{tabular}
%% \hspace{0.1in}
%% \begin{tabular}{rclrll}
$\METAtype$        & $\in$ & $\SETtype$        & $::=$  & $\LABtypeTypevar{\METAtypevar}{\METAlab}$
                                                 $\mid$   $\LABtypeArrow{\METAtype_1}{\METAtype_2}{\METAlab}$
                                                 $\mid$   $\LABsptypeTypename{\METAtype}{\METAlabtypename}{\METAlab}$&\\
$\METAtypecon$     & $\in$ & $\SETtypecon$     & $::=$  & $\LABtypeconId{\METAdcon}{\METAlab}$
                                                 $\mid$   $\LABtypeconCompp{\METAdcon}{\METAlab_1}{\METAtype}{\METAlab}$ &\\
$\METAdatname$     & $\in$ & $\SETdatname$     & $::=$  & $\LABdatnamep{\METAtypevar}{\METAtypename}{\METAlab}$&\\
\end{tabular}
\begin{tabular}{rclrll}
$\METAdec$         & $\in$ & $\SETdec$         & $::=$  & $\LABdecVal{\LABvalbind{\METApat}{\METAexp}{\METAlab}}$
                                                 $\mid$   $\LABdecOpen{\METAstrid}{\METAlab}$
                                                 $\mid$   $\LABdecDat{\LABspdatbind{\METAdatname}{\METAtypecon}{\METAlab}}$&\\
$\METAatexp$       & $\in$ & $\SETatexp$       & $::=$  & $\LABexpId{\METAid}{\METAlab}$
                                                 $\mid$   $\LABexpLet{\METAdec}{\METAexp}{\METAlab}$ &\\
$\METAexp$         & $\in$ & $\SETexp$         & $::=$  & $\LABexpAtexp{\METAatexp}$
                                                 $\mid$   $\LABexpFnp{\LABmrule{\METApat}{\METAexp}{\METAlab}}{\METAlab}$
                                                 $\mid$   $\LABexpApp{\METAexp}{\METAatexp}{\METAlab}$ &\\
%$\METApat$         & $\in$ & $\SETpat$         & $::=$  & $\LABpatId{\METAid}{\METAlab}$\\
$\METAatpat$       & $\in$ & $\SETatpat$       & $::=$  & $\LABpatId{\METAid}{\METAlab}$\\
$\METApat$         & $\in$ & $\SETpat$         & $::=$  & $\LABpatAtpat{\METAatpat}$
                                                 $\mid$   $\LABpatAppSp{\METAlabdcon}{\METAatpat}{\METAlab}$ &\\
$\METAstrdec$      & $\in$ & $\SETstrdec$      & $::=$  & $\LABstrdecDec{\METAdec}$
                                                 $\mid$   $\LABstrdecStr{\LABstrbindBas{\METAstrid}{\METAstrexp}{\METAlab}}$ &\\
$\METAstrexp$      & $\in$ & $\SETstrexp$      & $::=$  & $\LABstrexpId{\METAstrid}{\METAlab}$
                                                 $\mid$   $\LABstrexpMul{\METAstrdec_1}{\METAstrdec_n}{\METAlab}$&

\end{tabular}


\vspace*{0.04in}
\mytitle{extra metavariables}

\begin{tabular}{rclrl}
$\METAgenid$      & $\in$ & $\SETgenid$      & $::=$  & $\METAid\mid\METAstrid\mid\METAtypevar\mid\METAtypename$\\
\end{tabular}
\hspace{0.2in}
\begin{tabular}{rclrl}
$\METAterm$        & $\in$ & $\SETterm$        & $::=$  & $\METAlabtypename
                                                           \mid\METAlabdcon
                                                           \mid\METAtype
                                                           \mid\METAtypecon
                                                           \mid\METAdatname
                                                           \mid\METAexp
                                                           \mid\METApat
                                                           \mid\METAstrdec
                                                           \mid\METAstrexp$
\end{tabular}

\end{\sizeintables}
%  \input{included/syntax3}
  \caption{External labelled syntax}
  \label{fig:syntaxOpen}
\end{\myfigure}


Fig.~\ref{fig:syntaxOpen} defines a fragment of \SML\
syntax used to present the core ideas.
%where the most interesting cases are datatype declarations
%and structure openings.
%
%
Most syntactic forms have labels ($\METAlab$), which are generated to
track blame for errors.
%%  where
%% a $\METAtvopt$ (``opt'' means optional)
%% is a simplification of a type variable sequence,
%% a $\METAtyopt$ is a simplification of a type sequence
%% and
%where no further syntactic restriction is enforced.
%% except the following one:
%% a label $\METAlab$ labels at most one node in a term.
%
To provide a visually convenient place for labels, some terms such
as function applications are surrounded by $\LABdelL~\LABdelR$
%
%% We use $\MEMemptysymb$ for an empty sequence.
%
which are not written by programmers but are part of an internal
representation used to avoid confusion with $(~)$ as part of \SML\
syntax.
%
%% We define two metavariables ranging over type variables:
%% $\METAtypevar$ is used for external type variables and $\METAtyvar$
%% for internal ones.   We define two metavariables ranging over type
%% constructors: $\METAtypename$ is used for external type constructors
%% and $\METAtyname$ for internal ones.
%
%Note that
Value identifiers ($\METAid$) are subscripted to disambiguate rules
for expression ($\LABexpId{\METAid}{\METAlab}$), datatype constructor
definitions ($\LABtypeconId{\METAdcon}{\METAlab}$), and pattern
($\LABpatId{\METAid}{\METAlab}$) occurrences.
%
The only non-subscripted (non-ambiguous) value identifiers are those
occurring at unary positions in patterns and datatype declarations.


Although \SML\ distinguishes value variables and datatype constructors
by assigning statuses in the type system, we distinguish them by
defining two disjoint sets $\SETvvar$ and $\SETdcon$.
%
%These statuses are context dependent.
As opposed to \CORETES, for fully correct minimal error slices,
\FORMTES\ handles identifier statuses.
%
Also, to simplify  \CORETES' presentation, datatypes have one
constructor and one type argument.

%  The needed generalisation is left to the reader

%% \nnewtext{Note that in our language we omit multi-constructor
%%   datatypes to simplify our core language and because only one
%%   constructor is needed to introduce \SML's identifier status
%%   ambiguity.}


Finally, we do not enforce all the syntactic restrictions of \SML\
syntax~\cite{Milner+Tofte+Harper+Macqueen:1997}.  For example,
in a recursive declaration such as
$\LABdecVal{\LABvalbind{\METApat}{\METAexp}{\METAlab}}$, the
expression $\METAexp$ must be a $\CONS{fn}$-expression (which we do
not enforce in the present document).


%% Labels are used to uniquely identify each part (node of the abstract
%% syntax tree) of a piece of code.  We also saw in
%% Fig.~\ref{fig:consGenAlgo} that at constraint generation, for each
%% node of an abstract syntax tree, we introduce a unique variable.  We
%% could therefore directly annotate the external syntax with unique
%% variables that would then be used at constraint generation.  Given
%% that, we could therefore get rid of labels.


%% In this section we are going to consider the following simple running
%% example:

%% \begin{center}
%%   \begin{\sizeintablesp}
%%     \begin{tabular}{l}
%%       $\examplerun$
%%     \end{tabular}
%%     \hspace{0.3in}
%%     \begin{tabular}{l}
%%       \examplebody{
%%         \Bl
%%         structure X = struct
%%           \\
%%           \Bi
%%           structure S = struct datatype 'a u = U end
%%           \\
%%           datatype 'a t = T
%%           \\
%%           val rec f = fn T => T
%%           \\
%%           val rec g = let open S in f U end
%%           \\
%%           end
%%           \Ei
%%         \\
%%         end
%%         \El
%%       }
%%     \end{tabular}
%%   \end{\sizeintablesp}
%% \end{center}


Let us now present example~$\examplerun$: our simple running example.
%
This piece of code is untypable because f is defined as taking a
\inexamplebody{'a t} and is applied to a \inexamplebody{'a u}.
%
The labelled version of this piece of code, which we call
$\METAstrdec_{\mathrm{EX}}$, is as follows:
\begin{center}
  \begin{\sizeintablesp}
    \begin{tabular}{l}
      $\examplerun$
    \end{tabular}
    \hspace{0.3in}
    \begin{tabular}{l}
    $\LABstrdecStr
    {\LABstrbindBas
      {\mbox{\inexamplebody{X}}}
      {\LABstrexpFourp
        {\LABstrdecStr
          {\LABstrbindBas
            {\mbox{\inexamplebody{S}}}
            {\LABstrexpOne
              {\LABstrdecDec
                {\LABdecDat
                  {\LABspdatbind
                    {\LABdatnamep{\mbox{\inexamplebody{'a}}}{\mbox{\inexamplebody{u}}}{\METAlab_6}}
                    {\LABtypeconId{\mbox{\inexamplebody{U}}}{\METAlab_7}}
                    {\METAlab_5}
                  }
                }
              }
              {}
              {\METAlab_4}
            }
            {\METAlab_3}
          }
        }
        {\LABstrdecDec
          {\LABdecDat
            {\LABspdatbind
              {\LABdatnamep{\mbox{\inexamplebody{'a}}}{\mbox{\inexamplebody{t}}}{\METAlab_9}}
              {\LABtypeconId{\mbox{\inexamplebody{T}}}{\METAlab_{10}}}
              {\METAlab_8}
            }
          }
        }
        {\LABstrdecDec
          {\LABdecVal
            {\LABvalbind
              {\LABpatAtpat{\LABpatId{\mbox{\inexamplebody{f}}}{\METAlab_{12}}}}
              {\LABexpFnp
                {\LABmrule
                  {\LABpatAtpat{\LABpatId{\mbox{\inexamplebody{T}}}{\METAlab_{14}}}}
                  {\LABexpAtexp{\LABexpId{\mbox{\inexamplebody{T}}}{\METAlab_{15}}}}
                  {\METAlab_{13}}
                }
                {}
              }
              {\METAlab_{11}}
            }
          }
        }
        {\LABstrdecDec
          {\LABdecVal
            {\LABvalbind
              {\LABpatAtpat{\LABpatId{\mbox{\inexamplebody{g}}}{\METAlab_{17}}}}
              {\LABexpAtexp
                {\LABexpLet
                  {\LABdecOpen{\mbox{\inexamplebody{S}}}{\METAlab_{19}}}
                  {\LABexpApp
                    {\LABexpAtexp{\LABexpId{\mbox{\inexamplebody{f}}}{\METAlab_{21}}}}
                    {\LABexpId{\mbox{\inexamplebody{U}}}{\METAlab_{22}}}
                    {\METAlab_{20}}
                  }
                  {\METAlab_{18}}
                }
              }
              {\METAlab_{16}}
            }
          }
        }
        {\METAlab_2}
      }
      {\METAlab_1}
    }$
    \end{tabular}
  \end{\sizeintablesp}
\end{center}



\subsection{\SECconstraint}
\label{sec:constraintsystem}




\begin{\myfigure}[t]
\begin{\sizeintables}
    \mytitle{constraint terms} \hspace{0.0in} (syntax of entities used
    internally by \TES\ and which the programmer never sees)

%\vspace*{-0.05in}
\begin{tabular}{rclrl}
  $\METAenvvar$     & $\in$ & $\SETenvvar$     & \multicolumn{2}{l}{(environment variables)}\\
  $\METAtynamevar$  & $\in$ & $\SETtynamevar$  & \multicolumn{2}{l}{(type constructor variables)}\\
  $\METAtyname$     & $\in$ & $\SETtycon$      & \multicolumn{2}{l}{(type constructor names)}\\
  $\METAtyvar$      & $\in$ & $\SETtyvar$      & \multicolumn{2}{l}{(internal type variables)}\\
  %  $\METAstatusvar$  & $\in$ & $\SETstatusvar$  & \multicolumn{2}{l}{(status variables)}\\
%  $\METAcdep$       & $\in$ & $\SETdependency$ & $::=$  & $\METAlab\mid\METAid$\\
  $\METAcdep$       & $\in$ & $\SETdependency$ & $::=$  & $\METAlab$\\
  %$\METArawstatus$  & $\in$ & $\SETrawstatus$  & $::=$  & $\CONSstatusv\mid\CONSstatusc\mid\CONSstatusd\mid\CONSstatusu\mid\CONSstatusp\mid\CONSstatusa$\\
  %$\METAstatus$     & $\in$ & $\SETstatus$     & $::=$  & $\METArawstatus\mid\CONSdeps{\METAstatus}{\METAcdepset}$\\
\end{tabular}
\begin{tabular}{rclrl}
  $\METAnamety$        & $\in$ & $\SETnametyp$       & $::=$  & $\METAtynamevar\mid
                                                                 \METAtyname\mid
                                                                 \CONStyconnamearrow\mid
%                                                                 \CONSenvenv{\METAnamety}{\METAcsenv}\mid
                                                                 \CONSdeps{\METAnamety}{\METAcdepset}$
\\%\mid\CONSsemt{\METAtypename}{\METAseqvar}
  $\METAlabty$         & $\in$ & $\SETlabtyp$        & $::=$  & $\METAtyvar\mid
                                                                 \CONSconsty{\METAnamety}{\METAlabty}\mid
                                                                 \CONSarrowty{\METAlabty_1}{\METAlabty_2}\mid
%                                                                 \CONSenvenv{\METAlabty}{\METAcsenv}\mid
                                                                 \CONSdeps{\METAlabty}{\METAcdepset}$
\\%\mid\CONSsemp{\METAtypevar}\mid\CONSsemv{\METAid}{\METAstatus}
  $\METAityscheme$     & $\in$ & $\SETityscheme$     & $::=$  & $\CONScsscheme{\METAvarset}{\METAcsenv}{\METAlabty}$\\
  $\METAityconscheme$  & $\in$ & $\SETityconscheme$  & $::=$  & $\CONScsscheme{\METAvarset}{\METAcsenv}{\METAnamety}$\\
  $\METAenvscheme$     & $\in$ & $\SETenvscheme$     & $::=$  & $\CONScsscheme{\METAvarset}{\METAcsenv}{\METAcsenv'}$\\
\end{tabular}
\begin{tabular}{rclrl}
  $\METAcs$         & $\in$ & $\SETcs$         & $::=$  & $\ucso{\METAnamety_1}{\METAnamety_2}\mid
                                                           \ucso{\METAcsenv_1}{\METAcsenv_2}\mid
                                                           \ucso{\METAlabty_1}{\METAlabty_2}$\\%\mid
%                                                           \ucso{\METAstatus_1}{\METAstatus_2}$\\
%  $\METAscheme$     & $\in$ & $\SETscheme$     & $::=$  & $\METAlabty\mid\CONSscheme{\METAtyvarset}{\METAlabty}\mid\CONSdeps{\METAscheme}{\METAcdepset}$\\
  $\METAbind$       & $\in$ & $\SETbind$       & $::=$  & $\CONSbind{\METAtypename}{\METAityconscheme}\mid
                                                           \CONSbind{\METAstrid}{\METAenvscheme}\mid
                                                           \CONSbind{\METAtypevar}{\METAityscheme}\hspace{0.005in}\mid
                                                           \CONSbind{\METAid}{\METAityscheme}$\\%\mid
%                                                           \CONSbind{\METAid}{\METAstatus}$\\%\mid
%                                                           \CONSbindu{\METAid}{\METAtyvar}$\\
  $\METAacc$        & $\in$ & $\SETacc$        & $::=$  & $\CONSacc{\METAtypename}{\METAtynamevar}\hspace{0.06in}\mid
                                                           \CONSacc{\METAstrid}{\METAenvvar}\mid
                                                           \CONSacc{\METAtypevar}{\METAtyvar}\mid
                                                           \CONSacc{\METAid}{\METAtyvar}$\\%\mid
%                                                           \CONSacc{\METAid}{\METArawstatus}$\\
  $\METAcsenv$      & $\in$ & $\SETcsenv$      & $::=$  & $\CONSenvnul
                                                           \mid\METAenvvar
                                                           \mid\METAbind
                                                           \mid\METAacc
                                                           \mid\METAcs
                                                           \mid\CONStopoly{\METAcsenv}
                                                           \mid\CONSexistsenv{\METAatom}{\METAcsenv}
                                                           \mid\CONSenvenv{\METAcsenv_1}{\METAcsenv_2}
                                                           \mid\CONSdeps{\METAcsenv}{\METAcdepset}$
\end{tabular}


\vspace*{0.04in}
\mytitle{extra metavariables}
\vspace*{0.02in}

\begin{tabular}{rclrl}
  $\METAcsterm$     & $\in$ & $\SETcsterm$     & $::=$  & $\METAlabty\mid\METAnamety\mid\METAcsenv$\\
  $\METAscheme$     & $\in$ & $\SETscheme$     & $::=$  & $\METAityscheme\mid\METAityconscheme\mid\METAenvscheme$\\
\end{tabular}
\hspace{0.2in}
\begin{tabular}{rclrl}
  $\METAvar$        & $\in$ & $\SETvar$         & $::=$  & $\METAtyvar\mid\METAtynamevar\mid\METAenvvar$\\
  $\METAatom$       & $\in$ & $\SETatom$        & $::=$  & $\METAvar\mid\METAtyname\mid\METAcdep$\\
\end{tabular}
\hspace{0.2in}
\begin{tabular}{rclrl}
  $\METAdependent$  & $\in$ & $\SETdependent$  & $::=$  & $\CONSdeps{\METAcsterm}{\METAcdepset}$\\%\mid\CONSdeps{\METAstatus}{\METAcdepset}
%  $\METAconsterm$   & $\in$ & $\SETconsterm$   & $::=$  & $\METAlabty\mid\METAnamety\mid\METAcsenv$\\
\end{tabular}

%% \vspace*{0.04in}
%% \mytitle{renamings, unifiers and substitutions}

%% \begin{tabular}{ r c l r l }

%% $\METAren$           & $\in$ & $\SETren$           & $=$    & $\{\METAren\in\func{\SETtyvar}{\SETtyvar}\mid\METAren\mbox{ is injective}\wedge\MEMdisj{\MEMdom{\METAren},\MEMran{\METAren},\SETfreshvar}\}$\\

%% $\METAunifstatety$   & $\in$ & $\SETunifstatety$   & $=$    & $\{\METAfun_1\cup\METAfun_2\cup\METAfun_3
%%                                                                \mid\METAfun_1\in\func{\SETtyvar}{\SETlabtyp}
%%                                                                \wedge\METAfun_2\in\func{\SETtynamevar}{\SETnametyp}
%%                                                                \wedge\METAfun_3\in\func{\SETenvvar}{\SETcsenv}\}$\\
%% %%                     &       &                     &        &  $\hspace*{0.85in}\wedge\METAfun_3\in\func{\SETseqvar}{\SETexttyseqid}$

%% $\METAsub$           & $\in$ & $\SETsub$           & $=$     & $\SETunifstatety$
%% \end{tabular}

\end{\sizeintables}
%  \input{included/syntax3}
  \caption{Syntax of constraint terms}
  \label{fig:constraintterms}
\end{\myfigure}


\subsubsection{Terms}
%
%% \begin{\myfigure}[!th]
%%   \input{included/constraintsForOpen}
%%   \caption{Constraints}
%%   \label{fig:constraintsForOpen}
%% \end{\myfigure}
%
Fig.~\ref{fig:constraintterms} defines
%
\index{constraint term}%
%
\emph{constraint terms},
those pieces of syntax that can occur anywhere inside a constraint.
%
In our system, this is any
%%%$\METAenvvar$
%%%$\METAtynamevar$
%%%$\METAtyname$
%%%$\METAtyvar$
%%%$\METAcdep$,
%%%$\METArawstatus$
%$\METAstatus$,
%
$\METAnamety$,
%
$\METAlabty$, or
%
%$\METAscheme$, or
%
$\METAcsenv$.


%
\hidden{Constraints are generated by our constraint
generator (defined at the end of this section) to then be
unified by our constraint solver (Sec.~\ref{sec:unification}).}
%% In this section we also define diverse functions to manipulate
%% constraints.
%
%% We consider the functional type constructor $\MEMtyarrow$ to be in
%% $\SETtyname$.

\mynote{(2010-04-21)}{We need something like
  $\CONSopen{\METAstrid}{\METAlab}$ because we need a labelled
  accessor so that during filtering we can either definitely discard
  an opened environment, replacing it by $\emptyset$, if it does not
  interfere in an error (during minimisation) or if we want to test
  the discarding of an opening during enumeration we can replace it by
  an environment variables.  We could put a label on
  $\CONSsems{\METAstrid}{\METAlab}$ but then we would have to put a
  label on the other accessors to have a uniform treatment pf
  accessors.  We could have more generally
  $\CONSopen{\METAcsenv}{\METAlab}$ so that we can open any
  environment and so that these openings are not accessors.  But now
  they look like the constrained environments
  $\MEMbindss{\METAcsenv}{\METAcdepset}$.  We could then have
  $\MEMbindss{\METAcsenv}{\METAcdepset}$ an en environment and
  $\MEMbindpp{\METAlabty}{\METAcdepset}$ as a type...}


%% \newtext{In addition to distinguishing identifier classes ($\SETid$
%%   for value identifiers, $\SETtypename$ for type constructor names,
%%   etc.), \SML\ assigns statuses within the value identifier class to
%%   distinguish value variables, datatype constructors, and exception
%%   constructors.
%%   Because \SML\ has no lexical distinction between, e.g., a datatype
%%   constructor and a value variable, a value identifier's status cannot
%%   always be inferred from any context smaller than the entire
%%   program.}

%% \newtext{In our constraint system, an identifier status can either be a raw
%% status ($\METArawstatus$) or a raw status annotated with dependencies
%% ($\METAstatus$).
%% %
%% The $\CONSstatusv$ status is for value variables (e.g.,
%% \SML\ requires the recursive function \inexamplebody{f} in
%% \inexamplebody{val rec f = fn x => x} to be a value variable and not a
%% datatype constructor).
%% Statuses $\CONSstatusc$ and $\CONSstatusd$ are for unary and nullary datatype
%% constructors respectively (e.g., \inexamplebody{C} in
%% \inexamplebody{datatype 'a t = C of 'a} and \inexamplebody{D} in
%% \inexamplebody{datatype 'a t = D}).
%% Status $\CONSstatusu$ is for unconfirmed context-dependent statuses
%% (e.g., in \inexamplebody{fn x => x},
%% the identifier \inexamplebody{x} could be a value variable or a
%% nullary datatype constructor).
%% Status $\CONSstatusp$ is for unresolvable statuses such as in
%% \inexamplebody{let open S in fn x => x end}, where \inexamplebody{x} could
%% be declared as a value variable as well as a datatype constructor in
%% the free structure \inexamplebody{S}.
%% Finally, status $\CONSstatusa$ is similar to a variable as it can be any status
%% (used by our constraint filtering function $\MEMcsprojSYMB$ defined
%% in Fig.~\ref{fig:csfiltering} in Sec.~\ref{sec:unification} to generate
%% dummy environments that cannot participate in type errors).}

Some forms, called
%
\index{constraint term!dependent constraint term}%
%
\emph{dependent forms}, are annotated by
dependencies: $\CONSdeps{x}{\METAcdepset}$.  In \CORETES, a dependency
$\METAcdep$ must be a label $\METAlab$\footnote{In \IMPLTES, a
  dependency $\METAcdep$
  can also be a value identifier $\METAid$ for handling identifier
  statuses.}.
%
%% During analysis, if a dependency $\METAcdep$ is a label $\METAlab$,
%% the annotated syntactic form depends on the program node labelled by
%% $\METAlab$.
%
During analysis, a form $\CONSdeps{x}{\METAcdepset}$ depends on the
program nodes with labels in $\METAcdepset$.
%
For example, if the dependent equality constraint
$\CONSdeps{\csou{\METAlabty_1}{\METAlabty_2}}{\METAcdepset\cup\{\METAlab\}}$
is generated for the labelled function application
$\LABexpApp{\METAexp}{\METAatexp}{\METAlab}$, the dependency
$\METAlab$ indicates that the
equality constraint $\csou{\METAlabty_1}{\METAlabty_2}$ needs only be
true if node $\METAlab$ has not been sliced out (our slicing algorithm
is defined in Sec.~\ref{sec:slicing}).
%
%% If $\METAcdep$ is a value identifier $\METAid$, then the
%% syntactic form depends on $\METAid$'s status in the code being a
%% $\CONSstatusv$ or $\CONSstatusu$.
%% %
%% Because identifiers' statuses are resolved during constraint solving, such
%% dependencies (value identifiers) are only generated during constraint
%% solving and not during initial constraint generation.
%% %
%% For example, if constraint solving generates the dependent equality
%% constraint
%% $\CONSdeps{\csou{\METAlabty_1}{\METAlabty_2}}{\METAcdepset\cup\{\METAid\}}$, then
%% the equality constraint
%% $\csou{\METAlabty_1}{\METAlabty_2}$ needs to be satisfied only if
%% $\METAid$ cannot be a datatype constructor.
%%
%% Let $\MEMundepSYMB$ be the function that strips off the outer
%% dependencies
%% %(not nested under another constructor than the dependency constructor)
%% of any syntactic form: $\MEMundep{x}=\MEMundep{y}$ if
%% $x=\CONSdeps{y}{\METAcdepset}$, $x$ otherwise.
%
%% Let $\MEMcollapseSYMB$ be the function that combines nested outermost
%% dependencies:
%% $\MEMcollapse{x}=\MEMcollapse{\CONSdeps{y}{\METAcdepset_1\cup\METAcdepset_2}}$
%% if $x=\CONSdeps{(\CONSdeps{y}{\METAcdepset_1})}{\METAcdepset_2}$,
%% $x$ otherwise.

\hidden{
The type $\CONSsemv{\METAid}{\METAstatus}$ is $\METAid$'s type,
%(``$\CONSsemiSYMB$'' standing for internal),
$\CONSsemp{\METAtypevar}$ is the type associated with
the external type variable $\METAtypevar$,
$\CONSsemt{\METAtypename}{\METAseqvar}$ is the internal type
constructor
associated with the external type constructor $\METAtypename$,
$\CONSsems{\METAstrid}{\METAlab}$ is the environment
declared by the structure $\METAstrid$, and
%$\CONSsema{\METAtypename}$ is $\METAtypename$'s arity and
$\CONSsemc{\METAid}$ is $\METAid$'s status.
These five terms are called accessors because are used to access type
environments
% they allow accessing
%type environments during unification.
}

%% \hidden{
%% A
%% $\METAbindv=\MEMbindvv{\METAscheme}{\METAstatus}{\METAcdepset}$
%% (where ``$\META{sem}$'' stands for static semantics)
%% is associated to a $\METAid$ in a type environment where
%% $\METAscheme$ is $\METAid$'s type and $\METAstatus$ is $\METAid$'s
%% status.
%% %
%% A
%% $\METAbindp=\MEMbindpp{\METAlabty}{\METAcdepset}$
%% is associated to a $\METAtypevar$
%% % in an environment
%% where $\METAlabty$ is the internal type associated to the explicit
%% type variable $\METAtypevar$.
%% %
%% A
%% $\METAbindt=\MEMbindtt{\METAnamety}{\METAcdepset}$
%% is associated to a $\METAtypename$
%% % in an environment
%% where
%% $\METAnamety$ is the internal type constructor associated to the
%% external type constructor
%% $\METAtypename$.
%% %%  and where
%% %% $\METAseqty$ constrains $\METAtypename$'s arity.
%% %
%% A
%% $\METAbinds=\MEMbindss{\METAcsenv}{\METAcdepset}$
%% is associated to a $\METAstrid$
%% % in an environment
%% where
%% $\METAcsenv$ is the environment associated to $\METAstrid$.
%% %
%% Each of these $\METAbindid$ is annotated by the dependencies
%% responsible for its presence in an environment.
%% }

%% For each of these, the accompanying dependency set is the ``reason''
%% set for the annotated static semantics to be in an environment.


An internal type $\CONSconsty{\METAnamety}{\METAlabty}$ is a
%
\index{type construction}%
%
\emph{type construction} and is built from an internal type constructor
$\METAnamety$ and its argument $\METAlabty$ (such as the polymorphic
list type
$\CONSconsty{\mbox{\inexamplebody{list}}}{\mbox{\inexamplebody{'a}}}$,
where \inexamplebody{'a} is an explicit type variable in \SML).
%
For simplicity's sake, in \CORETES\ external ($\METAtypename$)
and internal ($\METAnamety$) type constructors both take exactly one
argument (\FORMTES~\cite{Rahli:2011} handles non-unary type
constructors).
%
The special internal type constructor $\CONStyconnamearrow$ represents
the binary arrow type constructor ($\CONSarrowtySYMB$) during
constraint solving solely to allow constraints between
$\CONSarrowtySYMB$ and any unary type constructor.  This allows one to
compute the necessary portions of code when generating type errors.
%
A scheme is either a type scheme, a type constructor scheme or an
environment scheme.  Each depends on an environment because in our
system, types always stay shallow (event during constraint
solving)\footnote{For example, at initial constraint generation,
  instead of generating a
  constraint such as
  $(\csou
  {\METAtyvar}
  {\CONSarrowty{\METAtyvar_1}{(\CONSarrowty{\METAtyvar_2}{\METAtyvar_3})}})$,
  we would generate an environment of the form
  $\CONSenvenv
  {(\csou{\METAtyvar}{\CONSarrowty{\METAtyvar_1}{\METAtyvar'}})}
  {(\csou{\METAtyvar'}{\CONSarrowty{\METAtyvar_2}{\METAtyvar_3}})}$.
  During constraint solving, instead of generating at type scheme of
  the form
  $\CONScsscheme
  {\{\METAtyvar_1,\METAtyvar_2,\METAtyvar_3\}}
  {\CONSenvnul}
  {(\CONSarrowty{\METAtyvar_1}{(\CONSarrowty{\METAtyvar_2}{\METAtyvar_3})})}$,
  we would generate a type scheme of the form
  $\CONScsscheme
  {\{\METAtyvar_1,\METAtyvar_2,\METAtyvar_3,\METAtyvar'\}}
  {\csou{\METAtyvar'}{\CONSarrowty{\METAtyvar_2}{\METAtyvar_3}}}
  {(\CONSarrowty{\METAtyvar_1}{\METAtyvar'})}$.}.
%
Our schemes and existential environments are subject to
alpha-conversion.  For example,
$\CONScsscheme{\{\METAtyvar\}}{\CONSenvnul}{\METAtyvar}$ is convertible to
$\CONScsscheme{\{\METAtyvar'\}}{\CONSenvnul}{\METAtyvar'}$.  These two terms are
considered equal.

%% Our type schemes are not subject to alpha-conversion.  For example,
%% $\CONSscheme{\{\METAtyvar\}}{\METAtyvar}$ is not convertible to
%% $\CONSscheme{\{\METAtyvar'\}}{\METAtyvar'}$.
%% %
%% \tocheck{The only reason is that in Sec.~\ref{sec:functors}, we extend the form
%% of our type schemes and sometimes allow to reverse the generalisation
%% process of a type to a type scheme (see the function
%% $\MEMgenparamSYMB$ defined in Fig.~\ref{fig:genparams}).}
%%%% TODO: why not?

%%% Having $\SETlabtyp\subset\SETscheme$ simplifies the presentation.

%% A binder of the form
%% $\CONSbindu{\METAid}{\METAtyvar}$, is an unconfirmed binder that
%% can either be confirmed to be a binder of a value variable at
%% constraint solving time, and so be turned into a binder of the form
%% $\CONSbind{\METAid}{\METAtyvar}$ or be turned into an accessor
%% $\CONSacc{\METAid}{\METAtyvar}$ if it turns out that $\METAid$ is a
%% datatype constructor.
%% %
%% \nnewtext{Such unconfirmed binders are initially generated for identifiers
%% occurring in patterns.  The status of such an identifier is context
%% dependent.  Therefore in order to design a compositional constraint
%% generation algorithm, thanks to these unconfirmed binders, the
%% resolution of identifiers' statuses is delayed to be dealt with at
%% constraint solving.}
%% %
%% This mechanism is further illustrated in
%% Sec.~\ref{sec:unification}.

A \emph{constraint/environment}
%
\index{constraint/environment}%
%
$\METAcsenv$ is a hybrid that acts as
both a \emph{constraint} and an \emph{environment}, and we will freely
switch between these terms when discussing them.
A major novelty is three of the constraint/environment forms, and
their interaction:
%
\index{constraint/environment!binder}%
%
\emph{binders}
($\CONSbind{\METAgenid}{\METAscheme}$, with metavariable $\METAbind$), \emph{\COMPENVS}
($\CONSenvenv{\METAcsenv_2}{\METAcsenv_1}$), and
%
\index{constraint/environment!accessor}%
%
\emph{accessors}
($\CONSacc{\METAgenid}{\METAvar}$, with metavariable $\METAacc$).
A binder $\CONSbind{\METAgenid}{\METAscheme}$ or an accessor
$\CONSacc{\METAgenid}{\METAvar}$ is used for program occurrences of
$\METAgenid$ that are respectively binding or bound.
%
\index{constraint/environment!composition environment@\COMPE}%
%
The \COMPE\ $\CONSenvenv{\METAcsenv_2}{\METAcsenv_1}$ is used when the
accessors of $\METAcsenv_2$ are in the scope of the binders of
$\METAcsenv_1$, and acts like a logical conjunction requiring
$\METAcsenv_1$ to be satisfied, and $\METAcsenv_2$ to be satisfied
when the bindings of $\METAcsenv_1$ are in scope.
%% references of the form $\CONSaccid{\METAgenid}$ (accessors) and $\CONSbindid{\METAgenid}$ (binders)
For example, in
$\CONSenvenv{\CONSacc{\METAid}{\METAtyvar}}{\CONSbind{\METAid}{\METAityscheme}}$,
the type variable $\METAtyvar$ is constrained to be an instance of
$\METAityscheme$ through the binding of $\METAid$.
%
Binders and accessors do not need to be next to each other.
For example, in
$\CONSenvenv
{\CONSenvenv
  {\CONSenvenv
    {\CONSenvenv
      {\CONSacc{\METAid}{\METAtyvar_2}}
      {\cdots}
    }
    {\CONSacc{\METAid}{\METAtyvar_1}}
  }
  {\cdots}
}
{\CONSbind{\METAid}{\CONScsscheme{\METAtyvarset}{\CONSenvnul}{\METAlabty}}}$,
if the ellipses do not shadow $\METAid$'s binder (e.g., if they
are equality constraints) then
% the semantics of
this constraint/environment
% is equivalent to the semantics of
has same solvability as
% (but not same solutions because $\METAren_1$ and $\METAren_2$
% introduce fresh variables)
$\CONSenvenv
{\CONSenvenv
  {\CONSenvenv
    {\CONSenvenv
      {\csou{\MEMrenaming{\METAren_2}{\METAlabty}}{\METAtyvar_2}}
      {\cdots}
    }
    {\csou{\MEMrenaming{\METAren_1}{\METAlabty}}{\METAtyvar_1}}
  }
  {\cdots}
}
{\CONSbind{\METAid}{\CONScsscheme{\METAtyvarset}{\CONSenvnul}{\METAlabty}}}$ where
the two accessors have been resolved by accessing the corresponding binder,
and where the two renamings $\METAren_1$ and $\METAren_2$ rename
the type variables in $\METAtyvarset$ to fresh variables
in order to instantiate the type
scheme $\CONScsscheme{\METAtyvarset}{\CONSenvnul}{\METAlabty}$.
We have
$\MEMdom{\METAren_1}=\MEMdom{\METAren_2}=\METAtyvarset$ and, among
other properties it holds that
$\MEMdisj{\MEMran{\METAren_1},\MEMran{\METAren_2}}$.
%
The shadowing mechanism is further discussed in Sec.~\ref{sec:unification}.
%
The motivation for these constraint/environments is to have a general
mechanism to build environments for sequential declarations that
avoids duplications at initial constraint generation or during
constraint solving.

The operator $\CONSenvenvSYMB$ is used to compose environments.  We
consider $\CONSenvenvSYMB$ to be associative (i.e.,
$(\CONSenvenv{(\CONSenvenv{\METAcsenv_3}{\METAcsenv_2})}{\METAcsenv_1})$
is considered to be equivalent to
$(\CONSenvenv{\METAcsenv_3}{(\CONSenvenv{\METAcsenv_2}{\METAcsenv_1})})$)
with unit $\CONSenvnul$ (i.e.,
$(\CONSenvenv{\METAcsenv}{\CONSenvnul})$,
$(\CONSenvenv{\CONSenvnul}{\METAcsenv})$ and $\METAcsenv$ are all
equivalent).
Also, let $\CONSenvenv{\METAcs_2}{\METAcs_1}$ be equivalent to
$\CONSenvenv{\METAcs_1}{\METAcs_2}$.

%%% NOTE (jbw): Also consider
%%% $(\CONSenvenv{\CONSbind{\METAgenid_2}{\METAvar_2}}{\CONSbind{\METAgenid_1}{\METAvar_1}})
%%% =(\CONSenvenv{\CONSbind{\METAgenid_1}{\METAvar_1}}{\CONSbind{\METAgenid_2}{\METAvar_2}})$
%%% if $\METAgenid_1\not=\METAgenid_2$,
%%% and
%%% $(\CONSenvenv{\CONSbind{\METAgenid}{\METAvar_2}}{\CONSbind{\METAgenid}{\METAvar_1}})
%%% =\CONSbind{\METAgenid}{\METAvar_2}$.
%%% These equations only work when the RHS's are $\METAvar$'s.
%%% If we had existentials we could do this:
%%% $(\CONSbind{\METAgenid}{x})
%%% =\existsexp{\METAvar}{(\CONSenvenv{\CONSbind{\METAgenid}{\METAvar}}{\csou{\METAvar}{x}})}$
%%% where $\METAvar$ and $x$ have the same sort.

A constraint/environment can also be (1)~the empty environment and
satisfied constraint $\CONSenvnul$, (2)~a constraint/environment
variable $\METAenvvar$, (3)~an equality constraint $\METAcs$, (4)~a
special form $\CONStopoly{\METAcsenv}$ which promotes bindings in
$\METAcsenv$ to be polymorphic (see below),
% in this section,
%an accessor $\CONSsems{\METAstrid}{}$,
(5)~an existential environment $\CONSexistsenv{\METAatom}{\METAcsenv}$
which binds every $\METAatom$ occurring free in $\METAcsenv$,
or (6)~a conditional environment $\CONSdeps{\METAcsenv}{\METAcdepset}$
which acts like $\METAcsenv$ if the dependencies in $\METAcdepset$ are
satisfied and otherwise acts (mostly) like $\CONSenvnul$.
%
Sec.~\ref{sec:semantics-constraint-envs} provides the semantics of our
constraint/environments.

Binders and accessors are related to ideas in earlier systems, e.g.,
Pottier and R\'{e}my's let-constraints and type scheme
instantiations~\cite{Pottier+Remy:2005}.
The earlier systems are too restrictive to easily represent module
systems because they only support very limited cases of what our
binders do and they lack environment variables.
%Sequence environments of
%the form $\CONSenvenv{\METAcsenv_2}{\METAcsenv_1}$ can be regarded as
%an extension of Hage and Heeren's
%strict nodes~\cite{Hage+Heeren:2005a,Hage+Heeren:2009,Heeren+Hage+Swierstra:2003a,Heeren:2005}
%to handle identifiers' bindings.
%Pottier and Remy's let constraints can also be seen as strict nodes.
We know of no other system with these features.
With our constraints we can easily define a
compositional constraint generator.
Sec.~\ref{sec:comparisonsConSys} provides a comparison with related
constraint systems.

%% Let $\CONSenvenvn{\METAcsenv_n}{}{\METAcsenv_1}$ be $\CONSenvnul$ if
%% $n=0$ and
%% $\CONSenvenv{\METAcsenv_n}{(\CONSenvenvn{\METAcsenv_{n-1}}{}{\METAcsenv_1})}$
%% if $n>0$.


%% The environments of the form $\CONStopoly{\METAcsenv}$ are explained
%% below.
%% %% in Sec.~\ref{sec:constraintgen}

%% \hidden{Throughout this paper we consider the variables $\METAtyvar_0$,
%% $\METAtynamevar_0$
%% %%, $\METAseqvar_0$
%% and $\METAenvvar_0$ (see the
%% definitions of $\MEMtrimreboundenvSYMB$ and $\MEMcsprojSYMB$ for more
%% details on their use) as
%% distinguished variables that are never generated at constraint
%% generation and that are never unified at unification.  These variables
%% should be introduced as constants but we do not
%% formalise this part of our type error slicer in order to keep the
%% presentation of the algorithms simple.}

\mynote{(2010-03-30)}{We need the distinction between $\CONSstatusu$
  and $\CONSstatusa$ because $\CONSstatusu$ is used unconfirmed
  monomorphic environments which is not compatible with a datatype
  constructor while $\CONSstatusa$ is compatible with any status.  We
  need the distinction between $\CONSstatusv$ and $\CONSstatusu$ because
  $\CONSstatusv$ is for confirmed value variables in an environment and
  $\CONSstatusu$ is for the unconfirmed ones and for those we only want
  to confirm them during constraint solving only if in the current
  environment we have a confirmed one ($\CONSstatusv$).  Otherwise for
  \inexamplebody{fn f => fn f => f} we would have the second
  \inexamplebody{f} in the environment only if the first one is.}

\mynote{(2010-04-06)}{We could generalise $\CONStopoly{\METAcsenv}$ to
  accept any function on environment.}

\mynote{(2010-04-06)}{An empty $\METAbind$ is like an empty constraint
  set: its an empty environment.  We have two ways to have an empty
  environment which is not nice.  Actually an infinite way because of
  $\CONSenvenv{\METAcsenv_1}{\METAcsenv_2}$.}


\subsubsection{Atoms}
%
Let $\MEMsomeforms{x}$ be the syntactic form set belonging to
$\SETatom$ and occurring in $x$ whatever $x$ is.
%
We define the following functions:
\begin{center}
  \begin{\sizeintables}
    \begin{tabular}{ l l l l }
      $\MEMvarset{x}$
      & $=$
      & $\MEMsomeforms{x}\cap\SETvar$
      & (set of variables)
      \\

      $\MEMlabelset{x}$
      & $=$
      & $\MEMsomeforms{x}\cap\SETlab$
      & (set of labels)
      \\

      $\MEMdepset{x}$
      & $=$
      & $\MEMsomeforms{x}\cap\SETdependency$
      & (set of dependencies)
    \end{tabular}
  \end{\sizeintables}
\end{center}

We also define
$\MEMfreevarset{x}$ as the variables occurring in $\MEMvarset{x}$,
that are not in the scope of a bound variable:
$\MEMfreevarset
{\CONSexistsenv{\METAtyvar}{\csou{\METAtyvar}{\METAtyvar}}}
=\emptyset$
and
$\MEMfreevarset
{\CONSenvenv
  {\csou{\METAtyvar}{\METAtyvar_2}}
  {(\CONSexistsenv{\METAtyvar}{\csou{\METAtyvar}{\METAtyvar_1}})}
}
=\{\METAtyvar,\METAtyvar_2\}$,

%% In our simple context, dependency can only be labels, but
%% dependencies are extended in Sec.~\ref{sec:idstatuses}.

\mynote{(2010-04-12)}{In $\MEMsomeforms{x}$, $x$ can be a set of
  syntactic forms as well.}

%% \mynote{(2010-04-22)}{The only place $\MEMtynamesetSYMB$ is used is in
%%   $\MEMdisjvsSYMB$ just below}

%% Let
%% $\MEMdisjvs{x_1,\dots,x_n}\iff\MEMdisj{\MEMsomeforms{x_1},\dots,\MEMsomeforms{x_n}}$.

\mynote{(2010-04-23)}{With $\MEMdisjvsSYMB$ the uniqueness of labels in
  a term should be ensured by our constraint generator.}



%% \subsubsection{Freshness}  %%of variables
%% %
%% We use distinguished dummy variables:
%% %%Let
%% $\SETfreshvar=\{\CONSfreshvar{\METAtyvar},\CONSfreshvar{\METAenvvar},\CONSfreshvar{\METAtynamevar}\}$.
%% %% $\CONSfreshvar{\METAtyvar}$, $\CONSfreshvar{\METAenvvar}$ and $\CONSfreshvar{\METAtynamevar}$.
%% Each use of a dummy variable acts like a fresh variable.
%% These variables are used to generate dummy environments and
%% constraints.
%% \tocheck{For example, in
%% $\CONSenvenv
%% {(\csou{\CONSfreshvar{\METAtyvar}}{\METAtyvar_2})}
%% {(\csou{\CONSfreshvar{\METAtyvar}}{\METAtyvar_1})}$,
%% the two occurrences of $\CONSfreshvar{\METAtyvar}$ can be thought of as
%% type variables different from each other and also different from
%% $\METAtyvar_1$ and $\METAtyvar_2$.}
%% %
%% % and simplify the generation of unused ``fresh''
%% % variables (variables that will never be constrained to anything).
%% %
%% %
%% Note that variable freshness is not handled via existential
%% constraints as in other
%% systems~\cite{Gustavsson+Svenningsson:2001,Muller:1994,Pottier+Remy:2005}.
%% %
%% %% We believe existential constraints tend to cloud constraints with
%% %% extra syntax.
%% %
%% Instead the relation $\MEMdisjvsSYMB$ ensures the freshness of the
%% generated variables and type constructor names:
%% $\MEMdisjvs{x_1,\dots,x_n}
%% \iff
%% \MEMdisj{\afunc{\METAfun}{x_1},\dots,\afunc{\METAfun}{x_n},\SETfreshvar}$,
%% where $\afunc{\METAfun}{x}=\MEMsomeforms{x}\setminus\SETid$.
%% This also ensures that each label occurs at most once in a labelled program.
%% Let us define $\MEMnondumvarsetSYMB$ as follows:
%% $\MEMnondumvarset{x}=\MEMvarset{x}\setminus\SETfreshvar$.



\subsubsection{Syntactic sugar}
%
We write
$\CONSscheme{\METAvarset}{\METAcsterm}$ for
$\CONScsscheme{\METAvarset}{\CONSenvnul}{\METAcsterm}$.
We write
$\CONSbind{\METAgenid}{\METAcsterm}$ for
$\CONSbind{\METAgenid}{\CONSscheme{\emptyset}{\METAcsterm}}$.
%
We write
$\CONSexistsenv{\mytuple{\METAatom_1,\dots,\METAatom_n}}{\METAcsenv}$
for
$\CONSexistsenv{\METAatom_1}{\cdots\CONSexistsenv{\METAatom_n}{\METAcsenv}}$.
%
%% We write $\csou{x_1}{x_2}$ for an equality constraint ($\METAcs$) or a
%% binding ($\METAbind$) of the form $\dcso{x_1}{x_2}$.
%
We write $\CONSdeps{\METAcsterm}{\METAcdep}$
for $\CONSdeps{\METAcsterm}{\{\METAcdep\}}$.
%
If $y$ is a $\METAcdep$ or a $\METAcdepset$,
%
then
$\CONSdepss{\METAcsterm}{y}$ abbreviates $\CONSdeps{\METAcsterm}{y}$,
%
and $\cso{\METAcsterm_1}{\METAcsterm_2}{y}$
abbreviates $\CONSdeps{\csou{\METAcsterm_1}{\METAcsterm_2}}{y}$,
and similarly for binders and accessors.
%
%% $\CONSbindl{\METAgenid}{x}{y}$ for
%% $\CONSdeps{\CONSbind{\METAgenid}{x}}{y}$,
%% $\CONSbindul{\METAgenid}{x}{y}$ for
%% $\CONSdeps{\CONSbindu{\METAgenid}{x}}{y}$, and
%% $\CONSaccl{\METAgenid}{x}{y}$ for
%% $\CONSdeps{\CONSacc{\METAgenid}{x}}{y}$.
%
%% We write $\CONSbindl{\METAid}{\mytuple{\METAscheme,\METAstatus}}{y}$
%% for $\CONSenvenv{\CONSbindl{\METAid}{\METAscheme}{y}}{\CONSbindl{\METAid}{\METAstatus}{y}}$,
%% and similarly for accessors.
%% and $\CONSaccl{\METAid}{\mytuple{\METAtyvar,\METArawstatus}}{y}$
%% for $\CONSenvenv{\CONSaccl{\METAid}{\METAtyvar}{y}}{\CONSaccl{\METAid}{\METArawstatus}{y}}$.
%
%% We write $\CONSbindl{\METAgenid}{x}{\emptyset}$ for
%% $\CONSbind{\METAgenid}{x}$.
%
%% We write
%% $\CONSscheme{\mytuple{\METAtyvar_1,\dots,\METAtyvar_n}}{\METAlabty}$
%% for
%% $\CONSscheme{\METAtyvar_1}{\dots\CONSscheme{\METAtyvar_n}{\METAlabty}}$.
%
%We write $\METAlabty$ for $\CONSscheme{\emptyset}{\METAlabty}$.
%
%% We write
%% $\CONSdepss{\CONSvidsem{\CONSscheme{\METAtyvarset}{\METAlabty}}{\METAstatus}}{y}$
%% for $\CONSvidsem{\CONSscheme{\METAtyvarset}{\CONSdepss{\METAlabty}{y}}}{\CONSdepss{\METAstatus}{y}}$.
%
%% We write
%% $\csou{\mytuple{\METAlabty_1,\METAstatus_1}}{\mytuple{\METAlabty_2,\METAstatus_2}}$
%% for
%% $\CONSenvenv{(\csou{\METAlabty_1}{\METAlabty_2})}{(\csou{\METAstatus_1}{\METAstatus_2})}$.
%
%% \mynote{(2010-05-07)}{This last syntactic sugar is only used in the
%%   environment solver to save space there.}
%
%
Let $\csbind{\METAcsenv}$ abbreviate
$\CONSexistsenv{\METAenvvar}{(\csou{\METAenvvar}{\METAcsenv})}$ such
that $\METAenvvar$ does not occur in $\METAcsenv$, a
constraint that enforces the logical constraint nature of $\METAcsenv$
while limiting the scope of its bindings (they can still have an
effect if $\METAcsenv$ constrains some environment variable).
%% where $\MEMdisjvs{\METAenvvar,\CONSenvenv{\METAcsset}{\METAcsenv}}$,
%% i.e., $\METAenvvar$ is fresh.
%
% (inspired by Pottier and R\'{e}my's let-constraints)
This is used for local bindings by rules $\MEMgencgruleb$ and
$\MEMgencgruled$ of our
initial constraint generation algorithm defined in Fig.~\ref{fig:consGenAlgo}.

%% We write
%% $\cso{x_1}{x_2}{\METAcdepset}$ for the environment
%% $\dcso{\ucso{x_1}{x_2}}{\METAcdepset}$
%% and $\csol{x_1}{x_2}{\METAlab}$ for $\cso{x_1}{x_2}{\{\METAlab\}}$.

%
%% We extract the term on the left-hand-side of a constraint as follows:
%% $\MEMfirstcs{\METAcs}=\afunc{\afunc{\METAcs}{0}}{0}$ (used by our
%% unification algorithm).
%% %% and $\MEMsecondcs{\METAcs}=x_2$

%% We always write
%% $\CONSarrowty{\METAlabty_1}{\METAlabty_2}$
%% instead of
%% $\CONSconsty{\MEMtyarrow}{\mytuple{\METAlabty_1,\METAlabty_2}}$.

%% When a relation is defined on constraint sets only and not on all
%% environments, we
%% sometimes write $\METAcsenv$ for
%% $\csbind{\METAcsenv}{\emptyset}$.  For example,
%% $\MEMissuccess{\METAcsenv}$ stands for
%% $\MEMissuccess{\csbind{\METAcsenv}{\emptyset}}$ where
%% $\MEMissuccessSYMB$ is defined at the end of Sec.~\ref{sec:unification}.

\mynote{2010-03-17}{Because $\METAenvvar$ is a fresh environment
  variable, we should have constraints such as:
  $\csoe{\METAenvvar}{\CONSenvenv{\CONSenvenv{\emptyset}{\METAcsset}}{\METAcsenv}}{\METAlabset}{\METAidset}{\METAenvvar}$.
  Or instead of $\METAenvvar$ we could have a
  $\CONSsems{\METAstrid}{\METAlab}$ using a dummy $\METAstrid$.}

\mynote{2010-03-17}{In $\CONSenvenv{\METAcsenv}{\METAcsorenv}$ no
  variable (in $\SETvar$) is visible from outside the environment.
  So, when unifying a $\CONSenvenv{\METAcsenv}{\METAcsorenv}$ we could
  rename all the variables (or even during constraint generation) and
  consider $\csbind{\METAcsenv}{\METAcsset}$ as syntactic sugar for
  $\cso{\METAenvvar}{\CONSenvenv{\METAenvvar}{\{\cso{\METAenvvar'}{\CONSenvenv{\CONSenvenv{\emptyset}{\METAcsset}}{\METAcsenv}}{\METAlabset}{}{\METAidset}\}}}{\emptyset}{}{\emptyset}$
  where the only requirement would be that
  $\MEMdisjvs{\METAenvvar,\METAenvvar',\METAcsenv,\METAcsset}$.}

%% The sets $\SETtyvar$ and $\SETmonotyvar$ are such that there exists a
%% bijection $\CONSpolytomonoSYMB$ from $\SETtyvar$ to $\SETmonotyvar$.

%%  and $\CONSstatusa$ is a
%% status that can be associated to any kind of identifier.  This last
%% status is used during unification and is associated to identifiers
%% pushed to the top-level environment when opening an incomplete
%% structure.

%% In a $\METAbindv$, $\METAbindt$, $\METAbinds$ or an equality
%% constraint, the second label set is to retain environment information
%% that are not going to be part of the slice displayed to the user.

%% \mynote{2010-02-12}{In an environment, true means that the environment
%%   is complete.  It can be incomplete when composing environment during
%%   unification. \mynote{2010-03-05}{I got rid of that because we can
%%     use the label sets.  In the environment part of the unifier,
%%     during unification, if a label set labelling an environment is
%%     empty then it means that it is incomplete.}}


%% \intitle{Free variables.}
%% %
%% \begin{center}
%%   \begin{tabular}{ l l l }
%%     $\MEMfreevars{\CONSenvenv{\METAcsenv}{\METAcsorenv}}$
%%     & $=$
%%     & $\MEMfreevars{\METAcsenv}\setminus\MEMfreevars{\METAcsorenv}$
%%     \\

%%     $\MEMfreevars{\METAenvvar}$
%%     & $=$
%%     & $\{\METAenvvar\}$
%%     \\

%%     $\MEMfreevars{\METAbind}$
%%     & $=$
%%     & $\cup_{\METAgenid\in\MEMdom{\METAbind}}\MEMfreevars{\afunc{\METAbind}{\METAgenid}}$
%%     \\

%%     $\MEMfreevars{\CONSsems{\METAstrid}{\METAlab}}$
%%     & $=$
%%     & $\emptyset$
%%     \\

%%     $\MEMfreevars{\METAcsset}$
%%     & $=$
%%     & $\cup_{\METAcs\in\METAcsset}\MEMfreevars{\METAcs}$
%%     \\

%%     $\MEMfreevars{\cso{\METAcsenv_1}{\METAcsenv_2}{\METAlabset}{}{\METAidset}}$
%%     & $=$
%%     & $\MEMfreevars{\METAcsenv_1}\cup\MEMfreevars{\METAcsenv_2}$
%%     \\

%%     $\MEMfreevars{\cso{x_1}{x_2}{\METAlabset}{}{\METAidset}}$
%%     & $=$
%%     & $\MEMvarset{x_1}\cup\MEMvarset{x_2}$
%%     if $x_1,x_2\not\in\SETcsenv$
%%   \end{tabular}
%% \end{center}




%% \intitle{Domain of an environment.}
%% %
%% Let the domain of an environment be defined as follows:
%% \begin{center}
%%   \begin{tabular}{lrl}
%%     $\MEMdom{\METAcsenv}$
%%     & $=$
%%     & $\left\{
%%     \begin{array}{ l l }
%%       \MEMdom{\METAbind}
%%       &
%%       \mbox{if }\METAcsenv=\METAbind
%%       \\
%%       \MEMdom{\METAcsenv'}
%%       &
%%       \mbox{if }\METAcsenv=\MEMenvcs{\METAcsenv'}{\METAcsorenv}
%%       \\
%%       \mbox{undefined}
%%       &
%%       \mbox{otherwise}
%%     \end{array}
%%     \right.$
%%   \end{tabular}
%% \end{center}

%% \mynote{2010-03-19}{We don't use the domain of an environment anymore.}


\subsection{\SECsemantics}
\label{sec:semantics-constraint-envs}



\subsubsection{Renamings, unifiers, and substitutions}




\begin{\myfigure}[t]
  \begin{\sizeintables}

    %% %\vspace*{-0.05in}
    %% \begin{tabular}{rclrl}
    %% \vspace*{0.04in}
    %% \mytitle{renamings, unifiers and substitutions}

    \begin{tabular}{ r c l r l }

      $\METAren$           & $\in$ & $\SETren$           & $=$    & $\{\METAren\in\func{\SETtyvar}{\SETtyvar}\mid\METAren\mbox{ is injective}\wedge\MEMdisj{\MEMdom{\METAren},\MEMran{\METAren}}\}$\\

      $\METAunifstatety$   & $\in$ & $\SETunifstatety$   & $=$    & $\{\METAfun_1\cup\METAfun_2\cup\METAfun_3
                                                                     \mid\METAfun_1\in\func{\SETtyvar}{\SETlabtyp}
                                                                     \wedge\METAfun_2\in\func{\SETtynamevar}{\SETnametyp}
                                                                     \wedge\METAfun_3\in\func{\SETenvvar}{\SETcsenv}\}$\\
%%                     &       &                     &        &  $\hspace*{0.85in}\wedge\METAfun_3\in\func{\SETseqvar}{\SETexttyseqid}$

      $\METAsub$           & $\in$ & $\SETsub$           & $=$     & $\{\METAfun_1\cup\METAfun_2\mid\METAfun_1\in\SETunifstatety\wedge\METAfun_2\in\func{\SETtycon}{\SETtycon}\}$\\

      $\METAunifstate$     & $\in$ & $\SETunifstate$     & $::=$  & $\MEMconsStateEnvp{\METAunifstatety}{\METAcsenv}{\METAtvbinder}$
    \end{tabular}

  \end{\sizeintables}
  \caption{Renamings, unifiers, and substitutions}
  \label{fig:ren-uni-sub}
\end{\myfigure}

Fig.~\ref{fig:ren-uni-sub} defines renamings, unifiers and
substitutions.
%
One can observe that
$\SETren\subset\SETunifstatety\subset\SETsub$.
%
Renamings are used to instantiate schemes.
%
%
%% Note that in Fig.~\ref{fig:ren-uni-sub},
%% $\SETsub=\SETunifstatety$.  These two sets will be extended in
%% Ch.~\ref{sec:extensions} such that they will be different.
The set
$\SETunifstatety$ is generally the set of unifiers generated by our
constraint solver defined in Sec.~\ref{sec:unification}.
%
%% Substitutions are extended in \FORMTES\ such that
%% $\SETunifstatety\subset\SETsub$.
%% We also use
%% the distinct set $\SETsub$ because we sometimes need to substitute
%% more syntactic forms than allowed by unifiers.  For example, in
%% Sec.~\ref{sec:signatures} we need to to substitute rigid type variables
%% (introduced in Sec.~\ref{sec:signatures} as well) when instantiating
%% type schemes (type schemes are also extended in
%% Sec.~\ref{sec:signatures}).  Rigid type variables are not allowed to
%% be in the domain of a unifier during constraint solving (because, as
%% explained in Sec.~\ref{sec:signatures}, they act as constant types).

The application of a substitution $\METAsub$ (and therefore of a
unifier $\METAunifstatety$ and a renaming $\METAren$) to a constraint
term is defined as follows:
\begin{center}
  \begin{\sizeintables}
    \begin{tabular}{lll}
      $\MEMsubstitution{\METAsub}{\METAatom}$
      & $=$
      & $\left\{
      \begin{array}{ll}
        x,
        &
        \mbox{if }\afunc{\METAsub}{\METAatom}=x
        \\
        \METAatom,
        &
        \mbox{otherwise}
      \end{array}
      \right.$
      \\

      $\MEMsubstitution{\METAsub}{(\CONSconsty{\METAnamety}{\METAlabty})}$
      & $=$
      & $\CONSconsty{\MEMsubstitution{\METAsub}{\METAnamety}}{\MEMsubstitution{\METAsub}{\METAlabty}}$
      \\

      $\MEMsubstitution{\METAsub}{(\CONSarrowty{\METAlabty_1}{\METAlabty_2})}$
      & $=$
      & $\CONSarrowty{\MEMsubstitution{\METAsub}{\METAlabty_1}}{\MEMsubstitution{\METAsub}{\METAlabty_2}}$
      \\

      $\MEMsubstitution{\METAsub}{\CONSdepss{\METAcsterm}{\METAcdepset}}$
      & $=$
      & $\CONSdepss{\MEMsubstitution{\METAsub}{\METAcsterm}}{\METAcdepset}$
      \\

      $\MEMsubstitution{\METAsub}{(\csou{\METAcsterm_1}{\METAcsterm_2})}$
      & $=$
      & $(\csou{\MEMsubstitution{\METAsub}{\METAcsterm_1}}{\MEMsubstitution{\METAsub}{\METAcsterm_2}})$
      \\

      $\MEMsubstitution{\METAsub}{(\CONSenvenv{\METAcsenv_2}{\METAcsenv_1})}$
      & $=$
      & $\CONSenvenv{\MEMsubstitution{\METAsub}{\METAcsenv_2}}{\MEMsubstitution{\METAsub}{\METAcsenv_1}}$
      \\
    \end{tabular}
    \hspace{0.1in}
    \begin{tabular}{lll}
      $\MEMsubstitution{\METAsub}{(\CONScsscheme{\METAvarset}{\METAcsenv}{\METAcsterm})}$
      & $=$
      & $\CONScsscheme{\METAvarset}{\MEMsubstitution{\METAsub}{\METAcsenv}}{\MEMsubstitution{\METAsub}{\METAcsterm}}$
      s.t.\ $\MEMdisj{\METAvarset,\MEMsomeforms{\METAsub}}$
      \\

      $\MEMsubstitution{\METAsub}{(\CONSexistsenv{\METAatom}{\METAcsenv})}$
      & $=$
      & $\CONSexistsenv{\METAatom}{\MEMsubstitution{\METAsub}{\METAcsenv}}$
      s.t.\ $\MEMdisj{\{\METAatom\},\MEMsomeforms{\METAsub}}$
      \\
      %%% NOTE: The undefined case can only happen for infinite sub
      %%% because we have alpha-conversion

      $\MEMsubstitution{\METAsub}{(\CONSacc{\METAgenid}{\METAvar})}$
      & $=$
      & $\left\{
      \begin{array}{ll}
        (\CONSacc{\METAgenid}{\MEMsubstitution{\METAsub}{\METAvar}}),
        &
        \mbox{if }\MEMsubstitution{\METAsub}{\METAvar}\in\SETvar
        \\
        \mbox{undefined},
        &
        \mbox{otherwise}
      \end{array}
      \right.$
      \\

      $\MEMsubstitution{\METAsub}{(\CONSbind{\METAgenid}{\METAscheme})}$
      & $=$
      & $(\CONSbind{\METAgenid}{\MEMsubstitution{\METAsub}{\METAscheme}})$
      \\

      $\MEMsubstitution{\METAsub}{\CONStopoly{\METAcsenv}}$
      & $=$
      & $\CONStopoly{\MEMsubstitution{\METAsub}{\METAcsenv}}$
      \\

      $\MEMsubstitution{\METAsub}{x}$
      & $=$
      & $x$,
      otherwise
    \end{tabular}
  \end{\sizeintables}
\end{center}

Fig.~\ref{fig:ren-uni-sub} also defines \CONTEXTS\ (or just
\CCONTEXT\ for short).
%
A \emph{\CCONTEXT}
%
\index{constraint solving context@\CCONTEXT}%
%
$\METAunifstate=\MEMconsStateEnvp{\METAunifstatety}{\METAcsenv}{\METAtvbinder}$
is the context in which the meaning of constraint/environments
is defined w.r.t.\ the semantic rules provided below in
Sec.~\ref{sem:sem-cons-env-rules}.  Such forms are also used in our
constraint solver defined in Sec.~\ref{sec:unification} as contexts in
which the solvability of constraint/environments is checked.
%
In our system, unifiers and environments are complementary: unifiers
contain information on internal variables and environments on
external identifiers.
%
This is further stressed in Sec.~\ref{sec:env-application}, in the
definition of the application of a \CCONTEXT\ to an identifier.

Let
$\afunc{\MEMconsStateEnvp{\METAunifstatety}{\METAcsenv}{}}{\METAvar}
=\afunc{\METAunifstatety}{\METAvar}$,
let
$\CONSenvenv{\METAcsenv'}{\MEMconsStateEnvp{\METAunifstatety}{\METAcsenv}{}}
=\MEMconsStateEnvp{\METAunifstatety}{\CONSenvenv{\METAcsenv'}{\METAcsenv}}{}$,
let
$\MEMdom{\MEMconsStateEnvp{\METAunifstatety}{\METAcsenv}{}}
=\MEMdom{\METAunifstatety}$,
and let
$\MEMconsStateEnvp{\METAunifstatety}{\METAcsenv}{}\cup\METAunifstatety'
=\MEMconsStateEnvp{\METAunifstatety\cup\METAunifstatety'}{\METAcsenv}{}$.

\subsubsection{Shadowing and \CCONTEXT\ application}
\label{sec:env-application}


%
In a \CCONTEXT\ some parts might be shadowed and so inaccessible.
For example, in the \CCONTEXT\
$\MEMconsStateEnvp
{\METAunifstatety}
{\CONSenvenv
  {\METAbind_1}
  {\CONSenvenv
    {\METAenvvar}
    {\METAbind_2}
  }
}
{}$
where $\METAunifstatety=\emptyset$,
the binder $\METAbind_1$ is ``visible'' and $\METAenvvar$ shadows
$\METAbind_2$ because $\METAenvvar$ is not bound in $\METAunifstatety$,
($\METAenvvar\not\in\MEMdom{\METAunifstatety}$) and an environment
variable stands for any environment and could potentially bind any
identifier.
%
%
Let the predicate $\MEMhiddenSYMB$ be defined as follows:
\begin{center}
  \begin{\sizeintables}
    \begin{tabular}{lll}
      $\MEMhidden{\MEMconsStateEnvp{\METAunifstatety}{\METAcsenv}{}}$
      & $\iff$
      &
      $\left\{
      \begin{array}{llll}
        & (\METAcsenv=\METAenvvar
        & \wedge
        & (\MEMhidden{\MEMconsStateEnvp{\METAunifstatety}{\afunc{\METAunifstatety}{\METAenvvar}}{}}
        \vee
        \METAenvvar\not\in\MEMdom{\METAunifstatety}))
        \\
        \vee
        & (\METAcsenv=(\CONSenvenv{\METAcsenv_2}{\METAcsenv_1})
        & \wedge
        & (\MEMhidden{\MEMconsStateEnvp{\METAunifstatety}{\METAcsenv_1}{}}
        \vee
        \MEMhidden{\MEMconsStateEnvp{\METAunifstatety}{\METAcsenv_2}{}}))
        \\
        \vee
        & (\METAcsenv=\CONSdeps{\METAcsenv'}{\METAcdepset}
        & \wedge
        & \MEMhidden{\MEMconsStateEnvp{\METAunifstatety}{\METAcsenv'}{}})
        \\
        \vee
        & (\METAcsenv=\CONSexistsenv{\METAatom}{\METAcsenv'}
        & \wedge
        & \MEMhidden{\MEMconsStateEnvp{\METAunifstatety}{\METAcsenv'}{}}
        \wedge \METAatom\not\in\MEMdom{\METAunifstatety})
      \end{array}
      \right.$
      \\

      $\MEMhidden{\METAcsenv}$
      & $\iff$
      & $\MEMhidden{\MEMconsStateEnvp{\emptyset}{\METAcsenv}{}}$
    \end{tabular}
  \end{\sizeintables}
\end{center}

If $\MEMhidden{\METAcsenv}$ then it means that some of the binders in
$\METAcsenv$ might be shadowed, and especially it means that in
$(\CONSenvenv{\METAcsenv}{\METAcsenv'})$, the environment $\METAcsenv$
shadows the entire environment $\METAcsenv'$ (i.e., no binder from
$\METAcsenv'$ is accessible in $(\CONSenvenv{\METAcsenv}{\METAcsenv'})$).

Let us now present how to access the semantics of an identifier in an
environment.
%
The applications $\afunc{\METAunifstate}{\METAgenid}$ and
$\afunc{\METAcsenv}{\METAgenid}$ are defined as follows:
\begin{center}
\begin{\sizeintables}
  \begin{tabular}{lll}
    $\afunc{\MEMconsStateEnvp{\METAunifstatety}{\CONSbind{\METAgenid}{\METAscheme}}{}}{\METAgenid}$
    & $=$
    & $\METAscheme$
    \\

    $\afunc{\MEMconsStateEnvp{\METAunifstatety}{\CONSdepss{\METAcsenv}{\METAcdepset}}{}}{\METAgenid}$
    & $=$
    & $\CONScsscheme{\METAvarset}{\METAcsenv'}{\CONSdepss{\METAcsterm}{\METAcdepset}}$,
    if
    $\afunc{\MEMconsStateEnvp{\METAunifstatety}{\METAcsenv}{}}{\METAgenid}
    =\CONScsscheme{\METAvarset}{\METAcsenv'}{\METAcsterm}$
    \\

    $\afunc{\MEMconsStateEnvp{\METAunifstatety}{(\CONSenvenv{\METAcsenv_2}{\METAcsenv_1})}{}}{\METAgenid}$
    & $=$
    & $\left\{
    \begin{array}{ll}
      \afunc{\MEMconsStateEnvp{\METAunifstatety}{\METAcsenv_2}{}}{\METAgenid},
      &\mbox{if }\afunc{\MEMconsStateEnvp{\METAunifstatety}{\METAcsenv_2}{}}{\METAgenid}
      \mbox{ is defined}
      \\
      \mbox{undefined},
      &\mbox{if }\afunc{\MEMconsStateEnvp{\METAunifstatety}{\METAcsenv_2}{}}{\METAgenid}
      \mbox{ is undefined and }
      \MEMhidden{\MEMconsStateEnvp{\METAunifstatety}{\METAcsenv_2}{}}
      \\
      \afunc{\MEMconsStateEnvp{\METAunifstatety}{\METAcsenv_1}{}}{\METAgenid},
      &\mbox{otherwise}
    \end{array}
    \right.$
    \\

    $\afunc{\MEMconsStateEnvp{\METAunifstatety}{\METAenvvar}{}}{\METAgenid}$
    & $=$
    & $\left\{
    \begin{array}{l}
      \afunc{\MEMconsStateEnvp{\METAunifstatety}{\METAcsenv}{}}{\METAgenid},
      \mbox{if }
      \afunc{\METAunifstatety}{\METAenvvar}=\METAcsenv
      \\
      \mbox{undefined},
      \mbox{otherwise}
    \end{array}
    \right.$
    \\

    $\afunc{\METAcsenv}{\METAgenid}$
    & $=$
    & $\afunc{\MEMconsStateEnvp{\emptyset}{\METAcsenv}{}}{\METAgenid}$
  \end{tabular}
\end{\sizeintables}
\end{center}


\mynote{(2010-05-03)}{Before we had $\METAcsenv_1$ does not contain
  any variable instead of $\METAcsenv_1\not\in\SETvar$, but this is to
  restrictive because we can have variables in $\METAbind$s.}

For example,
\begin{center}
  \begin{\sizeintables}
    \begin{tabular}{l}
      $\afunc
      {(\CONSenvenv
        {\CONSbind{\METAstrid}{\METAcsenv}}
        {\CONSbind{\METAid}{\CONSscheme{\METAtyvarset}{\METAlabty}}})
      }
      {\METAid}
      =
      \CONSscheme{\METAtyvarset}{\METAlabty}$
      \\

      $\afunc
      {(\CONSenvenv
        {\CONSbind{\METAstrid}{\METAcsenv}}
        {\CONSenvenv
          {\METAenvvar}
          {\METAcsenv'}
        })
      }
      {\METAid}$
      is undefined
      \\

      $\afunc
      {(\CONSenvenv
        {\CONSbind{\METAstrid}{\METAcsenv}}
        {\CONSbind{\METAid}{\METAscheme}})
      }
      {\METAtypename}$
      is undefined
      \\

      $\afunc
      {\MEMconsStateEnvp
        {\{\asgn{\METAenvvar}{(\CONSbind{\METAid}{\CONSscheme{\METAtyvarset}{\METAlabty}})}\}}
        {(\CONSenvenv
          {\CONSbind{\METAstrid}{\METAcsenv}}
          {\CONSenvenv
            {\METAenvvar}
            {\METAcsenv'}
          })
        }
        {}
      }
      {\METAid}
      =\CONSscheme{\METAtyvarset}{\METAlabty}$
    \end{tabular}
  \end{\sizeintables}
\end{center}

The application of an existential environment to an identifier is
undefined because such an environment represents incomplete
information.


\subsubsection{Semantic rules}
\label{sem:sem-cons-env-rules}


\begin{figure}[t]
  \begin{\sizeintables}
    \begin{tabular}{llllll}
      %% \multicolumn{3}{l@{\hspace{0.1in}}}{
      %%   $\infer[\RULEsemTycomp]
      %%   {\CONScssemup
      %%     {\METAunifstatety}
      %%     {\METAcsenv}
      %%     {\METAcdepset_1}
      %%     {\METAcdepset_2}
      %%     {\CONSenvenv{\METAcsterm}{\METAcsenv_0}}
      %%     {\METAcsterm'}
      %%     {\METAunifstatety}
      %%   }
      %%   {
      %%     \METAcsterm\not\in\SETcsenv
      %%     &
      %%     \CONScssemup{\METAunifstatety}{\METAcsenv}{\METAcsdepset_1}{\METAcsdepset_2}{\METAcsenv_0}{\METAcsenv'_0}{}
      %%     &
      %%     \CONScssemup{\METAunifstatety}{\CONSenvenv{\METAcsenv'_0}{\METAcsenv}}{\METAcsdepset_1}{\METAcsdepset_2}{\METAcsterm}{\METAcsterm'}{}
      %%   }$
      %% }

      %% &

      %% \multicolumn{3}{l@{\hspace{0.2in}}}{
      %% $\infer[\RULEsemArrow]
      %% {\CONScssemup
      %%   {\METAunifstatety}
      %%   {\METAcsenv}
      %%   {\METAcdepset_1}
      %%   {\METAcdepset_2}
      %%   {\CONSarrowty{\METAlabty_1}{\METAlabty_2}}
      %%   {\CONSarrowty{\METAlabty'_1}{\METAlabty'_2}}
      %%   {\METAunifstatety}
      %% }
      %% {\forallexp{i\in\{1,2\}}{\CONScssemup{\METAunifstatety}{\METAcsenv}{}{}{\METAlabty_i}{\METAlabty'_i}{}}}$
      %% }

      %% \vspace{0.1in}
      %% \\

      %% \multicolumn{3}{l@{\hspace{0.1in}}}{
      %%   $\infer[\RULEsemTyname]
      %%   {\CONScssemup
      %%     {\METAunifstatety}
      %%     {\METAcsenv}
      %%     {\METAcdepset_1}
      %%     {\METAcdepset_2}
      %%     {\METAcsterm}
      %%     {\METAcsterm}
      %%     {\METAunifstatety}
      %%   }
      %%   {\METAcsterm\mbox{ is of the form }\METAtypename\mbox{ or }\CONStyconnamearrow}$
      %% }

      %% &

      %% \multicolumn{3}{l@{\hspace{0.2in}}}{
      %% $\infer[\RULEsemTycons]
      %% {\CONScssemup
      %%   {\METAunifstatety}
      %%   {\METAcsenv}
      %%   {\METAcdepset_1}
      %%   {\METAcdepset_2}
      %%   {\CONSconsty{\METAlabty}{\METAnamety}}
      %%   {\CONSconsty{\METAlabty'}{\METAnamety'}}
      %%   {\METAunifstatety}
      %% }
      %% {
      %%   \CONScssemup{\METAunifstatety}{\METAcsenv}{}{}{\METAlabty}{\METAlabty'}{}
      %%   &
      %%   \CONScssemup{\METAunifstatety}{\METAcsenv}{}{}{\METAnamety}{\METAnamety'}{}
      %% }$
      %% }

      %% \vspace{0.1in}
      %% \\

      \multicolumn{1}{l@{\hspace{0.2in}}}{
        $\infer[\RULEsemTrue]
        {\CONScssemup
          {\METAunifstatety}
          {\METAcsenv}
          {\METAcdepset_1}
          {\METAcdepset_2}
          {\CONSenvnul}
          {\CONSenvnul}
          {\METAunifstatety}
        }
        {}$
      }

      &

      \multicolumn{2}{l@{\hspace{0.2in}}}{
      $\infer[\RULEsemEvar]
      {\CONScssemup
        {\METAunifstatety}
        {\METAcsenv}
        {\METAcdepset_1}
        {\METAcdepset_2}
        {\METAenvvar}
        {\METAenvvar}
        {\METAunifstatety}
      }
      {}$
      }

      %% \multicolumn{2}{l@{\hspace{0.2in}}}{
      %% $\infer[\RULEsemEvar]
      %% {\CONScssemup
      %%   {\METAunifstatety}
      %%   {\METAcsenv}
      %%   {\METAcdepset_1}
      %%   {\METAcdepset_2}
      %%   {\METAenvvar}
      %%   {\METAcsenv'}
      %%   {\METAunifstatety}
      %% }
      %% {\CONScssemup{\METAunifstatety}{\METAcsenv}{}{}{\MEMsubstitution{\METAunifstatety}{\METAenvvar}}{\METAcsenv'}{}}$
      %% }

      %% &

      %% \multicolumn{3}{l}{
      %% $\infer[\RULEsemEvarp]
      %% {\CONScssemup
      %%   {\METAunifstatety}
      %%   {\METAcsenv}
      %%   {\METAcdepset_1}
      %%   {\METAcdepset_2}
      %%   {\METAenvvar}
      %%   {\MEMsubstitution{\METAunifstatety}{\METAenvvar}}
      %%   {\METAunifstatety}
      %% }
      %% {\METAvar\not\in\MEMdom{\METAunifstatety}}$
      %% }

      %% \vspace{0.1in}
      %% \\

      %% \multicolumn{3}{l}{
      %% $\infer[\RULEsemEeq]
      %% {\CONScssemup
      %%   {\METAunifstatety}
      %%   {\METAcsenv}
      %%   {\METAcdepset_1}
      %%   {\METAcdepset_2}
      %%   {(\csou{\METAcsterm_1}{\METAcsterm_2})}
      %%   {\CONSenvnul}
      %%   {\MEMsubstitution{\METAunifstatety''}{\METAunifstatety'}}
      %% }
      %% {\forallexp
      %%   {i\in\{1,2\}}
      %%   {\CONScssemup
      %%   {\METAunifstatety}
      %%   {\METAcsenv}
      %%   {\METAcdepset_1}
      %%   {\METAcdepset_2}
      %%   {\METAcsterm_i}
      %%   {\METAcsterm'_i}
      %%   {\METAunifstatety_i}}
      %%   &\METAcsterm'_1=\METAcsterm'_2
      %% }$
      %% }

      &

      \multicolumn{3}{l}{
      $\infer[\RULEsemEq]
      {\CONScssemup
        {\METAunifstatety}
        {\METAcsenv}
        {\METAcdepset_1}
        {\METAcdepset_2}
        {(\csou{\METAcsterm_1}{\METAcsterm_2})}
        {\CONSenvnul}
        {\MEMsubstitution{\METAunifstatety''}{\METAunifstatety'}}
      }
      {\forallexp
        {i\in\{1,2\}}
        {\CONScssemup
        {\METAunifstatety}
        {\METAcsenv}
        {\METAcdepset_1}
        {\METAcdepset_2}
        {\METAcsterm_i}
        {\METAcsterm'_i}
        {\METAunifstatety_i}}
        &\MEMsubstitution{\METAunifstatety}{\METAcsterm'_1}=\MEMsubstitution{\METAunifstatety}{\METAcsterm'_2}
      }$
      }

      \vspace{0.1in}
      \\

      \multicolumn{3}{l@{\hspace{0.2in}}}{
      $\infer[\RULEsemAcci]
      {\CONScssemup
        {\METAunifstatety}
        {\METAcsenv}
        {\METAcdepset_1}
        {\METAcdepset_2}
        {(\CONSacc{\METAgenid}{\METAvar})}
        {\CONSenvnul}
        {\METAunifstatety'}
      }
      {
        \MEMcsinsb{\afunc{\METAcsenv}{\METAgenid}}{\METAcsenv'}{\METAcsterm}
        &\CONScssemup
                 {\METAunifstatety}
                 {\METAcsenv}
                 {\METAcdepset_1}
                 {\METAcdepset_2}
                 {\CONSenvenv{(\csou{\METAcsterm}{\METAvar})}{\METAcsenv'}}
                 {\CONSenvnul}
                 {\METAunifstatety'}
      }$
      }

      &

      \multicolumn{3}{l@{\hspace{0.2in}}}{
      $\infer[\RULEsemAcco]
      {\CONScssemup
        {\METAunifstatety}
        {\METAcsenv}
        {\METAcdepset_1}
        {\METAcdepset_2}
        {(\CONSacc{\METAgenid}{\METAvar})}
        {\CONSenvnul}
        {\METAunifstatety}
      }
      {\afunc{\METAcsenv}{\METAgenid}\mbox{ undefined }}$
      }

      \vspace{0.1in}
      \\

      \multicolumn{3}{l@{\hspace{0.2in}}}{
      $\infer[\RULEsemBind]
      {\CONScssemup
        {\METAunifstatety}
        {\METAcsenv}
        {\METAcdepset_1}
        {\METAcdepset_2}
        {(\CONSbind{\METAgenid}{\METAcsterm})}
        {(\CONSbind{\METAgenid}{\MEMsubstitution{\METAunifstatety}{\METAcsterm}})}
        {\METAunifstatety}
      }
      {}$
      }


%%% NOTE: We only allow monomorphic binders here.

      &

      \multicolumn{3}{l}{
      $\infer[\RULEsemPoly]
      {\CONScssemup
        {\METAunifstatety}
        {\METAcsenv}
        {\METAcdepset_1}
        {\METAcdepset_2}
        {\CONStopoly{\METAcsenv'}}
        {\MEMtopolyu{\mytuple{\METAunifstatety,\METAcsenv}}{\METAcsenv''}}
        {\METAunifstatety'}
      }
      {
        \CONScssemup{\METAunifstatety}{\METAcsenv}{\METAcdepset_1}{\METAcdepset_2}{\METAcsenv'}{\METAcsenv''}{\METAunifstatety'}
      }$
      }

      \vspace{0.1in}
      \\

      \multicolumn{3}{l}{
      $\infer[\RULEsemComp]
      {\CONScssemup
        {\METAunifstatety}
        {\METAcsenv}
        {\METAcdepset_1}
        {\METAcdepset_2}
        {(\CONSenvenv{\METAcsenv_2}{\METAcsenv_1})}
        {(\CONSenvenv{\METAcsenv'_2}{\METAcsenv'_1})}
        {\METAunifstatety_2}
      }
      {
        \CONScssemup{\METAunifstatety}{\METAcsenv}{\METAcdepset_1}{\METAcdepset_2}{\METAcsenv_1}{\METAcsenv'_1}{\METAunifstatety_1}
        &\CONScssemup{\METAunifstatety}{(\CONSenvenv{\METAcsenv'_1}{\METAcsenv})}{\METAcdepset_1}{\METAcdepset_2}{\METAcsenv_2}{\METAcsenv'_2}{\METAunifstatety_2}
      }$
      }

      &

      \multicolumn{3}{l}{
      $\infer[\RULEsemEx]
      {\CONScssemup
        {\METAunifstatety}
        {\METAcsenv}
        {}
        {}
        {\CONSexistsenv{\METAatom}{\METAcsenv_1}}
        {\METAcsenv_2}
        {}
      }
      {
        \CONScssemup{\MEMuplus{\METAunifstatety}{\METAunifstatety'}}{\METAcsenv}{}{}{\METAcsenv_1}{\METAcsenv_2}{}
        &\MEMdom{\METAunifstatety'}=\{\METAatom\}
      }$
      }
    \end{tabular}
  \end{\sizeintables}
  \caption{Semantics of the constraint/environments, ignoring dependencies}
  \label{fig:cssem2}
\end{figure}


We now present the semantics of our constraint/environments.
%
First, let us define two $\MEMcsinsSYMB$ relations, used to
instantiate type schemes, as follows:
\begin{center}
  \begin{\sizeintables}
    \begin{tabular}{l@{\hspace{0.2in}}l@{\hspace{0.2in}}l}
      $\MEMcsinsa
      {\CONScsscheme{\METAvarset}{\METAcsenv}{\METAcsterm}}
      {\METAsub}
      {\MEMsubstitution{\METAsub}{\METAcsenv}}
      {\MEMsubstitution{\METAsub}{\METAcsterm}}$
      & if
      &
      $\MEMdom{\METAsub}=\METAvarset$
      \\

      $\MEMcsinsb{\METAscheme}{\METAcsenv}{\METAcsterm}$
      & if
      & $\existsexp{\METAsub}{\MEMcsinsa{\METAscheme}{\METAsub}{\METAcsenv}{\METAcsterm}}$
      %% \\
      %% $\MEMcsinsp{x}{\METAvarset}{x}$
      %% & if
      %% & $\MEMcollapse{\CONSdepss{x}{\emptyset}}$
      %% is not of the form
      %% $\CONSdepss{(\CONSscheme{\METAvarset}{y})}{\METAcdepset}$
    \end{tabular}
  \end{\sizeintables}
\end{center}

Let us define semantic judgements as follows:
\begin{center}
  \begin{\sizeintables}
    $\METAsemjudgement\in\SETsemjudgement::=\CONScssemup{\METAunifstatety}{\METAcsenv}{}{}{\METAcsenv_1}{\METAcsenv_2}{}$
  \end{\sizeintables}
\end{center}

Fig.~\ref{fig:cssem2} defines the semantics of
% (a subset of)
our constraint/environments, ignoring dependencies at first.
%
%% We explain below why the rules in Fig.~\ref{fig:cssem2} only define
%% the semantics of a subset of our constraint environments.
%
This figure uses the function $\MEMtopolySYMB$ which is
formally defined below in Fig.~\ref{fig:monotopoly} in
Sec.~\ref{sec:topoly}, and which
transforms monomorphic environments into polymorphic ones.
%%   The
%% function $\MEMtopolySYMB$ used in \CORETES\ (i.e., defined in
%% Fig.~\ref{fig:monotopoly}) can only be applied to a single dependent
%% value identifier binder.  Note that this function is extended in
%% Fig.~\ref{fig:topolyStatus} in Sec.~\ref{sec:solvingstatus} to deal
%% with environments composed of more than one binder.

We say that an environment $\METAcsenv$ is satisfiable
iff there exist
$\METAunifstatety$ and
$\METAcsenv'$ such that
$\CONScssemup
{\METAunifstatety}
{\CONSenvnul}
{\METAcdepset_1}
{\METAcdepset_2}
{\METAcsenv}
{\METAcsenv'}
{\METAunifstatety}$.
%
%% The environment $\METAcsenv'$ is the semantics of $\METAcsenv$ in the
%% environment $\CONSenvnul$.}
%context $\MEMconsStateEnvp{\METAunifstatety}{\CONSenvnul}{}$.}



Let us now consider the following environment which we call
$\METAcsenv_1$:
\begin{center}
  \begin{\sizeintables}
    $\CONSexistsenv
    {\mytuple{\METAtyvar_1,\METAtyvar_2}}
    {\CONSenvenv
      {(\csou{\METAtyvar_1}{\CONSarrowty{\METAtyvar_3}{\METAtyvar_4}})}
      {\CONSenvenv
        {(\csou{\METAtyvar_2}{\CONSconsty{\METAtyname}{\METAtyvar}})}
        {\CONSenvenv
          {(\CONSacc{\METAid}{\METAtyvar_2})}
          {\CONStopoly{\CONSbind{\METAid}{\METAtyvar_0}}}
        }
      }
    }$
  \end{\sizeintables}
\end{center}


Let:
\begin{center}
  \begin{\sizeintables}
    \begin{tabular}{lll}
      $\METAunifstatety_1$
      & $=$
      & $\{
      \asgn{\METAtyvar_1}{\CONSarrowty{\METAtyvar_3}{\METAtyvar_4}},
      \asgn{\METAtyvar_2}{\CONSconsty{\METAtyname}{\METAtyvar}}
      \}$,
      \\

      $\METAcsenv'$
      & $=$
      & $(\CONSbind{\METAid}{\CONSscheme{\{\METAtyvar_0\}}{\METAtyvar_0}})$,
      \\

      $\METAsemjudgement_1$
      & $=$
      & $\CONScssemup
      {\METAunifstatety_1}
      {\METAcsenv'}
      {}
      {}
      {\CONSenvenv
        {(\csou{\METAtyvar_1}{\CONSarrowty{\METAtyvar_3}{\METAtyvar_4}})}
        {\CONSenvenv
          {(\csou{\METAtyvar_2}{\CONSconsty{\METAtyname}{\METAtyvar}})}
          {(\CONSacc{\METAid}{\METAtyvar_2})}
        }
      }
      {\CONSenvnul}
      {}$,
      \\

      $\METAsemjudgement$
      & $=$
      & $\CONScssemup
      {\emptyset}
      {\CONSenvnul}
      {}
      {}
      {\METAcsenv_1}
      {\METAcsenv'}
      {}$.
    \end{tabular}
  \end{\sizeintables}
\end{center}
Then one can derive $\METAsemjudgement_1$ as follows:
\begin{center}
  \begin{\sizeintables}
    $\infer[]
    {\METAsemjudgement_1}
    {\infer[]
      {\CONScssemup
        {\METAunifstatety_1}
        {\METAcsenv'}
        {}
        {}
        {(\CONSacc{\METAid}{\METAtyvar_2})}
        {\CONSenvnul}
        {}
      }
      {\infer[]
        {\CONScssemup
          {\METAunifstatety_1}
          {\METAcsenv'}
          {}
          {}
          {(\csou{\METAtyvar_2}{\METAtyvar_2})}
          {\CONSenvnul}
          {}
        }
        {
          \MEMsubstitution{\METAunifstatety_1}{\METAtyvar_2}
          =
          \MEMsubstitution{\METAunifstatety_1}{\METAtyvar_2}
        }
      }
      &\infer[]
      {\CONScssemup
        {\METAunifstatety_1}
        {\METAcsenv'}
        {}
        {}
        {\CONSenvenv
          {(\csou{\METAtyvar_1}{\CONSarrowty{\METAtyvar_3}{\METAtyvar_4}})}
          {(\csou{\METAtyvar_2}{\CONSconsty{\METAtyname}{\METAtyvar}})}
        }
        {\CONSenvnul}
        {}
      }
      {\infer[]
        {\CONScssemup
          {\METAunifstatety_1}
          {\METAcsenv'}
          {}
          {}
          {(\csou{\METAtyvar_2}{\CONSconsty{\METAtyname}{\METAtyvar}})}
          {\CONSenvnul}
          {}
        }
        {
          \MEMsubstitution{\METAunifstatety_1}{\METAtyvar_2}
          =
          \MEMsubstitution{\METAunifstatety_1}{(\CONSconsty{\METAtyname}{\METAtyvar})}
        }
        &\infer[]
        {\CONScssemup
          {\METAunifstatety_1}
          {\METAcsenv'}
          {}
          {}
          {(\csou{\METAtyvar_1}{\CONSarrowty{\METAtyvar_3}{\METAtyvar_4}})}
          {\CONSenvnul}
          {}
        }
        {
          \MEMsubstitution{\METAunifstatety_1}{\METAtyvar_1}
          =
          \MEMsubstitution{\METAunifstatety_1}{(\CONSarrowty{\METAtyvar_3}{\METAtyvar_4})}
        }
      }
    }$
  \end{\sizeintables}
\end{center}

Finally, one can derive $\METAsemjudgement$ as follows:
\begin{center}
  \begin{\sizeintables}
    $\infer[]
    {\METAsemjudgement}
    {\infer[]
      {\CONScssemup
        {
            \{
            \asgn{\METAtyvar_1}{\CONSarrowty{\METAtyvar_3}{\METAtyvar_4}}
            \}
        }
        {\CONSenvnul}
        {}
        {}
        {\CONSexistsenv
          {\METAtyvar_2}
          {\CONSenvenv
            {(\csou{\METAtyvar_1}{\CONSarrowty{\METAtyvar_3}{\METAtyvar_4}})}
            {\CONSenvenv
              {(\csou{\METAtyvar_2}{\CONSconsty{\METAtyname}{\METAtyvar}})}
              {\CONSenvenv
                {(\CONSacc{\METAid}{\METAtyvar_2})}
                {\CONStopoly{\CONSbind{\METAid}{\METAtyvar_0}}}
              }
            }
          }
        }
        {\METAcsenv'}
        {}
      }
      {\infer[]
        {\CONScssemup
          {
            \{
            \asgn{\METAtyvar_1}{\CONSarrowty{\METAtyvar_3}{\METAtyvar_4}},
            \asgn{\METAtyvar_2}{\CONSconsty{\METAtyname}{\METAtyvar}}
            \}
          }
          {\CONSenvnul}
          {}
          {}
          {\CONSenvenv
            {(\csou{\METAtyvar_1}{\CONSarrowty{\METAtyvar_3}{\METAtyvar_4}})}
            {\CONSenvenv
              {(\csou{\METAtyvar_2}{\CONSconsty{\METAtyname}{\METAtyvar}})}
              {\CONSenvenv
                {(\CONSacc{\METAid}{\METAtyvar_2})}
                {\CONStopoly{\CONSbind{\METAid}{\METAtyvar_0}}}
              }
            }
          }
          {\METAcsenv'}
          {}
        }
        {\infer[]
          {\CONScssemup
            {
              \{
              \asgn{\METAtyvar_1}{\CONSarrowty{\METAtyvar_3}{\METAtyvar_4}},
              \asgn{\METAtyvar_2}{\CONSconsty{\METAtyname}{\METAtyvar}}
              \}
            }
            {\CONSenvnul}
            {}
            {}
            {\CONStopoly{\CONSbind{\METAid}{\METAtyvar_0}}}
            {\METAcsenv'}
            {}
          }
          {\infer[]
            {\CONScssemup
              {
                \{
                \asgn{\METAtyvar_1}{\CONSarrowty{\METAtyvar_3}{\METAtyvar_4}},
                \asgn{\METAtyvar_2}{\CONSconsty{\METAtyname}{\METAtyvar}}
                \}
              }
              {\CONSenvnul}
              {}
              {}
              {\CONSbind{\METAid}{\METAtyvar_0}}
              {\CONSbind{\METAid}{\METAtyvar_0}}
              {}
            }
            {}
          }
          &
          \METAsemjudgement_1
        }
      }
    }$
  \end{\sizeintables}
\end{center}




%% Let
%% $\METAsemjudgement_1
%% =(\CONScssemup
%% {\METAunifstatety}
%% {\CONSenvnul}
%% {}
%% {}
%% {\CONStopoly{\CONSbind{\METAid}{\METAtyvar_0}}}
%% {\METAcsenv'}
%% {})$.
%% This judgement can be derived as follows:
%% \begin{center}
%%   \begin{\sizeintablesp}
%%     $\infer[]
%%     {\METAsemjudgement_1}
%%     {\infer[]
%%       {\CONScssemup
%%         {\METAunifstatety}
%%         {\CONSenvnul}
%%         {}
%%         {}
%%         {(\CONSbind{\METAid}{\METAtyvar_0})}
%%         {(\CONSbind{\METAid}{\METAtyvar_0})}
%%         {}
%%       }
%%       {}
%%       &
%%       \MEMtopolyu{\MEMconsStateEnvp{\emptyset}{\CONSenvnul}{}}{\CONSbind{\METAid}{\METAtyvar_0}}
%%       =\METAcsenv'
%%     }$
%%   \end{\sizeintablesp}
%% \end{center}

%% Let
%% $\METAsemjudgement_2
%% =(\CONScssemup
%% {\METAunifstatety}
%% {\CONSenvnul}
%% {}
%% {}
%% {\CONSenvenv
%%   {(\CONSacc{\METAid}{\METAtyvar_2})}
%%   {\CONStopoly{\CONSbind{\METAid}{\METAtyvar_0}}}
%% }
%% {\METAcsenv'}
%% {})$.
%% This judgement can be derived as follows:
%% \begin{center}
%%   \begin{\sizeintablesp}
%%     $\infer[]
%%     {\METAsemjudgement_2}
%%     {\METAsemjudgement_1
%%       &\infer[]
%%       {\CONScssemup
%%         {\METAunifstatety}
%%         {\METAcsenv'}
%%         {}
%%         {}
%%         {(\CONSacc{\METAid}{\METAtyvar_2})}
%%         {\CONSenvnul}
%%         {}
%%       }
%%       {\MEMcsinsp{\afunc{\METAcsenv'}{\METAid}}{}{\CONSconsty{\METAtyname}{\METAtyvar}}
%%         &\infer[]
%%         {\CONScssemup
%%           {\METAunifstatety}
%%           {\METAcsenv'}
%%           {}
%%           {}
%%           {(\csou{\CONSconsty{\METAtyname}{\METAtyvar}}{\METAtyvar_2})}
%%           {\CONSenvnul}
%%           {}
%%         }
%%         {\MEMsubstitution{\METAunifstatety}{\METAtyvar_2}
%%           =\MEMsubstitution{\METAunifstatety}{(\CONSconsty{\METAtyname}{\METAtyvar})}
%%           =\CONSconsty{\METAtyname}{\METAtyvar}
%%         }
%%       }
%%     }$
%%   \end{\sizeintablesp}
%% \end{center}

%% Finally, the judgement $\METAsemjudgement$ can be derived as follows:
%% \begin{center}
%%   \begin{\sizeintablesp}
%%     $\infer[]
%%     {\METAsemjudgement}
%%     {\infer[]
%%       {\CONScssemup
%%         {\METAunifstatety}
%%         {\CONSenvnul}
%%         {}
%%         {}
%%         {\CONSenvenv
%%           {(\csou{\METAtyvar_2}{\CONSconsty{\METAtyname}{\METAtyvar}})}
%%           {\CONSenvenv
%%             {(\CONSacc{\METAid}{\METAtyvar_2})}
%%             {\CONStopoly{\CONSbind{\METAid}{\METAtyvar_0}}}
%%           }
%%         }
%%         {\METAcsenv'}
%%         {}
%%       }
%%       {\METAsemjudgement_2
%%         &\infer[]
%%         {\CONScssemup
%%           {\METAunifstatety}
%%           {\METAcsenv'}
%%           {}
%%           {}
%%           {(\csou{\METAtyvar_2}{\CONSconsty{\METAtyname}{\METAtyvar}})}
%%           {\CONSenvnul}
%%           {}
%%         }
%%         {\MEMsubstitution{\METAunifstatety}{\METAtyvar_2}
%%           =\MEMsubstitution{\METAunifstatety}{(\CONSconsty{\METAtyname}{\METAtyvar})}
%%           =\CONSconsty{\METAtyname}{\METAtyvar}
%%         }
%%       }
%%       &\infer[]
%%       {\CONScssemup{\METAunifstatety}{\METAcsenv'}{}{}{(\csou{\METAtyvar_1}{\CONSarrowty{\METAtyvar_3}{\METAtyvar_4}})}{\CONSenvnul}{}}
%%       {\MEMsubstitution{\METAunifstatety}{\METAtyvar_1}
%%         =\MEMsubstitution{\METAunifstatety}{(\CONSarrowty{\METAtyvar_3}{\METAtyvar_4})}
%%         =\CONSarrowty{\METAtyvar_3}{\METAtyvar_4}
%%       }
%%     }$
%%   \end{\sizeintablesp}
%% \end{center}

Let us mention an issue w.r.t.\ the semantics of our
constraint/environments and our constraint solver defined below in
Sec.~\ref{sec:unification}.
%
Let us consider the following environment, similar to
$\METAcsenv_1$, which we call $\METAcsenv_2$:
\begin{center}
  \begin{\sizeintables}
    $\CONSenvenv
    {\CONSenvenv
      {\CONSenvenv
        {(\csou{\METAtyvar_1}{\CONSarrowty{\METAtyvar_3}{\METAtyvar_4}})}
        {(\csou{\METAtyvar_2}{\CONSconsty{\METAnamety}{\METAtyvar}})}
      }
      {(\CONSacc{\METAid}{\METAtyvar_2})}
    }
    {\CONStopoly{\CONSbind{\METAid}{\METAtyvar_1}}}$
  \end{\sizeintables}
\end{center}
%
The environment $\METAcsenv_2$ only differs from $\METAcsenv_1$ by the
replacement of $\METAtyvar_0$ by $\METAtyvar_1$.  There are
now two occurrences of $\METAtyvar_1$ in $\METAcsenv_2$
which uses $\METAtyvar_1$ at two separate unrelated
places.
%
Because of these two occurrences of $\METAtyvar_1$, the environment
$\METAcsenv_2$ fails to be satisfiable w.r.t.\ the rules defined in
Fig.~\ref{fig:cssem2}.  However, $\METAcsenv_2$ is satisfiable
w.r.t.\ our constraint solver defined below in
Sec.~\ref{sec:unification}.
%
The issue is that our constraint solver considers the two occurrences
of $\METAtyvar_1$ to be different when with the semantics defined in
this section, these two occurrences are considered to be the same.
%
%% The environment $\METAcsenv_2$ is wrongly using $\METAtyvar_1$ at
%% two separate unrelated places.
%
Note that $\METAcsenv_2$ cannot be generated by our initial constraint
generation algorithm defined below in Sec.~\ref{sec:constraintgen}, so
this bug is not triggered.
%% (Not initially generating environments such
%% as $\METAcsenv_2$ is currently our only way of forbidding them.)
(To overcome this issue, our semantic rules and constraint solver
could be modified to fail on $\METAcsenv_2$ by (1) keeping track of
the generalized type variables, and by (2) failing when dealing with a
constraint in which occurs a generalized type variable.)


%% NOTE: The constraint solver could then fail when the semantics
%% wouldn't.  It is somewhat safer.  We could enforce a similar
%% constraint on our semantics.


%% \tocheckk{
%% Can we have:
%% an environment $\METAcsenv$ is satisfiable
%% iff there exist
%% $\METAren$, $\METAunifstatety$, $\METAcsenv_0$ and $\METAcsenv'$ such that
%% $\MEMsubstitution{\METAcsenv_0}{\METAren}=\METAcsenv$,
%% $\MEMdom{\METAren}\not\in\MEMfreetyvarset{\METAcsenv'}$,
%% and
%% $\CONScssemup
%% {\METAunifstatety}
%% {\CONSenvnul}
%% {\METAcdepset_1}
%% {\METAcdepset_2}
%% {\METAcsenv_0}
%% {\METAcsenv'}
%% {\METAunifstatety}$
%% (where $\MEMfreetyvarsetSYMB$ extracts the set of free variables of
%% its argument).
%% }


Let us now consider dependencies.  We define semantic judgements
considering dependencies as follows:
\begin{center}
  \begin{\sizeintables}
    \begin{tabular}{lllrl}
      $\METAdepstatus$
      & $\in$
      & $\SETdepstatus$
      & $::=$
      & $\CONSdepstatusK
      \mid \CONSdepstatusD
      \mid \CONSdepstatusB$
      \\

      $\METAdepenv$
      & $\in$
      & $\SETdepenv$
      & $=$
      & $\func{\SETdependency}{\SETdepstatus}$
      \\

      $\METAsemjudgementdep$
      & $\in$
      & $\SETsemjudgementdep$
      & $::=$
      & $\CONScssemupp
      {\METAunifstatety}
      {\METAcsenv}
      {\METAdepenv}
      {\METAcsenv_1}
      {\METAcsenv_2}$
    \end{tabular}
  \end{\sizeintables}
\end{center}

We define the application of dependency environments to dependency
sets as follows:
\begin{center}
  \begin{\sizeintables}
    $\afunc{\METAdepenv}{\METAcdepset}=\{\afunc{\METAdepenv}{\METAcdep}\mid\METAcdep\in\METAcdepset\}$
  \end{\sizeintables}
\end{center}



\begin{figure}[t]
  \begin{\sizeintables}
    \begin{tabular}{llllll}
      %% \multicolumn{3}{l}{
      %%   $\infer[\RULEsemTrue]
      %%   {\CONScssemupp
      %%     {\METAunifstatety}
      %%     {\METAcsenv}
      %%     {\METAdepenv}
      %%     {\CONSenvnul}
      %%     {\CONSenvnul}
      %%   }
      %%   {}$
      %% }

      %% &

      %% \multicolumn{3}{l@{\hspace{0.2in}}}{
      %% $\infer[\RULEsemEvar]
      %% {\CONScssemupp
      %%   {\METAunifstatety}
      %%   {\METAcsenv}
      %%   {\METAdepenv}
      %%   {\METAenvvar}
      %%   {\MEMsubstitution{\METAunifstatety}{\METAenvvar}}
      %% }
      %% {}$
      %% }
      %% \\

      %% \\

      %% \multicolumn{3}{l}{
      %%   $\infer[\RULEsemCeq]
      %%   {\CONScssemupp
      %%     {\METAunifstatety}
      %%     {\METAcsenv}
      %%     {\METAdepenv}
      %%     {(\csou{x_1}{x_2})}
      %%     {\CONSenvnul}
      %%   }
      %%   {
      %%     \MEMsubstitution{\METAunifstatety}{x_1}=\MEMsubstitution{\METAunifstatety}{x_2}
      %%     &
      %%     x_1,x_2\not\in\SETcsenv
      %%   }$
      %% }

      %% &

      %% \multicolumn{3}{l}{
      %% $\infer[\RULEsemEeq]
      %% {\CONScssemupp
      %%   {\METAunifstatety}
      %%   {\METAcsenv}
      %%   {\METAdepenv}
      %%   {(\csou{\METAcsenv_1}{\METAcsenv_2})}
      %%   {\CONSenvnul}
      %% }
      %% {\forallexp
      %%   {i\in\{1,2\}}
      %%   {\CONScssemupp
      %%   {\METAunifstatety}
      %%   {\METAcsenv}
      %%   {\METAdepenv}
      %%   {\METAcsenv_i}
      %%   {\METAcsenv'_i}}
      %%   &\METAcsenv'_1=\METAcsenv'_2
      %% }$
      %% }
      %% \\

      %% \\

      %% \multicolumn{5}{l@{\hspace{0.2in}}}{
      %% $\infer[\RULEsemAcci]
      %% {\CONScssemupp
      %%   {\METAunifstatety}
      %%   {\METAcsenv}
      %%   {\METAdepenv}
      %%   {(\CONSacc{\METAgenid}{\METAvar})}
      %%   {\CONSenvnul}
      %% }
      %% {
      %%   \MEMcsinsp{\afunc{\METAcsenv}{\METAgenid}}{\MEMvarset{\mytuple{\METAunifstatety,\METAcsenv,\METAvar}}}{x}
      %%   &\CONScssemupp{\METAunifstatety}{\METAcsenv}{\METAdepenv}{(\csou{x}{\METAvar})}{\CONSenvnul}
      %% }$
      %% }

      %% &

      %% \multicolumn{1}{l}{
      %% $\infer[\RULEsemAcco]
      %% {\CONScssemupp
      %%   {\METAunifstatety}
      %%   {\METAcsenv}
      %%   {\METAdepenv}
      %%   {(\CONSacc{\METAgenid}{\METAvar})}
      %%   {\CONSenvnul}
      %% }
      %% {\afunc{\METAcsenv}{\METAgenid}\mbox{ undefined }}$
      %% }
      %% \\

      %% \\

      %% \multicolumn{3}{l@{\hspace{0.1in}}}{
      %% $\infer[\RULEsemBind]
      %% {\CONScssemupp
      %%   {\METAunifstatety}
      %%   {\METAcsenv}
      %%   {\METAdepenv}
      %%   {(\CONSbind{\METAgenid}{x})}
      %%   {(\CONSbind{\METAgenid}{x})}
      %% }
      %% {}$
      %% }

      %% &

      %% \multicolumn{3}{l}{
      %% $\infer[\RULEsemPoly]
      %% {\CONScssemupp
      %%   {\METAunifstatety}
      %%   {\METAcsenv}
      %%   {\METAdepenv}
      %%   {\CONStopoly{\METAcsenv'}}
      %%   {\MEMtopolyu{\mytuple{\emptyset,\METAcsenv}}{\METAcsenv''}}
      %% }
      %% {
      %%   \CONScssemupp{\METAunifstatety}{\METAcsenv}{\METAdepenv}{\METAcsenv'}{\METAcsenv''}
      %% }$
      %% }
      %% \\

      %% \\

      %% \multicolumn{4}{l@{\hspace{0.1in}}}{
      %% $\infer[\RULEsemComp]
      %% {\CONScssemupp
      %%   {\METAunifstatety}
      %%   {\METAcsenv}
      %%   {\METAdepenv}
      %%   {(\CONSenvenv{\METAcsenv_2}{\METAcsenv_1})}
      %%   {(\CONSenvenv{\METAcsenv'_2}{\METAcsenv'_1})}
      %% }
      %% {
      %%   \CONScssemupp{\METAunifstatety}{\METAcsenv}{\METAdepenv}{\METAcsenv_1}{\METAcsenv'_1}
      %%   &\CONScssemupp{\METAunifstatety}{(\CONSenvenv{\METAcsenv'_1}{\METAcsenv})}{\METAdepenv}{\METAcsenv_2}{\METAcsenv'_2}
      %% }$
      %% }

      %% &

      \multicolumn{3}{l@{\hspace{0.1in}}}{
      $\infer[\RULEsemDepa]
      {\CONScssemupp
        {\METAunifstatety}
        {\METAcsenv}
        {\METAdepenv}
        {\CONSdeps{\METAcsenv'}{\METAcdepset}}
        {\CONSdeps{\METAcsenv''}{\METAcdepset}}
      }
      {
        \CONScssemupp{\METAunifstatety}{\METAcsenv}{\METAdepenv}{\METAcsenv'}{\METAcsenv''}
        &\afunc{\METAdepenv}{\METAcdepset}=\{\CONSdepstatusK\}
      }$
      }
      %% \\

      %% \\

      %% \multicolumn{5}{l@{\hspace{0.1in}}}{
      %% $\infer[\RULEsemEx]
      %% {\CONScssemup
      %%   {\METAunifstatety}
      %%   {\METAcsenv}
      %%   {}
      %%   {}
      %%   {\CONSexistsenv{\METAatom}{\METAcsenv_1}}
      %%   {\METAcsenv_2}
      %%   {}
      %% }
      %% {
      %%   \CONScssemup{\MEMuplus{\METAunifstatety}{\METAunifstatety'}}{\METAcsenv}{}{}{\METAcsenv_1}{\METAcsenv_2}{}
      %%   &\MEMdom{\METAunifstatety'}=\{\METAatom\}
      %% }$
      %% }

      &

      \multicolumn{3}{l}{
      $\infer[\RULEsemDepb]
      {\CONScssemupp
        {\METAunifstatety}
        {\METAcsenv}
        {\METAdepenv}
        {\CONSdeps{\METAcsenv'}{\METAcdepset}}
        {\MEMunlab{\METAcsenv'}}
      }
      {
        \CONSdepstatusD\in\afunc{\METAdepenv}{\METAcdepset}
      }$
      }
      \\

      \\

      \multicolumn{6}{l}{
        $\infer[\RULEsemDepc]
        {\CONScssemupp
          {\METAunifstatety}
          {\METAcsenv}
          {\METAdepenv}
          {\CONSdeps{\METAcsenv'}{\METAcdepset}}
          {\CONSenvnul}
        }
        {
          \{\CONSdepstatusB\}=\afunc{\METAdepenv}{\METAcdepset}\setminus\{\CONSdepstatusK\}
        }$
      }
    \end{tabular}
  \end{\sizeintables}
  \caption{Semantics of the constraint/environments, considering dependencies}
  \label{fig:cssem}
\end{figure}



Let us add dependencies to the rules defined in Fig.~\ref{fig:cssem2}.
Semantic judgements are now of the form
$\CONScssemupp{\METAunifstatety}{\METAcsenv}{\METAdepenv}{\METAcsenv_1}{\METAcsenv_2}$.
Except for these additions, the rules defined in Fig.~\ref{fig:cssem2}
do not differ and are therefore not repeated.  In addition,
Fig.~\ref{fig:cssem} defines three new rules: $\RULEsemDepa$,
$\RULEsemDepb$, and~$\RULEsemDepc$ to deal with dependencies.
%
Fig.~\ref{fig:cssem} uses the
function $\MEMunlabSYMB$ which is formally defined below in
Fig.~\ref{fig:csfiltering} in Sec.~\ref{sec:csfiltering}.  This
function transforms an environment
$\METAcsenv$ into a similar dummy environment $\METAcsenv'$ which
contains dummy versions of the
binders from $\METAcsenv$ and cannot participate in any error.

%% We have such forward references because the semantics of our
%% constraints is highly related to their solving.


We say that an environment $\METAcsenv$ is satisfiable
w.r.t.\ the dependency environment $\METAdepenv$ iff there exist
$\METAunifstatety$ and $\METAcsenv'$ such that
$\CONScssemupp
{\METAunifstatety}
{\CONSenvnul}
{\METAdepenv}
{\METAcsenv}
{\METAcsenv'}$.
%
Given a dependency environment $\METAdepenv$, a dependency $\METAcdep$
is said to be satisfied if
$\afunc{\METAdepenv}{\METAcdep}=\CONSdepstatusK$, and it is said to be
unsatisfied if $\afunc{\METAdepenv}{\METAcdep}=\CONSdepstatusD$.  The
dependency status $\CONSdepstatusB$ is more complicated.  This status
is needed for scoping issues which are further discussed below in
Sec.~\ref{sec:csfiltering}.  If an environment $\METAcsenv$ is
annotated by a dependency which has status $\CONSdepstatusB$ then
$\METAcsenv$'s binders and environment variables (which could
potentially bind any identifier) are turned into dummy binders and
dummy environment variables respectively.  Other environments, such as
equality constraints,
% annotated by dependencies with status $\CONSdepstatusB$
are discarded.
%% The set $\METAcdepset_2$ can be regarded as a set of both:
%% ``semi-satisfied'' (we say ``semi-satisfied'' because environments are
%% not kept as they are but turned into dummy ones) dependencies for
%% dependencies annotating binders and environment variables, and of
%% unsatisfied dependencies for dependencies annotating any other kind of
%% environment (such as equality constraints).
%
The environment $\METAcsenv'$ is the semantics of
$\METAcsenv$ in the context
$\mytuple{\METAunifstatety,\CONSenvnul,\METAdepenv}$.

%% The dependency set $\METAcdepset_1\setminus\METAcdepset_2$ is the set
%% of satisfied dependencies in $\METAcsenv$.  The meaning of the
%% dependency set $\METAcdepset_2$ is more complicated.  This set is
%% needed for scoping issues which are further discussed
%% below in Sec.~\ref{sec:csfiltering}.  The set $\METAcdepset_2$ is used
%% to turn binders and environment variables (which could potentially
%% bind any identifier) into dummy binders and dummy environment
%% variables respectively.  Other environments (e.g., equality
%% constraints) annotated by dependencies from $\METAcdepset_2$ are
%% discarded.  The set $\METAcdepset_2$ can be regarded as a set of both:
%% ``semi-satisfied'' (we say ``semi-satisfied'' because environments are
%% not kept as they are but turned into dummy ones) dependencies for
%% dependencies annotating binders and environment variables, and of
%% unsatisfied dependencies for dependencies annotating any other kind of
%% environment (such as equality constraints).
%% %
%% The environment $\METAcsenv'$ is the semantics of
%% $\METAcsenv$ in the context
%% $\mytuple{\METAunifstatety,\CONSenvnul,\METAcdepset_1,\METAcdepset_2}$.



%
%% \tocheck(Anticipating Sec.~\ref{sec:unification} which defines our constraint
%% solver:
%% $\CONScssemu{\emptyset}{\CONSenvnul}{\METAcdepset_1}{\METAcdepset_2}{\METAcsenv}{\METAcsenv'}{\METAunifstatety}$
%% iff
%% $\CONSunifenv{\MEMconsStateEnvp{\emptyset}{\CONSenvnul}{}}{\emptyset}{\MEMcsprojp{\METAcsenv}{\METAcdepset_1}{\METAcdepset_2}}
%% \ffra
%% \CONSunifsuccess{\MEMconsStateEnvp{\METAunifstatety'}{\METAcsenv'}{}}{}$
%% and $\METAunifstatety=\MEMclosesub{\METAunifstatety'}$.)}



\subsection{\SECgeneration}
\label{sec:constraintgen}



%% \intitle{Value bindings.}
%% %
%% %
%% At constraint generation (Fig.~\ref{fig:consGenAlgo}), in the pattern
%% rule $\MEMgencgrulee$,
%% % for atomic patterns,
%% we generate monomorphic, unconfirmed binders of the form
%% $\CONSbindu{\METAid}{\METAtyvar}$ where no type variable is yet
%% quantified over.
%% %
%% These binders are monomorphic because in \SML, e.g., the type of a
%% recursive function such as \inexamplebody{f} in the let-expression
%% %the let-expression
%% \inexamplebody{let val rec f = fn x => f x in f end},
%% is monomorphic within its definition
%% (\inexamplebody{f}'s first and second occurrences' types are equal)
%% and generalised into a polymorphic \textit{for all} type scheme when typing
%% the declaration (\inexamplebody{f}'s third occurrence's type is
%% an instance of the generalisation of \inexamplebody{f}'s first
%% occurrence's type).
%% %
%% An environment $\METAcsenv$ is then turned into a polymorphic one
%% during constraint solving (using $\MEMtopolySYMB$ defined in
%% Fig.~\ref{fig:monotopoly} in Sec.~\ref{sec:unification}) if marked as
%% follows: $\CONStopoly{\METAcsenv}$.  Such forms are generated by
%% the recursive value declaration rule
%% $\MEMgencgrulel$ and the datatype declaration rule
%% $\MEMgencgrulen$.
%% %
%% In $\MEMgencgrulee$ again, the binder is unconfirmed and
%% no status constraint is generated (as opposed to, e.g., rule
%% $\MEMgencgrulej$ which forces the analysed identifier to be a nullary
%% datatype constructor) because in \SML, e.g.,
%% in \inexamplebody{fn x => x}, without any more
%% context, the identifier \inexamplebody{x} could be a value variable or a
%% datatype constructor.  The status of \inexamplebody{x} is then unknown.
%% Because recursive functions are forced to be value
%% variables ($\CONSstatusv$) even when in the scope of a datatype
%% constructor binding,
%% $\MEMtostVSYMB$ (used by $\MEMgencgrulel$) generates a status constraint:
%% \begin{center}
%%   \begin{\sizeintables}
%%     %% $\MEMtostV{\METAcsenv}=
%%     %% \left\{
%%     %% \begin{array}{ll}
%%     %%   \CONSenvenv{\MEMtostV{\METAcsenv_1}}{\MEMtostV{\METAcsenv_2}},
%%     %%   &
%%     %%   \mbox{if }\METAcsenv=\CONSenvenv{\METAcsenv_1}{\METAcsenv_2}
%%     %%   \\
%%     %%   (\CONSbindl{\METAid}{\CONSvidsem{\METAlabty}{\CONSstatusv}}{\METAlab}),
%%     %%   &
%%     %%   \mbox{if }\METAcsenv=(\CONSbindl{\METAid}{\CONSvidsem{\METAlabty}{\CONSstatusu}}{\METAlab})
%%     %%   \\
%%     %%   \METAcsenv,
%%     %%   &
%%     %%   \mbox{otherwise}
%%     %% \end{array}
%%     %% \right.$
%%     \begin{tabular}{ l l l }
%%       $\MEMtostV{\CONSenvenv{\METAcsenv_2}{\METAcsenv_1}}$
%%       & $=$
%%       & $\CONSenvenv{\MEMtostV{\METAcsenv_2}}{\MEMtostV{\METAcsenv_1}}$
%%       \\

%%       $\MEMtostV{\CONSbindul{\METAid}{\METAtyvar}{\METAlab}}$
%%       & $=$
%%       & $(\CONSbindl{\METAid}{\mytuple{\METAtyvar,\CONSstatusv}}{\METAlab})$
%%       \\

%%       $\MEMtostV{\METAcsenv}$
%%       & $=$
%%       & $\METAcsenv$,
%%       if none of the above applies
%%     \end{tabular}
%%   \end{\sizeintables}
%% \end{center}

%% \newtext{As explained in Sec.~\ref{sec:unification}, at constraint
%% solving, an unconfirmed binder of
%% the form $\CONSbindu{\METAid}{\METAtyvar}$ eventually turns
%% into a binder of the form $\CONSbind{\METAid}{\METAtyvar}$ or an
%% accessor of the form $\CONSacc{\METAid}{\METAtyvar}$.  (In some cases,
%% a status constraint is also generated from an unconfirmed binder.)}


%% The function $\MEMtopolySYMB$ is used by our environment
%% solver (Fig.~\ref{fig:buildenv}) to transform an environment into
%% a polymorphic one as follows:
%% %
%% \begin{center}
%% \begin{\sizeintables}
%% \begin{tabular}{l}
%% \begin{tabular}{ l r l }
%%   %% $\MEMtomono{\MEMconsenv{\mytuple{\METAcsenv_1,\dots,\METAcsenv_n}}{\METAbool}}$
%%   %% & $=$ &
%%   %% $\MEMconsenv{\mytuple{\MEMtomono{\METAcsenv_1},\dots,\MEMtomono{\METAcsenv_n}}}{\METAbool}$
%%   %% \\

%%   $\MEMtopoly{\MEMbindvv{\METAlabty}{\METApoly}{\METAstatus}{\METAcdepset}}$
%%   & $=$ &
%%   $\MEMbindvv{\METAlabty}{\CONSpoly}{\CONSstatusv}{\METAcdepset}$
%% \end{tabular}
%% \\
%% \begin{tabular}{ l r l }
%%   $\MEMtopoly{\MEMbindss{\METAcsenv}{\METAcdepset}}$
%%   & $=$ &
%%   $\MEMbindss{\MEMtopoly{\METAcsenv}}{\METAcdepset}$
%% \end{tabular}
%% \\
%% \begin{tabular}{ l r l }
%%   $\MEMtopoly{\METAbind}$
%%   & $=$
%%   & $\{\asgn{\METAgenid}{\MEMtopoly{\afunc{\METAbind}{\METAgenid}}}
%%   \mid
%%   \METAgenid\in\SETid\}$
%%   \\
%%   & $\cup$
%%   & $\{\asgn{\METAgenid}{\afunc{\METAbind}{\METAgenid}}\mid\METAgenid\not\in\SETid\}$
%%   \\

%%   %% $\MEMtomono{\MEMenvcs{\METAcsenv}{\METAcsset}}$
%%   %% & $=$
%%   %% & $\MEMenvcs{(\MEMtomono{\METAcsenv})}{\METAcsset}$
%%   %% \\

%%   %% $\MEMtopoly{\CONSenvenv{\METAcsenv_1}{\METAcsenv_2}}$
%%   %% & $=$
%%   %% & $\CONSenvenv{(\MEMtopoly{\METAcsenv_1})}{\MEMtopoly{\METAcsenv_2}}$
%%   %% \\

%%   $\MEMtopoly{\METAcsenv}$
%%   & $=$
%%   & $\CONStopoly\METAcsenv$,
%%   if $\METAcsenv$ is not a $\METAbind$
%% \end{tabular}
%% \end{tabular}
%% \end{\sizeintables}
%% \end{center}

%% \mynote{2010-04-07}{We could use $\MEMisstUSYMB$ in $\MEMtopolySYMB$.}

%% %
%% \begin{center}
%% \begin{tabular}{l}
%% \begin{tabular}{ l r l }
%%   %% $\MEMtomono{\MEMconsenv{\mytuple{\METAcsenv_1,\dots,\METAcsenv_n}}{\METAbool}}$
%%   %% & $=$
%%   %% & $\MEMconsenv{\mytuple{\MEMtomono{\METAcsenv_1},\dots,\MEMtomono{\METAcsenv_n}}}{\METAbool}$
%%   %% \\

%%   $\MEMtomono{\MEMbindgg{\mytuple{\METAlabty,\METApoly,\METAstatus}}{\METAlabset}{\METAidset}}$
%%   & $=$
%%   & $\MEMbindgg{\mytuple{\METAlabty,\CONSmono,\CONSstatusu}}{\METAlabset}{\METAidset}$
%% \end{tabular}
%% \\
%% \begin{tabular}{ l r l }
%%   $\MEMtomono{\METAbind}$
%%   & $=$
%%   & $\{\asgn{\METAgenid}{\MEMtomono{\afunc{\METAbind}{\METAgenid}}}
%%   \mid
%%   \METAgenid\in\SETid\}$
%%   \\
%%   & $\cup$
%%   & $\{\asgn{\METAgenid}{\afunc{\METAbind}{\METAgenid}}\mid\METAgenid\not\in\SETid\}$
%%   \\

%%   %% $\MEMtomono{\MEMenvcs{\METAcsenv}{\METAcsset}}$
%%   %% & $=$
%%   %% & $\MEMenvcs{(\MEMtomono{\METAcsenv})}{\METAcsset}$
%%   %% \\

%%   $\MEMtomono{\CONSenvenv{\METAcsenv}{\METAcsorenv}}$
%%   & $=$
%%   & $\CONSenvenv{(\MEMtomono{\METAcsenv})}{\MEMtomono{\METAcsorenv}}$
%%   \\

%%   $\MEMtomono{\METAcsorenv}$
%%   & $=$
%%   & $\METAcsorenv$,
%%   if $\METAcsorenv$ is a $\METAenvvar$, $\CONSsems{\METAstrid}{\METAlab}$ or a $\METAcsset$
%% \end{tabular}
%% \end{tabular}
%% \end{center}

%% Statuses become unknown ones ($\CONSstatusu$) because in
%% our \SML\ subset a monomorphic environment is context-dependent as it
%% can always be rebound.  In
%% \inexamplebody{let datatype t = x in fn x => x end}, e.g.,
%% \inexamplebody{x}
%% is a datatype constructor throughout the let-expression.  The
%% monomorphic environment generated by \inexamplebody{fn x => x}
%% is context-dependent and the two last \inexamplebody{x}'s are in fact
%% bound to the first one.

\mynote{(2010-03-28)}{We need the distinction between
$\CONSstatusv$ and $\CONSstatusu$ in $\MEMtrimreboundenvSYMB$.}


%% \intitle{Status testings.}
%% %
%% %We test the monomorphism and status of binders as follows:
%% %Let $\MEMismono{\METAbindid}$ be true iff $\METAbindid$ is a
%% %$\METAbindv$ and $\afunc{\afunc{\METAbindv}{0}}{1}=\CONSpoly$.
%% %% Let $\MEMismono{x}$ be $\neg\MEMispoly{x}$ for
%% %% $x\in\{\METAbindv,\METAbindt,\METAbinds\}$.
%% If $\afunc{\METAbindv}{0}=\mytuple{\METAlabty,\METApoly,\METAstatus}$
%% then
%% %% $\MEMisstV{\METAbindv}$ is true iff
%% %% $\METAstatus=\CONSstatusv$,
%% $\MEMisstV{\METAbindv}
%% \iff
%% \METAstatus=\CONSstatusv$,
%% $\MEMisstA{\METAbindv}
%% \iff
%% \METAstatus=\CONSstatusa$,
%% $\MEMisstUM{\METAbindv}
%% \iff
%% \mytuple{\METAstatus,\METApoly}=\mytuple{\CONSstatusu,\CONSmono}$ and
%% $\MEMisstCD{\METAbindv}
%% \iff
%% \METAstatus\in\{\CONSstatusc,\CONSstatusd\}$.

%% \mynote{(2010-04-14)}{Maybe this should move in the unification
%%   section because they're only used there.  They should only be used
%%   in Fig.~\ref{fig:trimenv}.}


%% Let the composition of environments be defined as follows:
%% \begin{center}
%% \begin{tabular}{lrl}
%%   $\MEMcupenv{\emptyset}$
%%   & $=$
%%   & $\MEMconsenv{\emptyset}{\MEMtrue}$\\

%%   $\MEMcupenv{\METAcsenvseq@\mytuple{\METAenvvar}}$
%%   & $=$
%%   & $\MEMcupenv{\METAcsenvseq}$\\

%%   $\MEMcupenv{\METAcsenvseq@\mytuple{\CONSsems{\METAstrid}{\METAlab}}}$
%%   & $=$
%%   & $\MEMcupenv{\METAcsenvseq}$\\

%%   $\MEMcupenv{\METAcsenvseq@\mytuple{\MEMconsenv{\METAseqenvseq}{\METAbool}}}$
%%   & $=$
%%   & $\MEMconsenv{\MEMcupenv{\mytuple{\MEMcupenv{\METAcsenvseq}}@\METAseqenvseq}}{\METAbool'}$
%% \end{tabular}
%% \end{center}

%% Let the composition of environments be defined as follows:
%% \begin{center}
%% \begin{tabular}{lrl}
%%   $\MEMcupenv{\emptyset}$
%%   & $=$
%%   & $\MEMconsenv{\emptyset}{\MEMtrue}$\\

%%   $\MEMcupenv{\METAcsenvseq@\mytuple{\METAenvvar}}$
%%   & $=$
%%   & $\METAenvvar$\\

%%   $\MEMcupenv{\METAcsenvseq@\mytuple{\CONSsems{\METAstrid}{\METAlab}}}$
%%   & $=$
%%   & $\CONSsems{\METAstrid}{\METAlab}$\\

%%   $\MEMcupenv{\mytuple{\METAcsenvseq@\MEMconsenv{\METAseqenvseq}{\METAbool}}}$
%%   & $=$
%%   & $\left\{
%%   \begin{array}{ l l }
%%     \MEMconsenv{\MEMcupenv{\METAseqenvseq'@\METAseqenvseq}}{\METAbool'}
%%     &
%%     \mbox{if }\MEMcupenv{\METAcsenvseq}=\MEMconsenv{\METAseqenvseq'}{\METAbool'}
%%     \mbox{ and }\METAbool
%%     \\
%%     \MEMconsenv{\METAseqenvseq}{\MEMfalse}
%%     &
%%     \mbox{otherwise}
%%   \end{array}
%%   \right.$
%% \end{tabular}
%% \end{center}


%% \begin{center}
%% \begin{tabular}{lrl}
%%   $\MEMcompdec{\emptyset}$
%%   &
%%   $=$
%%   &
%%   $\mytuple{\emptyset,\emptyset}$\\

%%   $\MEMcompdec{\mytuple{\METAenvvar}@\METAcsenvseq}$
%%   &
%%   $=$
%%   &
%%   $\METAenvvar$\\

%%   $\MEMcompdec{\mytuple{\CONSsems{\METAstrid}{\METAlab}}@\METAcsenvseq}$
%%   &
%%   $=$
%%   &
%%   $\CONSsems{\METAstrid}{\METAlab}$\\

%%   $\MEMcompdec{\mytuple{\mytuple{\METAbind,\METAopenenvseq}}@\METAcsenvseq}$
%%   &
%%   $=$
%%   &
%%   $\MEMcupenv{\mytuple{\mytuple{\METAbind',\METAopenenvseq'},\METAcsenv'}}$\\
%%   & &
%%   where $\METAcsenv' = \MEMcompdec{\METAcsenvseq}$\\
%%   %% & &
%%   %% and $\METAidset = \MEMdom{\METAcsenv'}\cap\SETid$\\
%%   %% & &
%%   %% and $\METAtypenameset = \MEMdom{\METAcsenv'}\cap\SETtypename$\\
%%   %% & &
%%   %% and $\METAstridset = \MEMdom{\METAcsenv'}\cap\SETstrid$\\
%%   & &
%%   and $\METAbind'=\MEMrestrictout{\METAbind}{\MEMdom{\METAcsenv'}}$\\
%%   %% \begin{tabular}{rl}
%%   %%   &
%%   %%   $\{\MEMbindv{\METAid}{\METAlabty}{\METAlab}{\METApoly}{\METAstatus}
%%   %%   \in \METAbindset
%%   %%   \mid \METAid \not \in \METAidset\}$\\
%%   %%   $\cup$
%%   %%   &
%%   %%   $\{\MEMbindt{\METAtypename}{\METAnamety}{\METAlab}{\METAseqvar}
%%   %%   \in \METAbindset
%%   %%   \mid \METAtypename \not \in \METAtypenameset\}$\\
%%   %%   $\cup$
%%   %%   &
%%   %%   $\{\MEMbinds{\METAstrid}{\METAcsenv''}{\METAlab}
%%   %%   \METAcsenv
%%   %%   \mid \METAstrid \not \in \METAstridset\}$
%%   %% \end{tabular}\\
%%   & &
%%   and
%%   $\METAopenenvseq'
%%   =
%%   \{\asgn{i}{\MEMopenenv{\METAstrid}{\METAlab}{\METAgenidset\cup\MEMdom{\METAcsenv'}}}
%%   \mid
%%   \afunc{\METAopenenvseq}{i}=\MEMopenenv{\METAstrid}{\METAlab}{\METAgenidset}\}$
%% \end{tabular}
%% \end{center}


%% \subsection{Constraint generation}
%% \label{sec:constraintgen}


\subsubsection{Algorithm}
\label{sec:genalgo}

%
\begin{\myfigure}[!t]
  \input{included/constraintGeneratorAlgoOpen2}
  \caption{Constraint generation rules}
  \label{fig:consGenAlgo}
\end{\myfigure}
%
Fig.~\ref{fig:consGenAlgo} defines
%
\index{initial constraint generator}%
%
our \emph{initial constraint generator}.
%
It either takes a declaration and returns an environemnt or takes a
non-declaration and a variable and returns an environment.
%
\tocheck{We use the word ``initial'' to distinguish it from our
constraint solver defined in Sec.~\ref{sec:unification} which, while
solving constraints, also generates some
constraints.}
%
%% Let the forms associated with terms (in $\SETterm$) by our initial
%% constraint generator be defined as follows:
%% \begin{center}
%%   \begin{\sizeintablesp}
%%     $\METAcgterm\in\SETcgterm::=\METAcsenv\mid\mytuple{\METAvar,\METAcsenv}$
%%   \end{\sizeintablesp}
%% \end{center}
%% The relation $\typinguSYMB$ is a binary relation defined on
%% $\SETterm\cprod\SETcgterm$, i.e.,
%% $\typinguSYMB\,\,\subset\SETterm\cprod\SETcgterm$.
%% %
%% %This relation is extended below in Sec.~\ref{sec:extensions}.

%% The rules of our constraint generator return $\METAcgterm$s
%% % (see $\SETcgterm$'s definition above in Sec.~\ref{sec:genalgo})
%% which can
%% either be environments $\METAcsenv$
%% (rules~$\MEMgencgrulel$-$\MEMgencgrulep$) or
%% constrained variables of the form $\mytuple{\METAvar,\METAcsenv}$
%% where $\METAcsenv$ constrains $\METAvar$.  Such a constrained
%% variable
%% %($\METAcsenv$ constrains $\METAvar$ in
%% %$\mytuple{\METAvar,\METAcsenv}$),
%% $\METAvar$ is in some cases an internal type variable $\METAtyvar$
%% (rules~$\MEMgencgrulea$-$\MEMgencgrulebf$,$\MEMgencgruleg$-$\MEMgencgrulek$),
%% in some other cases a type constructor variable $\METAtynamevar$
%% (rule~$\MEMgencgrulebe$), and in some other cases an environment
%% variable $\METAenvvar$ (rules $\MEMgencgruleq$-$\MEMgencgruler$).  We
%% chose not to have a constructor of constrained types that would build
%% an internal type from an environment and an internal type (as a
%% \COMPENV\ of the form $\CONSenvenv{\METAcsenv_2}{\METAcsenv_1}$ builds
%% a constrained environment from two environments because $\METAcsenv_1$
%% constrains $\METAcsenv_2$), because it simplifies the presentation of our
%% system by not having deep types.  Such a system with constrained types
%% could be investigated (see also Sec.~\ref{sec:constrainedtypes} on
%% this matter).  Having chosen to return pairs of the form
%% $\mytuple{\METAtyvar,\METAcsenv}$ for expressions, we then decided to
%% follow the same pattern for structure expressions and return pairs of
%% the form $\mytuple{\METAenvvar,\METAcsenv}$ instead of returning
%% environments of the form
%% $\CONSenvenv{\METAenvvar}{\METAcsenv}$.



\hidden{
\subsubsection{Shape of the generated environments}
\label{sec:shapegenenvs}

%
Our initial constraint generator defined in Fig.~\ref{fig:consGenAlgo}
only generates restricted forms of environments ($\METAcsenvg$ defined
below, where ``g'' stands for ``generation'').  Let us present these
restricted forms, where $\METAlabtyg$ is a restriction of
$\METAlabty$, and the other forms are restrictions of $\METAcsenv$
(where ``p'' stands for ``poly'' and ``l'' for ``labelled''):
\begin{center}
  \begin{\sizeintablesp}
    \begin{tabular}{lllrl}
      $\METAlabtyg$
      & $\in$
      & $\SETlabtyg$
      & $::=$
      & $\METAtyvar\mid\CONSconsty{\METAtynamevar}{\METAtyvar}
      \mid\CONSconsty{\METAtyname}{\METAtyvar}
      \mid\METAlabtyarrowp{\METAtyvar_1}{\METAtyvar_2}{}$
      \\

      $\METAbindg$
      & $\in$
      & $\SETbindg$
      & $::=$
      & $\CONSbindl{\METAtypename}{\METAtyname}{\METAlab}
      \mid\CONSbindl{\METAstrid}{\METAenvvar}{\METAlab}
      \mid\CONSbindl{\METAtypevar}{\METAtyvar}{\METAlab}
      \mid\CONSbindl{\METAid}{\METAtyvar}{\METAlab}$
      %\mid\CONSbindl{\METAid}{\METArawstatus}{\METAlab}$
      %\mid\CONSbindul{\METAid}{\METAtyvar}{\METAlab}$
      \\

      $\METAcsg$
      & $\in$
      & $\SETcsg$
      & $::=$
      & $\cso{\METAenvvar_1}{\METAenvvar_2}{\METAlab}
      \mid\cso{\METAtyvar}{\METAlabtyg}{\METAlab}$
      \\

      $\METAaccg$
      & $\in$
      & $\SETaccg$
      & $::=$
      & $\CONSdepss{\METAacc}{\METAlab}$
      \\

      $\METAenvvarg$
      & $\in$
      & $\SETenvvarg$
      & $::=$
      & $\CONSdepss{\METAenvvar}{\METAlab}$
      \\

      $\METAcsenvpp$
      & $\in$
      & $\SETcsenvpp$
      & $::=$
      & $\METAaccg
      \mid\METAcsg
      \mid\CONSenvenv{\METAcsenvpp_2}{\METAcsenvpp_1}$
      \\

      $\METAcsenvp$
      & $\in$
      & $\SETcsenvp$
      & $::=$
      & $\CONSbindl{\METAid}{\METAtyvar}{\METAlab}
      \mid\CONSenvenv{\METAcsenvpp}{\METAcsenvp}
      \mid\CONSenvenv{\METAcsenvp}{\METAcsenvpp}$
      \\

      $\METAcsenvg$
      & $\in$
      & $\SETcsenvg$
      & $::=$
      & $\CONSenvnul
      \mid\METAenvvarg
      \mid\METAbindg
      \mid\METAaccg
      \mid\METAcsg
      \mid\csou{\METAenvvar}{\METAcsenvg}
      \mid\CONStopoly{\METAcsenvp}
      \mid\CONSenvenv{\METAcsenvg_2}{\METAcsenvg_1}$
    \end{tabular}
  \end{\sizeintablesp}
\end{center}

At initial constraint generation, the only labelled
(dependent) environments are equality constraints ($\METAcs$), binders
($\METAbind$), accessors ($\METAacc$), and environment variables
($\METAenvvar$).
%
Also, note that a $\METAcsenvp$ contains exactly one binder and can also
contain equality constraints as well as accessors.

\mynote{(2010-05-17)}{We don't actually generate status constraints at
  constraint generation, and we don't really need to generate any such
  constraints during constraint solving.}
}


\subsubsection{Complexity of constraint generation}
%
Inspection reveals the generated constraint's size is linear in the
program size.  Unlike \HWTES' constraint
generation~\cite{Haack+Wells:2004}, for a polymorphic let-bound
function (see the combination of rules~$\MEMgencgruleb$,
$\MEMgencgrulee$ and $\MEMgencgrulel$) we do not eagerly copy
constraints for the function body.  Instead, we generate, among other
things, $\CONStopolySYMB$ environments, \COMPENVS, and binders, and
force solving (constraint solving is defined below in
Sec.~\ref{sec:unification}) the constraints for the body before
copying its type for each use of the function.  This type is a
simplified form of the constraints generated for the function body.

%%%% NOTE: Should we say that we in fact maintain a type plus an
%%%% environment.


%% The rules for optional types and optional type variables associate, in
%% addition to a constraint set, two type sequence variables where the
%% first one constrains the actual parameters of a type constructor and
%% the second one constrains its arity only.
%

%% Rule~$\MEMgencgrulee$ for value identifiers generates binders for
%% value variables and accessors for datatype constructors using the
%% function $\MEMbindoraccSYMB$ defined as follows:
%% $\MEMbindoracc{\METAvvar}{\METAtyvar}=(\CONSbind{\METAvvar}{\METAtyvar})$
%% and
%% $\MEMbindoracc{\METAdcon}{\METAtyvar}=(\CONSacc{\METAdcon}{\METAtyvar})$.


%%%%% MARK: Reduce and give titles to the paragraphs below.


\subsubsection{Discussion of some constraint generation rules}

\intitle{Recursive value declarations.}
%
In rule~$\MEMgencgrulel$, to handle the recursivity of such
declarations, the environment $\METAcsenv_2$ generated for $\METAexp$
must be in the scope of environment $\METAcsenv_1$ generated for
$\METApat$.
%
The binders in $\METAcsenv_1$ are monomorphic.  Polymorphic type
schemes are generated at constraint solving when dealing with the
$\CONStopolySYMB$ constraint.
%
Within the $\CONStopolySYMB$ environment, binders need to be
monomorphic because \SML\ does not allow polymorphic recursion.
%
Allowing $\CONStopolySYMB$ constraints on environments other than just
a single binder (such as in
$\CONStopoly{\CONSenvenv{\CONSenvenv{\METAacc}{\METAcs}}{\METAbind}}$
where $\METAacc$ could potentially refer to $\METAbind$) allows one to
delay the generation of polymorphic types.  Therefore, given a
recursive function declaration, one can generate only one binder for
the function (in a naive approach two would be needed: one monomorphic
for the function's body and one polymorphic for the function's scope
as mentioned in Sec.~\ref{sec:comparisonpottierremy} below).
%
%% For non-recursive value
%% declarations, we would have to reverse the order:
%% $\CONSenvenv{\METAcsenv_1}{\METAcsenv_2}$, so that for the declaration
%% of, e.g., an identifier \inexamplebody{foo} that uses
%% \inexamplebody{foo} in its definition, then the accessor nested in
%% $\METAcsenv_2$ and generated for \inexamplebody{foo}'s occurrence in
%% the expression part of \inexamplebody{foo}'s declaration will not
%% refer to the binder, accessible in $\METAcsenv_1$, generated for the
%% occurrence of \inexamplebody{foo} being declared (in
%% \inexamplebody{val foo = foo 1}, \inexamplebody{foo}'s second occurrence
%% does not refer to \inexamplebody{foo}'s first occurrence).


\intitle{Recursive datatypes.}
%
In rule~$\MEMgencgrulen$, to handle the recursivity of such
declarations, the environment $\CONStopoly{\METAcsenv_2}$ generated
for the datatype constructor of the declared type constructor must be
in the scope of environment $\METAcsenv_1$ generated for the
declared type constructor.  For example, in the declaration
\inexamplebody{datatype nat = z | s of nat}, \inexamplebody{nat}'s
second occurrence refers to its first occurrence.  Note that
$\METAcsenv_1$ also binds explicit type variables in \CORETES.  This
extends the scope of the bound external type variable further than
needed, but causes no harm in \CORETES, in which all type variables
only occur inside datatype constructor bindings.  This issue is
resolved in \FORMTES~\cite{Rahli:2011} using local environments.


\intitle{Unlabelled equality constraints.}
%
Rules~$\MEMgencgruled$, $\MEMgencgrulel$, $\MEMgencgrulen$,
$\MEMgencgrulep$ and $\MEMgencgruler$ generate unlabelled environment
equality constraints.
%
Given a structure expression $\METAstrexp$ of the form
$\LABstrexpMul{\METAstrdec_1}{\METAstrdec_n}{\METAlab}$,
rule~$\MEMgencgruler$ generates a constraint $\METAcs$ of the form
$\csou{\METAenvvar'}{(\CONSenvenvn{\METAcsenv_n}{\METAcsenv_{n-1}}{\METAcsenv_1})}$.
%
Such a constraint needs to be unlabelled because each $\METAcsenv_i$
does not depend on $\METAstrexp$ itself, but only on the corresponding
declaration $\METAstrdec_i$ which happens to be packed together with
other declarations in $\METAstrexp$.
%%  $\LABstrexpMul{\METAstrdec_1}{\METAstrdec_n}{\METAlab}$
%% (where the $\METAstrdec_i$s are packed together).
%
When slicing out the packaging created by $\METAstrexp$ (by slicing
out $\METAlab$ above), we must not discard the $\METAcsenv_i$s, which
is what would happen if we were to label $\METAcs$ with $\METAlab$ and
discard it when slicing out $\METAlab$.
%, and the typability of such a nested declaration does not depend
%on the structure expression itself.
%
The information related only to $\METAstrexp$, carried by $\METAcs$,
is the fact that a sequence of declarations, corresponding to the
\COMPENV\ $\CONSenvenvn{\METAcsenv_n}{\METAcsenv_{n-1}}{\METAcsenv_1}$,
is packed into a structure.
%
This information depends on $\METAstrexp$ via the extra labelled
equality constraint $\cso{\METAenvvar}{\METAenvvar'}{\METAlab}$.  In
rules~$\MEMgencgruled$,~$\MEMgencgrulel$,~$\MEMgencgrulen$
and~$\MEMgencgrulep$, we use labelled environment variables of the
form $\CONSdepss{\METAenvvar}{\METAlab}$ for this purpose.


\intitle{Environment variables.}
%
Rules~$\MEMgencgruled$, $\MEMgencgrulel$, $\MEMgencgrulen$,
$\MEMgencgrulem$ and $\MEMgencgrulep$ label environment variables.
%
In rule $\MEMgencgrulem$, we do so to prevent sliced out declarations
from shadowing their context.  For example, if $\METAenvvar$ is
unconstrained, it shadows $\METAcsenv$ in
$\CONSenvenv{\METAenvvar}{\METAcsenv}$.  In the other rules we do so
to be able to disconnect accessors from their binders.
%% The labels cannot be placed on the equality constraints because
%% they are not shallow.
%
%
%% For example, if $\METAenvvar$ is unconstrained, it shadows
%% $\METAcsenv$ in $\CONSenvenv{\METAenvvar}{\METAcsenv}$ which is
%% something we do not want to happen in these rules.
%
%% In each of these rules, such an environment variable represents the
%% entire declaration.  For example, in rule~$\MEMgencgrulem$,
%% $\METAenvvar$ represents the entire analysed opening declaration.
%
Let us focus on rule $\MEMgencgrulem$.  In rule~$\MEMgencgrulem$,
$\METAenvvar$ represents the entire opening declaration, and
is labelled with $\METAlab$, the label associated with the declaration.
%
Without $\METAlab$, $\METAenvvar$ would be a constraint that always
has to be satisfied, even when the corresponding opening declaration
has been sliced out.
%
For example, slicing out \inexamplebody{open S} in
\inexamplebody{structure S = struct end; val x = 1; open S; val y = x 1;}
would result in the environment variable generated for
\inexamplebody{open S} shadowing its context which contains
the declaration \inexamplebody{val x = 1}.  Failing from labelling
$\METAenvvar$ using $\METAlab$ in rule~$\MEMgencgrulem$
would prevent
from finding the error that \inexamplebody{x} is declared as an
integer in the piece of code presented above, and is also applied to
an argument in \inexamplebody{y}'s body.
%
With the label, the
environment variable is a constraint that has to be satisfied only
when the declaration is not sliced out.
%% Note that in
%% rule~$\MEMgencgrulem$, the link between the environment variable and
%% the structure to open is made via the labelled accessor.
%
%$\CONSaccl{\METAstrid}{\METAenvvar}{\METAlab}$.}
%

\mynote{(2010-06-25)}{The explanation for open declarations requires
  more explanation or/and an example.}


\mynote{(2010-05-08)}{in $\MEMgencgruler$, we could generate
  $\CONSenvenv{\csou{\METAenvvar'}{(\CONSenvenvn{\METAcsenv_n}{}{\METAcsenv_1})}}{\cso{\METAenvvar}{\METAenvvar'}{\METAlab}}$
  instead so that a dependency not satisfied would mean that the
  entire dependent subtree could be discarded.}

\mynote{(2010-04-13)}{For all the bindings (atomic pattern, datatype
  constructor, datatype name, structure declaration) we need the
  equality constraints which come along so that when we filter the
  constraints we don't have to generate dummy types for our dummy
  environment because the constraints are discarded and so the types
  stored in the bindings are free.}

\mynote{(2010-04-13)}{$\MEMgencgrulen$ is broken for
  \inexamplebody{fn x : 'a => let datatype 'a t = c of 'a in x : 'a end}
  for example because it exports the environment for explicit type variables.}

\mynote{(2010-04-14)}{Structure expressions cannot simply return
  environment because when it such an expression is part of dot term
  then it need to loose its connection to the environment, namely the
  generated $\METAenvvar$.  If structure expressions where generating
  environments of the form $\METAcsenv$ and not a pairs of the form
  $\mytuple{\METAenvvar,\METAcsset}$ then when generating the
  constraints for a structure expression as part of a dot term we
  would need, for example to introduce a new environment variable
  $\METAenvvar'$ and generate $\CONSenvenv{\METAenvvar'}{\METAcsenv}$
  instead of just getting rid of $\METAenvvar$ in the pair
  $\mytuple{\METAenvvar,\METAcsset}$.}



\subsubsection{Constraints generated for example~$\examplerun$ (see Sec.~\ref{sec:syntax})}
\label{sec:genexamplerun}


%% We now present the constraints generated for example~$\examplerun$
%% presented in Sec.~\ref{sec:syntax}.
%
%% First, let us repeat example~$\examplerun$
%% which is the declaration $\METAstrdec_{\mathrm{EX}}$:
%% \begin{center}
%%   \begin{\sizeintablesp}
%%     $\LABstrdecStr
%%     {\LABstrbindBas
%%       {\mbox{\inexamplebody{X}}}
%%       {\LABstrexpFourp
%%         {\LABstrdecStr
%%           {\LABstrbindBas
%%             {\mbox{\inexamplebody{S}}}
%%             {\LABstrexpOne
%%               {\LABstrdecDec
%%                 {\LABdecDat
%%                   {\LABspdatbind
%%                     {\LABdatnamep{\mbox{\inexamplebody{'a}}}{\mbox{\inexamplebody{u}}}{\METAlab_6}}
%%                     {\LABtypeconId{\mbox{\inexamplebody{U}}}{\METAlab_7}}
%%                     {\METAlab_5}
%%                   }
%%                 }
%%               }
%%               {}
%%               {\METAlab_4}
%%             }
%%             {\METAlab_3}
%%           }
%%         }
%%         {\LABstrdecDec
%%           {\LABdecDat
%%             {\LABspdatbind
%%               {\LABdatnamep{\mbox{\inexamplebody{'a}}}{\mbox{\inexamplebody{t}}}{\METAlab_9}}
%%               {\LABtypeconId{\mbox{\inexamplebody{T}}}{\METAlab_{10}}}
%%               {\METAlab_8}
%%             }
%%           }
%%         }
%%         {\LABstrdecDec
%%           {\LABdecVal
%%             {\LABvalbind
%%               {\LABpatAtpat{\LABpatId{\mbox{\inexamplebody{f}}}{\METAlab_{12}}}}
%%               {\LABexpFnp
%%                 {\LABmrule
%%                   {\LABpatAtpat{\LABpatId{\mbox{\inexamplebody{T}}}{\METAlab_{14}}}}
%%                   {\LABexpAtexp{\LABexpId{\mbox{\inexamplebody{T}}}{\METAlab_{15}}}}
%%                   {\METAlab_{13}}
%%                 }
%%                 {}
%%               }
%%               {\METAlab_{11}}
%%             }
%%           }
%%         }
%%         {\LABstrdecDec
%%           {\LABdecVal
%%             {\LABvalbind
%%               {\LABpatAtpat{\LABpatId{\mbox{\inexamplebody{g}}}{\METAlab_{17}}}}
%%               {\LABexpAtexp
%%                 {\LABexpLet
%%                   {\LABdecOpen{\mbox{\inexamplebody{S}}}{\METAlab_{19}}}
%%                   {\LABexpApp
%%                     {\LABexpAtexp{\LABexpId{\mbox{\inexamplebody{f}}}{\METAlab_{21}}}}
%%                     {\LABexpId{\mbox{\inexamplebody{U}}}{\METAlab_{22}}}
%%                     {\METAlab_{20}}
%%                   }
%%                   {\METAlab_{18}}
%%                 }
%%               }
%%               {\METAlab_{16}}
%%             }
%%           }
%%         }
%%         {\METAlab_2}
%%       }
%%       {\METAlab_1}
%%     }$
%%   \end{\sizeintablesp}
%% \end{center}
%
%
%% We assume in this section that the generated variables and type
%% constructor names are all distinct from each other.

The environment generated for \inexamplebody{datatype 'a u = U},
which we call $\METAcsenv_0$, is as follows:
\begin{center}
  \begin{\sizeintablesp}
    \begin{tabular}{l}
      $\METAcsenv_0$
      \hspace{0.05in}$=$\hspace{0.05in}
      $\CONSexistsenv
             {\mytuple{\METAtyvar_1,\METAtyvar_2,\METAenvvar_4}}
             {(\CONSenvenv
               {\CONSdepss{\METAenvvar_4}{\METAlab_5}}
               {(\csou
                 {\METAenvvar_4}
                 {(\CONSenvenv
                   {\CONSenvenv
                     {\METAcsenv'_0}
                     {\METAcsenv''_0}
                   }
                   {(\cso{\METAtyvar_1}{\METAtyvar_2}{\METAlab_5})})
                 })
               })
             }$
      \\

      \hspace*{0.2in}
      such that
      $\left\{
      \begin{array}{l@{\hspace{0.1in}}l@{\hspace{0.1in}}l}
        \METAcsenv'_0
        & \mbox{is}
        & \CONStopoly{\CONSbindl{\mbox{\inexamplebody{U}}}{\METAtyvar_2}{\METAlab_7}}
        \\
        \METAcsenv''_0
        & \mbox{is}
        & \CONSexistsenv
                    {\mytuple{\METAtyvar'_1,\METAtyname_1}}
                    {\CONSenvenv
                      {\CONSenvenv
                        {(\CONSbindl{\mbox{\inexamplebody{'a}}}{\METAtyvar'_1}{\METAlab_6})}
                        {(\CONSbindl{\mbox{\inexamplebody{u}}}{\METAtyname_1}{\METAlab_6})}}
                      {(\cso{\METAtyvar_1}{\CONSconsty{\METAtyname_1}{\METAtyvar'_1}}{\METAlab_6})}}
      \end{array}
      \right.$
    \end{tabular}
  \end{\sizeintablesp}
\end{center}

The environment generated for
\inexamplebody{structure S = struct datatype 'a u = U end},
which we call $\METAcsenv_1$, is as follows:
\begin{center}
  \begin{\sizeintablesp}
    \begin{tabular}{l}
      $\METAcsenv_1$
      \hspace{0.05in}$=$\hspace{0.05in}
      $\CONSexistsenv
             {\mytuple{\METAenvvar_1,\METAenvvar_2}}
             {\CONSenvenv
               {\CONSdepss{\METAenvvar_1}{\METAlab_3}}
               {\CONSenvenv
                 {(\csou
                   {\METAenvvar_1}
                   {(\CONSbindl{\mbox{\inexamplebody{S}}}{\METAenvvar_2}{\METAlab_3})})
                 }
                 {\csbind
                   {\CONSexistsenv
                     {\mytuple{\METAenvvar_3}}
                     {(\CONSenvenv
                       {(\csou
                         {\METAenvvar_3}
                         {\METAcsenv_0})
                       }
                       {(\cso{\METAenvvar_2}{\METAenvvar_3}{\METAlab_4})})
                     }
                   }
                 }
               }
             }$
    \end{tabular}
  \end{\sizeintablesp}
\end{center}

The environment generated for
\inexamplebody{datatype 'a t = T},
which we call $\METAcsenv_2$ is as follows:
\begin{center}
  \begin{\sizeintablesp}
    \begin{tabular}{l}
      $\METAcsenv_2$
      \hspace{0.05in}$=$\hspace{0.05in}
      $\CONSexistsenv
             {\mytuple{\METAtyvar_3,\METAtyvar_4,\METAenvvar_5}}
             {(\CONSenvenv
               {\CONSdepss{\METAenvvar_5}{\METAlab_8}}
               {(\csou
                 {\METAenvvar_5}
                 {(\CONSenvenv
                   {\CONSenvenv
                     {\METAcsenv'_2}
                     {\METAcsenv''_2}
                   }
                   {(\cso{\METAtyvar_3}{\METAtyvar_4}{\METAlab_8})})
                 })
               })
             }$
      \\

      \hspace*{0.2in}
      such that
      $\left\{
      \begin{array}{l@{\hspace{0.1in}}l@{\hspace{0.1in}}l}
        \METAcsenv'_2
        & \mbox{is}
        & \CONStopoly{\CONSbindl{\mbox{\inexamplebody{T}}}{\METAtyvar_4}{\METAlab_{10}}}
        \\
        \METAcsenv''_0
        & \mbox{is}
        & \CONSexistsenv
                    {\mytuple{\METAtyvar'_3,\METAtyname_2}}
                    {\CONSenvenv
                      {\CONSenvenv
                        {(\CONSbindl{\mbox{\inexamplebody{'a}}}{\METAtyvar'_3}{\METAlab_9})}
                        {(\CONSbindl{\mbox{\inexamplebody{t}}}{\METAtyname_2}{\METAlab_9})}
                      }
                      {(\cso{\METAtyvar_3}{\CONSconsty{\METAtyname_2}{\METAtyvar'_3}}{\METAlab_9})}
                    }
      \end{array}
      \right.$
    \end{tabular}
  \end{\sizeintablesp}
\end{center}

The environment generated for
\inexamplebody{val rec f = fn T => T},
which we call $\METAcsenv_3$ is as follows:
\begin{center}
  \begin{\sizeintablesp}
    \begin{tabular}{l}
      $\METAcsenv_3$
      \hspace{0.05in}$=$\hspace{0.05in}
      $\CONSexistsenv
             {\mytuple{\METAtyvar_5,\METAtyvar_6,\METAenvvar_6}}
             {\CONSenvenv
               {\CONSdepss{\METAenvvar_6}{\METAlab_{11}}}
               {(\csou
                 {\METAenvvar_6}
                 {\CONStopoly
                   {\CONSenvenv
                     {\CONSenvenv
                       {(\cso{\METAtyvar_5}{\METAtyvar_6}{\METAlab_{11}})}
                       {\METAcsenv'_3}}
                     {(\CONSbindl{\mbox{\inexamplebody{f}}}{\METAtyvar_5}{\METAlab_{12}})}
                   }
                 })
               }
             }$
      \\

      \hspace*{0.2in}
      such that
      $\METAcsenv'_3
      =\csbind
      {\CONSexistsenv
        {\mytuple{\METAtyvar_7,\METAtyvar_8,\METAenvvar_7}}
        {\CONSenvenv
          {\CONSenvenv
            {\CONSenvenv
              {(\cso
                {\METAtyvar_6}
                {\METAlabtyarrowp{\METAtyvar_7}{\METAtyvar_8}{}}
                {\METAlab_{13}})
              }
              {(\CONSaccl{\mbox{\inexamplebody{T}}}{\METAtyvar_8}{\METAlab_{15}})}
            }
            {\CONSdepss{\METAenvvar_7}{\METAlab_{13}}}
          }
          {(\csou
            {\METAenvvar_7}
            {(\CONSaccl{\mbox{\inexamplebody{T}}}{\METAtyvar_7}{\METAlab_{14}})})
          }
        }
      }$
    \end{tabular}
  \end{\sizeintablesp}
\end{center}

The environment generated for
\inexamplebody{val rec g = let open S in f U end},
which we call $\METAcsenv_4$ is as follows:
\begin{center}
  \begin{\sizeintablesp}
    \begin{tabular}{l}
      $\METAcsenv_4$
      \hspace{0.05in}$=$\hspace{0.05in}
      $\CONSexistsenv
             {\mytuple{\METAtyvar_9,\METAtyvar_{10},\METAenvvar_8}}
             {\CONSenvenv
               {\CONSdepss{\METAenvvar_8}{\METAlab_{16}}}
               {(\csou
                 {\METAenvvar_8}
                 {\CONStopoly
                   {\CONSenvenv
                     {\CONSenvenv
                       {(\cso{\METAtyvar_{9}}{\METAtyvar_{10}}{\METAlab_{16}})}
                       {\csbind
                         {\CONSexistsenv
                           {\METAtyvar_{11}}
                           {\CONSenvenv
                             {\CONSenvenv
                               {(\cso{\METAtyvar_{10}}{\METAtyvar_{11}}{\METAlab_{18}})}
                               {\METAcsenv''_4}
                             }
                             {\METAcsenv'_4}
                           }
                         }
                       }
                     }
                     {(\CONSbindl{\mbox{\inexamplebody{g}}}{\METAtyvar_{9}}{\METAlab_{17}})}
                   }
                 })
               }
             }$
      \\

      \hspace*{0.2in}
      such that
      $\left\{
      \begin{array}{l@{\hspace{0.1in}}l@{\hspace{0.1in}}l}
        \METAcsenv'_4
        & \mbox{is}
        & \CONSexistsenv
                   {\METAenvvar_9}
                   {\CONSenvenv
                     {\CONSdepss{\METAenvvar_{9}}{\METAlab_{19}}}
                     {(\CONSaccl{\mbox{\inexamplebody{S}}}{\METAenvvar_{9}}{\METAlab_{19}})}
                   }
        \\
        \METAcsenv''_4
        & \mbox{is}
        &
        \CONSexistsenv
            {\mytuple{\METAtyvar_{12},\METAtyvar_{13}}}
            {\CONSenvenv
              {\CONSenvenv
                {(\cso{\METAtyvar_{12}}{\METAlabtyarrowp{\METAtyvar_{13}}{\METAtyvar_{11}}{}}{\METAlab_{20}})}
                {(\CONSaccl{\mbox{\inexamplebody{U}}}{\METAtyvar_{13}}{\METAlab_{22}})}
              }
              {(\CONSaccl{\mbox{\inexamplebody{f}}}{\METAtyvar_{12}}{\METAlab_{21}})}
            }
      \end{array}
      \right.$
    \end{tabular}
  \end{\sizeintablesp}
\end{center}

Finally, the environment generated for the entire piece of code is the
following environment which we call $\METAcsenv_{\mathrm{EX}}$:
\begin{center}
  \begin{\sizeintablesp}
    \begin{tabular}{l}
      $\METAcsenv_{\mathrm{EX}}$
      \hspace{0.05in}$=$\hspace{0.05in}
      $\CONSexistsenv
             {\mytuple{\METAenvvar_{11},\METAenvvar_{10}}}
             {\CONSenvenv
               {\CONSdepss{\METAenvvar_{10}}{\METAlab_1}}
               {\CONSenvenv
                 {(\csou
                   {\METAenvvar_{10}}
                   {(\CONSbindl{\mbox{\inexamplebody{X}}}{\METAenvvar_{11}}{\METAlab_1})})
                 }
                 {\csbind
                   {\CONSexistsenv
                     {\mytuple{\METAenvvar_{12}}}
                     {\CONSenvenv
                       {(\csou
                         {\METAenvvar_{12}}
                         {(\CONSenvenvfour
                           {\METAcsenv_4}
                           {\METAcsenv_3}
                           {\METAcsenv_2}
                           {\METAcsenv_1})
                         })
                       }
                       {(\cso{\METAenvvar_{11}}{\METAenvvar_{12}}{\METAlab_{2}})}
                     }
                   }
                 }
               }
             }$
    \end{tabular}
  \end{\sizeintablesp}
\end{center}



\subsection{\SECsolving}
\label{sec:unification}


%% \hidden{
%% Our unification algorithm is divided into
%% two solvers: the environment solver (Fig.~\ref{fig:buildenv}) and the
%% equality constraint solver (Fig.~\ref{fig:unifAlgoOpen}).
%% %  We start by
%% %presenting relations used by our unification algorithm.
%% %% which is defined at the end of this section.
%% Unification is heavily used by enumeration and minimisation to decide
%% the solvability of a particular environment filtering
%% (Fig.~\ref{fig:csfiltering}).}


\subsubsection{Syntax}
%
\begin{\myfigure}[t]
  \begin{\sizeintables}
    \begin{tabular}{ r c l r l}
      $\METAuniferrorkind$ & $\in$ & $\SETuniferrorkind$ & $::=$  & $\CONSuniferrortyconsclashp{\METAnamety_1}{\METAnamety_2}$\\
%                                                           $\mid$   $\CONSuniferrorcircularityp$\\
      %      $\METAunifstate$     & $\in$ & $\SETunifstate$     & $::=$  & $\MEMconsStateEnvp{\METAunifstatety}{\METAcsenv}{\METAtvbinder}$
      $\METAerror$         & $\in$ & $\SETerror$         & $::=$  & $\CONSerror{\METAuniferrorkind}{\METAcdepset}$\\
    \end{tabular}
    \hspace{0.2in}
    \begin{tabular}{ r c l r l}
      $\METAunifterm$      & $\in$ & $\SETunifterm$      & $::=$  & $\CONSunifenv{\METAunifstate}{\METAcdepset}{\METAcsenv}{\METAcsenv'}$
                                                           $\mid$   $\CONSunifsuccess{\METAunifstate}{\METAcsenv}$
                                                           $\mid$   $\CONSuniferror{\METAerror}$
    \end{tabular}
  \end{\sizeintables}
  \caption{Syntactic forms used by the constraint solver}
  \label{fig:unifSyntaxOpen}
\end{\myfigure}
%
Fig.~\ref{fig:unifSyntaxOpen} defines additional syntactic forms used
by our constraint solver (see Fig.~\ref{fig:unifAlgoOpen}) where a
constraint solving step is defined by the
relation $\fra$, and where $\ffra$ is
its reflexive (w.r.t.\ $\SETunifterm$) and transitive closure.
%% In this section we present different
%% relations used by our unification algorithm and at the end of this
%% section provide the definition of our algorithm.
%
%
% where $\METAunifstatety$ is a unifier and $\METAcsenv$
%a type environment.
% and a mapping $\METAtvbinder$.
%
%
%
%% \hidden{
%% The domain of a $\METAtvbinder$ is a
%% monomorphic type variable set indicating for each state of a
%% constraint solving
%% computation which type variables are not allowed to be generalised.
%% %
%% In a $\METAtvbinder$, the dependencies associated to a type variable
%% are the ``reasons'' for it to be monomorphic.
%% %
%% For example in
%% \inexamplebody{fn z => let val f = fn x => z x in (f 1, f()) end}
%% \inexamplebody{f}'s type cannot be generalised to a type scheme
%% because its type depends on \inexamplebody{z}'s type which is
%% monomorphic, \inexamplebody{z} being the pattern of a fn-expression.
%% }
%
%
Given an environment $\METAcsenv$ to solve, our constraint solver
starts in the state
$\CONSunifenv{\MEMconsStateEnvp{\emptyset}{\CONSenvnul}{}}{\emptyset}{\METAcsenv}{\CONSenvnul}$,
%% where $\CONSenvnul$ is called the
%% %
%% \index{initial environment}%
%% %
%% \emph{initial environment}
%% and $\MEMconsStateEnvp{\emptyset}{\CONSenvnul}{}$ the
%% %
%% \index{initial context}%
%% %
%% \emph{initial context}.
%
and either succeeds with final state
$\CONSunifsuccess{\METAunifstate}{\METAcsenv'}$
% (if the constraints are solvable)
returning its current \CONTEXT\ $\METAunifstate$ and $\METAcsenv'$,
the ``solved'' version of $\METAcsenv$, or
fails with final state $\CONSuniferror{\METAerror}$
% (if the constraints are unsolvable)
returning an error which can only be a type constructor clash in
\CORETES\ (see $\METAuniferrorkind$ in
Fig.~\ref{fig:unifSyntaxOpen}).
% or a status clash (discussed below with the
%$\MEMcompStatusSYMB$ relation).
%
%% The $\METAtycons$'s extend the type constructor variables
%% ($\METAtynamevar$) and names ($\METAtyname$)
%% with the arrow type constructor $\MEMtyarrow$.
%%   The function
%% $\MEMtoptyconSYMB$ is used by our unification algorithm to distinguish
%% between a used defined type constructor ($\METAnamety$) and the arrow
%% type constructor, but also to distinguish between two different used We extract the top type
%% constructor of a type or an internal type constructor as follows:
%
%
Given a state $\CONSunifenv{\METAunifstate}{\METAcdepset}{\METAcsenv}{\METAcsenv'}$,
if the dependencies in $\METAcdepset$ are satisfied
and $\METAcsenv$ is solvable in the \CCONTEXT\ $\METAunifstate$
then the constraint solver succeeds with final state
$\CONSunifsuccess{\METAunifstate'}{\CONSenvenv{\METAcsenv''}{\METAcsenv'}}$
for some $\METAunifstate'$ and $\METAcsenv''$.


\mynote{(2010-03-31)}{Provided among other things that our algorithm
  terminates.}


%% \intitle{Environment composition.}
%% %% Let
%% %% $\MEMrestropn{\METAopenenvseq}{\METAgenidset}
%% %% =
%% %% \{\asgn{i}{\MEMopenenv{\METAstrid}{\METAlab}{\METAgenidset'\cup\METAgenidset}}
%% %% \mid
%% %% \afunc{\METAopenenvseq}{i}=\MEMopenenv{\METAstrid}{\METAlab}{\METAgenidset'}\}$
%% %
%% During unification we maintain a type environment ($\METAcsenv$ in
%% $\METAunifstate$) in a ``normal form'' to ease its access (see
%% environment application below).
%% Such a ``normal form'' is as follows:
%% $\CONSenvenvn{\METAcsenv_0}{\METAcsenv_1}{\METAcsenv_n}$
%% where $n\geq{0}$, for all $i\in\{0,\dots,n\}$, $\METAcsenv_i$ is
%% not of the form $\CONSenvenv{\METAcsenv}{\METAcsenv'}$
%% and if $\METAcsenv_0\in\SETbind$ then $\METAcsenv_1\not\in\SETbind$.
%% If $\METAcsenv_0\in\SETbind$ then $\METAcsenv_0$ is the visible usable
%% part of the environment and if $\METAcsenv_1$ exists then it shadows
%% the rest of the environment (the $\METAcsenv_i$'s for $i>1$).  Such a
%% shadowing $\METAcsenv_1$ is an environment variable
%% $\METAenvvar$ which stands for any environment and could potentially
%% define a mapping for any identifier.
%% %
%% The function $\MEMcupenvSYMB$ is used by $\MEMupdateenvSYMB$ during a
%% unification computation to maintain the shape of the type environments
%% ($\METAcsenv$) stored in the unification contexts
%% ($\METAunifstate$) stored in the unification states ($\METAunifterm$)
%% of the computation.  It is also used by $\MEMcompenvtermSYMB$ used
%% itself by our environment solver (Fig.~\ref{fig:buildenv}) to build
%% the current environment being solved.
%% %
%% In both these functions, $\MEMcupenvSYMB$ composes
%% two environments $\METAcsenv_2$ and $\METAcsenv_1$ which are already
%% in ``normal forms'' and where $\METAcsenv_2$ has been used as
%% part of the type environment to solve $\METAcsenv_1$.
%% %
%% During unification, the $\METAcsenv$ stored in a $\METAunifstate$
%% does not contain any equality constraint set $\METAcsset$ because they
%% are unified and transformed into unifiers of the form
%% $\METAunifstatety$ (see rules $\unifruleesone$ and $\unifrulenineteen$
%% in Fig.~\ref{fig:unifAlgoOpen}).
%% Moreover, if we unify a constraint set generated by our constraint
%% generator then such an $\METAcsenv$ cannot contain any accessor (in
%% $\SETsem$) because an accessor is only generated as the left-hand-side
%% of an equality constraint and is either transformed into a
%% non-accessor or discarded during the unification of the constraint
%% (see rules $\unifruleaeone$ and $\unifruleaetwo$ in
%% Fig.~\ref{fig:unifAlgoOpen}).
%% %
%% Similarly environments of the form $\CONStopoly{\METAcsenv}$ are
%% transformed by our environment solver (Fig.~\ref{fig:buildenv}) and
%% environments of the form $\CONSopen{\METAcsenv}{\METAlab}$ are
%% transformed by our filtering function (Fig.~\ref{fig:csfiltering}).
%% %
%% We compose environments as follows:
%% \begin{center}
%%   \begin{\sizeintables}
%%     \begin{tabular}{ l }
%%       $\MEMcupenvp{\CONSenvenvn{\METAcsenv_1}{\METAcsenv_2}{\METAcsenv_n}}{\METAcsenv_0}$
%%       \\
%%       $=\left\{
%%       \begin{array}{ll}
%%         \CONSenvenvn{(\METAcsenv_1\MEMplusenv\METAcsenv_0)}{\METAcsenv_2}{\METAcsenv_n},
%%         &
%%         \mbox{if }\METAcsenv_0,\METAcsenv_1\in\SETbind
%%         \\
%%         \CONSenvenvn{\CONSenvenv{\METAcsenv_0}{\METAcsenv_1}}{\METAcsenv_2}{\METAcsenv_n},
%%         &
%%         \mbox{otherwise}
%%       \end{array}
%%       \right.$
%%       \\
%%       where $\METAcsenv_1$ is not of the form $\CONSenvenv{\METAcsenv}{\METAcsenv'}$
%%     \end{tabular}
%%   \end{\sizeintables}
%% \end{center}

%% %% \begin{center}
%% %% \begin{\sizeintables}
%% %% \begin{tabular}{ l l r l }
%% %%   (1)
%% %%   & $\MEMcupenv{\CONSenvenv{\METAbind_1}{\CONSenvenvn{\METAbind_2}{\METAcsenv_1}{\METAcsenv_n}}}$
%% %%   & $=$
%% %%   & $\CONSenvenvn{(\METAbind_2\MEMplusenv\METAbind_1)}{\METAcsenv_1}{\METAcsenv_n}$
%% %%   \\
%% %%   & \multicolumn{3}{l}{\hspace*{0.1in}
%% %%     where $n\geq{0}$
%% %%   }
%% %%   \\

%% %%   (2)
%% %%   & $\MEMcupenv{\CONSenvenv{\METAcsenv_0}{\CONSenvenvn{\METAcsenv_1}{\METAcsenv_2}{\METAcsenv_n}}}$
%% %%   & $=$
%% %%   & $\CONSenvenvn{\CONSenvenv{\METAcsenv_0}{\METAcsenv_1}}{\METAcsenv_2}{\METAcsenv_n}$
%% %%   \\
%% %%   & \multicolumn{3}{l}{\hspace*{0.1in}
%% %%     where $n\geq{1}$ and
%% %%     if (1) does not apply
%% %%     and $\METAcsenv_1$ is not of the form $\CONSenvenv{\METAcsenv}{\METAcsenv'}$
%% %%   }
%% %% \end{tabular}
%% %% \end{\sizeintables}
%% %% \end{center}

%% \mynote{(2010-04-13)}{We could also collapse the $\METAbind$s inside a
%%   $\METAcsenv$, but we don't need to because if they are not collapsed
%%   already it means that they are shadowed.  And
%%   similarly empty $\METAbind$s could be discarded.}

%% \ifcomm
%% \begin{spnote}{(2010-04-13)}
%% \begin{center}
%% \begin{\sizeintables}
%% \begin{tabular}{ l l r l }
%%   (1)
%%   & $\MEMcupenv{\CONSenvenv{\METAcsenv_1}{\CONSenvenv{\METAcsenv_2}{\METAcsenv_3}}}$
%%   & $=$
%%   & $\MEMcupenv{\CONSenvenv{\CONSenvenv{\METAcsenv_1}{\METAcsenv_2}}{\METAcsenv_3}}$
%%   \\
%%   %% & \multicolumn{3}{l}{\hspace*{0.1in}
%%   %%   if $\METAcsenv'_1=\MEMcupenv{\METAcsenv_1}$
%%   %%   and $\METAcsenv'_2=\MEMcupenv{\METAcsenv_2}$
%%   %% }
%%   %% \\

%%   (2)
%%   & $\MEMcupenv{\CONSenvenv{\CONSenvenv{\METAcsenv_1}{\METAcsenv_2}}{\METAcsenv_3}}$
%%   & $=$
%%   & $\MEMcupenv{\CONSenvenv{\CONSenvenv{\CONSenvenv{\METAcsenv_1}{\METAcsenv}}{\METAcsenv'}}{\METAcsenv_3}}$
%%   \\
%%   & \multicolumn{3}{l}{\hspace*{0.1in}
%%     if (1) does not apply
%%     and $\METAcsenv_2=\CONSenvenv{\METAcsenv}{\METAcsenv'}$
%%   }
%%   \\

%%   (3)
%%   & $\MEMcupenv{\CONSenvenv{\CONSenvenv{\METAcsenv}{\METAbind_1}}{\METAbind_2}}$
%%   & $=$
%%   & $\MEMcupenv{\CONSenvenv{\METAcsenv}{\METAbind_2\MEMplusenv\METAbind_1}}$
%%   \\

%%   (4)
%%   & $\MEMcupenv{\CONSenvenv{\METAbind_1}{\METAbind_2}}$
%%   & $=$
%%   & $\METAbind_2\MEMplusenv\METAbind_1$
%%   \\

%%   (5)
%%   & $\MEMcupenv{\CONSenvenv{\METAcsenv_1}{\METAcsenv_2}}$
%%   & $=$
%%   & $\CONSenvenv{(\MEMcupenv{\METAcsenv_1})}{\METAcsenv_2}$
%%   \\
%%   & \multicolumn{3}{l}{\hspace*{0.1in}
%%     if (1)-(4) do not apply
%%   }
%%   \\

%%   (6)
%%   & $\MEMcupenv{\METAcsenv}$
%%   & $=$
%%   & $\METAcsenv$
%%   \\
%%   & \multicolumn{3}{l}{\hspace*{0.1in}
%%     if $\METAcsenv$ is not of the form $\CONSenvenv{\METAcsenv_1}{\METAcsenv_2}$
%%   }
%% \end{tabular}
%% \end{\sizeintables}
%% \end{center}
%% %% where (4) applies only when
%% %% and where in (5), $\METAcsenv\in\{\METAenvvar,\CONSsems{\METAstrid}{\METAlab},\METAbind\}$.

%% \mynote{(2010-04-13)}{(2) and (6) should never happen, (5) is useless
%%   and we should have a rule for when we haven an empty $\METAbind$ on
%%   the left.}

%% \mynote{2010-04-07}{If we want to collapse the constraint sets such as
%%   in $\CONSenvenv{\CONSenvenv{\METAcsenv}{\METAcsset_1}}{\METAcsset_2}$
%%   we would need rules similar to (3) and (4) for constraint sets that
%%   union them.}
%% \end{spnote}
%% \fi

%% \mynote{2010-04-01}{The statement below has not been proved.}

%% \mynote{(2010-04-14)}{Note that
%% $\MEMcupenv{\METAcsenv}=\CONSenvenv{\cdots\CONSenvenv{\METAcsenv_0}{\METAcsenv_1}}{\METAcsenv_n}$
%% where for all $i\in\{0,\dots,n\}$, $\METAcsenv_i$ is not of the
%% form $\CONSenvenv{\METAcsenv}{\METAcsenv'}$
%% and if $\METAcsenv_0\in\SETbind$ then $\METAcsenv_1\not\in\SETbind$.}
%% %% and for all $i\in\{1,\dots,n\}$,
%% %% if $\METAcsenv_i\in\SETbind$ then
%% %% $\METAcsenv_{i-1}\not\in\SETbind$.

%% \hidden{The high of an environment is defined as follows:
%% $\MEMhighcsenv{\CONSenvenv{\METAcsenv_1}{\METAcsenv_2}}=\MEMhighcsenv{\METAcsenv_2}+1$
%% and $\MEMhighcsenv{\METAcsenv}=0$ if $\METAcsenv$ is not of the form
%% $\CONSenvenv{\METAcsenv_1}{\METAcsenv_2}$.

%% We prove this result by induction on (the number of constructors of)
%% $\METAcsenv$.  The result is trivial if $\METAcsenv$ is not of the
%% form $\CONSenvenv{\METAcsenv_1}{\METAcsenv_2}$, using (6).  Let
%% $\METAcsenv=\CONSenvenv{\METAcsenv_1}{\METAcsenv_2}$ then
%% $\MEMhighcsenv{\METAcsenv}\geq{1}$.  We prove the result by induction
%% on $\METAcsenv$'s high.
%% \begin{itemize}
%% \item If $\MEMhighcsenv{\METAcsenv}=1$ then
%%   $\MEMhighcsenv{\METAcsenv_2}=0$ and so $\METAcsenv_2$ is not of the
%%   form $\CONSenvenv{\METAcsenv_3}{\METAcsenv_4}$.  Let us prove the
%%   result by induction on $\METAcsenv_1$'s high.  If
%%   $\MEMhighcsenv{\METAcsenv_1}=0$ then $\METAcsenv_1$ is not of the
%%   form $\CONSenvenv{\METAcsenv_3}{\METAcsenv_4}$ then we either apply
%%   (4) and conclude trivially or we apply (5) and we conclude by IH
%%   (the one on $\METAcsenv$).  If $\MEMhighcsenv{\METAcsenv_1}=n+1$
%%   then $\METAcsenv_1=\CONSenvenv{\METAcsenv_3}{\METAcsenv_4}$ where
%%   $\MEMhighcsenv{\METAcsenv_4}=n$.  Either we apply (2) and we
%%   conclude by IH (the one on $\MEMhighcsenv{\METAcsenv_1}$) or we
%%   apply (3) and we conclude by IH (the one on $\METAcsenv$) or we
%%   apply (5) and we conclude by IH (the one on $\METAcsenv$).
%% \item $\MEMhighcsenv{\METAcsenv}=n+1$ where $n\geq{1}$.  Then
%%   $\MEMhighcsenv{\METAcsenv_2}=n$ and because  $n\geq{1}$ then
%%   $\METAcsenv_2=\CONSenvenv{\METAcsenv_3}{\METAcsenv_4}$.  We apply
%%   (1) and conclude by IH (the one on $\MEMhighcsenv{\METAcsenv}$).
%% \end{itemize}}


%% \mynote{(2010-03-30)}{When generated, an environment should already be
%%   ``normal form''.}


%% \mynote{2010-03-15}{We don't always reduce an environment.
%%   especially during unification.  \mynote{2010-03-19}{We do now.}}

%% \mynote{2010-03-22}{There's no rule to get rid of empty sets.}


%% \begin{center}
%% \begin{tabular}{lrl}
%%   $\MEMcupenvseq{\MEMconsenv{\emptyset}{\METAbool}}$
%%   & $=$
%%   & $\emptyset$
%%   \\

%%   $\MEMcupenvseq{\MEMconsenv{\mytuple{\METAbind}}{\METAbool}}$
%%   & $=$
%%   & $\MEMconsenv{\mytuple{\METAbind}}{\METAbool}$
%%   \\

%%   $\MEMcupenvseq{\MEMconsenv{\mytuple{x}@\METAcsenvseq}{\METAbool}}$
%%   & $=$
%%   & $\MEMconsenv{\mytuple{x}@\MEMcupenvseq{\METAcsenvseq}}{\METAbool}$
%%   $\mbox{ if }x\in\{\METAenvvar,\CONSsems{\METAstrid}{\METAlab},\MEMenvcs{\METAcsenv}{\METAcsset}\}$
%%   \\

%%   $\MEMcupenvseq{\MEMconsenv{\mytuple{\METAcsenvseq'}@\METAcsenvseq}{\METAbool}}$
%%   & $=$
%%   & $\MEMcupenvseq{\MEMconsenv{\METAcsenvseq'@\METAcsenvseq}{\METAbool}}$
%%   \\

%%   $\MEMcupenvseq{\MEMconsenv{\mytuple{\METAbind,\METAbind'}@\METAseqenvseq}{\METAbool}}$
%%   & $=$
%%   & $\MEMcupenvseq{\MEMconsenv{\mytuple{\METAbind+\METAbind'}@\METAseqenvseq}{\METAbool}}$
%%   \\

%%   $\MEMcupenvseq{\MEMconsenv{\mytuple{\METAbind,\MEMconsenv{\METAcsenvseq'}{\METAbool'}}@\METAcsenvseq}{\METAbool}}$
%%   & $=$
%%   & $\MEMcupenvseq{\MEMconsenv{\mytuple{\METAbind}@\METAcsenvseq'@\METAcsenvseq}{\METAbool}}$
%%   \\

%%   $\MEMcupenvseq{\MEMconsenv{\mytuple{\METAbind,x}@\METAcsenvseq}{\METAbool}}$
%%   & $=$
%%   & $\MEMconsenv{\mytuple{\METAbind,x}@\MEMcupenvseq{\METAcsenvseq}}{\METAbool}$
%%   $\mbox{ if }x\in\{\METAenvvar,\CONSsems{\METAstrid}{\METAlab},\MEMenvcs{\METAcsenv}{\METAcsset}\}$
%%   \\

%%   $\MEMcupenv{\METAcsenv}$
%%   & $=$
%%   & $\METAcsenv$
%%   $\mbox{ if }\METAcsenv\in\{\METAenvvar,\METAbind,\CONSsems{\METAstrid}{\METAlab},\MEMenvcs{\METAcsenv}{\METAcsset}\}$
%%   \\

%%   $\MEMcupenv{\MEMconsenv{\METAcsenvseq}{\METAbool}}$
%%   & $=$
%%   & $\left\{
%%   \begin{array}{ l l }
%%     \METAcsenv
%%     &
%%     \mbox{if }\MEMcupenvseq{\METAcsenvseq}=\MEMconsenv{\METAcsenv}{\METAbool}
%%     \\
%%     \MEMcupenvseq{\METAcsenvseq}
%%     &
%%     \mbox{otherwise}
%%   \end{array}
%%   \right.$
%% \end{tabular}
%% \end{center}


%% \mynote{2010-03-15}{The $\MEMdomSYMB$ function is meant to be used on
%%   fully simplified environment using the $\MEMcupenvSYMB$ function.}



%% \newtext{
%% To maintain this shape of environments in unification contexts, we
%% define $\MEMputdepsSYMB$ to place dependencies on binders as follows:
%% \begin{center}
%%   \begin{\sizeintables}
%%     \begin{tabular}{lll}
%%       $\MEMputdeps{\CONSenvenv{\METAcsenv_2}{\METAcsenv_1}}{\METAcdepset}$
%%       & $=$
%%       & $\CONSenvenv{\MEMputdeps{\METAcsenv_2}{\METAcdepset}}{\MEMputdeps{\METAcsenv_1}{\METAcdepset}}$
%%       \\

%%       $\MEMputdeps{\CONSbindl{\METAgenid}{x}{\METAcdepset}}{\METAcdepset'}$
%%       & $=$
%%       & $\CONSbindl{\METAgenid}{x}{\METAcdepset\cup\METAcdepset'}$
%%       \\

%%       $\MEMputdeps{\METAcsenv}{\METAcdepset}$
%%       & $=$
%%       & $\METAcsenv$, if none of the above applies
%%     \end{tabular}
%%   \end{\sizeintables}
%% \end{center}
%% }


%% \mynote{(2010-04-14)}{
%% During unification the $\METAcsenv$ stored into a $\METAunifstate$
%% is of the form $\CONSenvenvn{\METAcsenv_0}{\METAcsenv_1}{\METAcsenv_n}$,
%% and is kept in such a form thanks to $\MEMcupenvSYMB$,
%% where for all $i\in\{0,\dots,n\}$, $\METAcsenv_i$ is not of the form
%% $\CONSenvenv{\METAcsenv}{\METAcsenv'}$
%% and if $\METAcsenv_0$ is of the form $\METAbind$
%% then $\METAcsenv_1\not\in\SETbind$.
%% Now, when applying
%% $\METAcsenv$ to an identifier $\METAgenid$ five different situations
%% can arise.
%% %
%% (1)~Either $\METAcsenv_0$ is not a $\METAbind$, e.g., if $\METAcsenv$
%% is the environment generated by our constraint generator for the
%% declaration sequence \inexamplebody{val x = 1 open S} and $\METAgenid$
%% is \inexamplebody{x} then because of the \inexamplebody{open},
%% $\METAcsenv_0$ is a $\METAenvvar$ which is not constrained to be equal
%% to a $\METAbind'$ and then shadows the $\METAcsenv_i$'s for $i>0$.
%% %
%% (2)~Or $\METAcsenv_0$ is a $\METAbind$ in which $\METAgenid$ is not
%% declared and $\METAcsenv_1$ shadows the rest of the environment on its
%% left in which $\METAgenid$ is declared, e.g., if $\METAcsenv$ is the
%% environment generated by our constraint generator for the declaration
%% sequence \inexamplebody{val x = 1 open S val y = 1} and $\METAgenid$
%% is \inexamplebody{x} then because of the \inexamplebody{open},
%% $\METAcsenv_1$ is a $\METAenvvar$ which is not constrained to be equal
%% to a $\METAbind'$ and then shadows the $\METAcsenv_i$'s for $i>1$.
%% %
%% (3)~Or some constraints in $\METAcsenv$ are filtered out (see
%% Fig.~\ref{fig:csfiltering} presenting constraint filtering and
%% Sec.~\ref{sec:enumeration} presenting enumeration which makes use of
%% filtering) but if they were not then one of the $\METAcsenv_i$
%% would result from a $\METAenvvar$ being constrained to
%% be equal to a $\METAbind'$ and $\METAgenid$ would be in
%% $\MEMdom{\METAcsenv_i}$, e.g., if $\METAcsenv$ is the environment
%% generated by our constraint generator for the declaration sequence
%% \inexamplebody{structure S = struct val x = 1 end open S} and
%% $\METAgenid$ is \inexamplebody{x} and if the constraints associated to
%% \inexamplebody{S}'s declaration are filtered out then one of the
%% $\METAcsenv_i$ is a $\METAenvvar$ which is not
%% constrained to be equal to a $\METAbind'$, but would have been if no
%% constraint was filtered out, and this $\METAenvvar$ shadows the
%% $\METAcsenv_j$'s for $j>i$.
%% \mynote{(2010-04-15)}{(3) should be split into two cases as for (1)
%%   and (2) because $i$ can only be $0$ or $1$.}
%% %
%% (4)~Or $\METAgenid$ is free, e.g., if $\METAcsenv$ is the environment
%% generated for the declaration sequence
%% \inexamplebody{structure S = struct val z = 1 end open S}
%% and $\METAgenid$ is \inexamplebody{x} which is free in the declaration
%% sequence.
%% %
%% (5)~Or $\METAgenid\in\MEMdom{\METAbind}$, e.g., if $\METAcsenv$ is the
%% environment generated for the declaration sequence
%% \inexamplebody{open S val x = 1} and $\METAgenid$ is \inexamplebody{x}
%% and if during unification no constraint is
%% filtered out then $\METAgenid\in\MEMdom{\METAbind}$ where $\METAbind$
%% is the mapping generated for the declaration \inexamplebody{val x = 1}.
%% }

%% if $\METAcsenv=\METAbind$ then
%% $\afunc{\METAcsenv}{\METAgenid}=\afunc{\METAbind}{\METAgenid}$,
%% if
%% %% $\METAcsenv=\MEMconsenv{\METAcsenvseq@\mytuple{\METAcsenv'}}{\METAbool}$
%% %% or
%% $\METAcsenv=\MEMenvcs{\METAcsenv'}{\METAcsset}$
%% or
%% $\METAcsenv=\CONSenvenv{\METAcsenv'}{\METAcsenv''}$
%% then $\afunc{\METAcsenv}{\METAgenid}=\afunc{\METAcsenv'}{\METAgenid}$
%% otherwise it is undefined.


%% \mynote{2010-03-15}{We also have to go down inside the constraint sets
%%   because of the environment constraints.}


%% \hidden{
%% \intitle{Unification context access.}
%% %
%% Let
%% $\METAunifstate=\MEMconsStateEnvp{\METAunifstatety}{\METAcsenv}{\METAtvbinder}$.
%% Let us consider the following definitions to access and
%% apply a unification context:
%% % syntactic sugar and definitions:
%% \begin{center}
%% \begin{\sizeintables}
%%   %% \begin{tabular}{ l l l }
%%   %%   $\MEMgetunifty{\METAunifstate}$
%%   %%   & $=$
%%   %%   & $\METAunifstatety$
%%   %% \end{tabular}
%%   %% \hspace*{0.1in}
%%   %% \begin{tabular}{ l l l }
%%   %%   $\MEMgetunifid{\METAunifstate}$
%%   %%   & $=$
%%   %%   & $\METAcsenv$
%%   %% \end{tabular}
%%   %% \hspace*{0.1in}
%%   %% \begin{tabular}{ l l l }
%%   %%   $\MEMgetunifmb{\METAunifstate}$
%%   %%   & $=$
%%   %%   & $\METAtvbinder$
%%   %% \end{tabular}

%%   %% \begin{tabular}{ l l l }
%%   %%   $\MEMdomid{\METAunifstate}$
%%   %%   & $=$
%%   %%   & $\MEMdom{\METAcsenv}$
%%   %% \end{tabular}
%%   %% \hspace*{0.1in}
%%   %% \begin{tabular}{ l l l }
%%   %%   $\MEMdomty{\METAunifstate}$
%%   %%   & $=$
%%   %%   & $\MEMdom{\METAunifstatety}$
%%   %%   \\
%%   %%   $\MEMdommb{\METAunifstate}$
%%   %%   & $=$
%%   %%   & $\MEMdom{\METAtvbinder}$
%%   %% \end{tabular}
%%   %% \hspace*{0.2in}
%%   \begin{tabular}{ l l l }
%%     $\afunc{\METAunifstate}{\METAvar}$
%%     & $=$
%%     & $\afunc{\METAunifstatety}{\METAvar}$
%%     \\
%%     $\afunc{\METAunifstate}{\METAgenid}$
%%     & $=$
%%     & $\afunc{\METAcsenv}{\METAgenid}$
%%   \end{tabular}
%% \end{\sizeintables}
%% \end{center}

%% \mynote{(2010-04-14)}{$\afunc{\METAcsenv}{\METAgenid}$ has just been
%%   defined in previous division called ``Environment application''.}
%% }

%% \mynote{2010-03-19}{$\MEMdomidSYMB$ is not used and this function is
%%   the only reason we define $\MEMdom{\METAcsenv}$ at the beginning.}

%% Let $\MEMdom{\METAenvstateid}$
%% be
%% $\MEMdom{\METAenvstatevid}\cup\MEMdom{\METAenvstatetyp}\cup\MEMdom{\METAenvstatestr}$
%% such that
%% $\METAenvstateid=\mytuple{\METAenvstatevid,\METAenvstatetyp,\METAenvstatestr,\METAincopn}$.


%% \intitle{Access to the environment.}
%% Let $\MEMpopenv{\METAunifstate}{\METAgenid}=x$
%% such that $\afunc{\METAunifstate}{\METAgenid}=y@\mytuple{x}$
%% and undefined otherwise


%% \intitle{Embedding of an $\METAcsenv$ into a $\METAenvstateid$.}
%% $$\MEMenvtostate{\METAcsenv}=
%% \left\{
%% \begin{array}{ l l }
%%   \{\asgn{\METAgenid}{\mytuple{\afunc{\METAbind}{\METAgenid}}}\mid\METAgenid\in\MEMdom{\METAbind}\}
%%   &
%%   \mbox{if }\METAcsenv=\METAbind
%%   \\
%%   \mbox{undefined}
%%   &
%%   \mbox{otherwise}
%% \end{array}
%% \right.$$

%% \hidden{
%% \intitle{Monomorphic type variables.}
%% %
%% The $\MEMgetmonobindSYMB$ functions are used by $\MEMupdateuniSYMB$
%% and $\MEMupdateenvSYMB$ (defined below) during unification to update
%% the monomorphic type variable map ($\METAtvbinder$) stored in a
%% unification context $\METAunifstate$.
%% For example the following constraint is
%% generated for \inexamplebody{fn x => x}:
%% \begin{center}
%%   \begin{\sizeintables}
%%     \begin{tabular}{l}
%%       $\csbind
%%       {\CONSdepss{\{
%%           \CONSvidsemm
%%               {\mbox{\inexamplebody{x}}}
%%               {\METAtyvar}
%%               {\CONSstatusu}
%%               \}}{\METAlab_1}}
%%       {\CONSenvenv
%%         {\CONSdepss{\{\csou{\METAtyvar}{\METAlabtyarrowp{\METAtyvar_1}{\METAtyvar_2}{\METAlab}}{}{}\}}{\METAlab}}
%%         {\CONSdepss{\{\csou{\CONSsemv{\mbox{\inexamplebody{x}}}{\CONSstatusu}}{\METAtyvar_2}{}{}\}}{\METAlab_2}}
%%       }$
%%     \end{tabular}
%%   \end{\sizeintables}
%% \end{center}
%% where
%% %where $\METAcsset=\{\csol{\CONSsemv{\mbox{\inexamplebody{x}}}{\CONSstatusu}}{\METAtyvar_3}{\METAlab_2}{}{},\csol{\METAtyvar}{\METAlabtyarrowp{\METAtyvar_1}{\METAtyvar_3}{\METAlab}}{\METAlab}{}{}\}$
%% $\METAlab_i$ is the label associated to the $i$th occurrence of
%% \inexamplebody{x}, and $\METAlab$ is the label associated to the
%% fn-expression.
%% %
%% When solving the environment binding \inexamplebody{x} (between
%% $\csbindL$ and $\csbindI$), we need to remember that
%% \inexamplebody{x}'s type is monomorphic when solving the constraints
%% on the right of $\csbindI$.
%% Monomorphic type variables are extracted as follows:
%% \begin{center}
%% \begin{\sizeintables}
%%   \begin{tabular}{ l l l }
%%     $\MEMgetmonobindb{\METAunifstate}{\METAlabty}$
%%     & $=$
%%     & $\{\asgn{\METAtyvar}{\MEMdepset{\METAlabty}}\mid\METAtyvar\in\MEMvarset{\METAlabty}\setminus\MEMdom{\afunc{\METAunifstate}{2}}\}$
%%   \end{tabular}
%%   \begin{tabular}{ l l l }
%%     $\MEMgetmonobindb{\METAunifstate}{\METAcsenv}$
%%     & $=$
%%     & $\left\{
%%     \begin{array}{l}
%%       \MEMfdunionSYMB_{\CONSvidsem{\METAlabty}{\METAstatus}\in\MEMran{\METAbind}}\MEMgetmonobindb{\METAunifstate}{\CONSdepss{\METAlabty}{\METAcdepset}},
%%       \mbox{if }\METAcsenv=\CONSdepss{\METAbind}{\METAcdepset}
%%       \\
%%       \emptyset, \mbox{otherwise}
%%     \end{array}
%%     \right.$
%%     %% \\

%%     %% $\MEMgetmonobindb{\METAbind}{\METAunifstate}$
%%     %% & $=$
%%     %% & $\{\asgn{\METAtyvar}{\METAcdepset}
%%     %% \mid
%%     %% \afunc{\METAbind}{\METAid}=\MEMbindvv{\METAlabty}{\CONSmono}{\METAstatus}{\METAcdepset}$
%%     %% \\
%%     %% & & \hspace*{0.45in}$\wedge
%%     %% \METAtyvar\in\MEMvarset{\METAlabty}\setminus\MEMdom{\afunc{\METAunifstate}{2}}\}$
%%     %% \\

%%     %% $\MEMgetmonobindt{\METAlabty}{\METAcdepset}{\METAunifstate}$
%%     %% & $=$
%%     %% & $\MEMgetmonobindb{\{\MEMbindv{\METAid}{\METAlabty}{\CONSmono}{\CONSstatusu}{\METAcdepset}\}}{\METAunifstate}$
%%   \end{tabular}
%% \end{\sizeintables}
%% \end{center}

%% \mynote{(2010-04-26)}{$\MEMgetmonobindSYMB$ is never applied on type schemes.}

%% \mynote{(2010-04-20)}{We don't gather the dependencies for a type
%%   variable to be monomorphic if it happens in $\MEMgetmonobindSYMB$
%%   that a type variable $\METAtyvar\in\MEMvarset{\METAlabty}$ is
%%   already in $\MEMdom{\afunc{\METAunifstate}{2}}$ because the first
%%   set $\METAcdepset$ already stored in $\METAunifstate$
%%   ($\METAcdepset=\afunc{\afunc{\METAunifstate}{2}}{\METAtyvar}$) is
%%   already enough to explain that the $\METAtyvar$ is monomorphic.  It
%%   is not like combining the solving of two constraints where we need
%%   to combine the dependencies because both calculation are needed to
%%   get the new combined constraint.  In the case of monomorphic type
%%   variable the first computation already gives us the information that
%%   we need.}
%% }



%% \intitle{Constraint flattening.}
%% %
%% $\MEMflatcsSYMB$ is used by $\MEMpushenvidSYMB$ to transform a
%% constraint $\METAcs$ into a unifier as follows:
%% \begin{center}
%% \begin{\sizeintables}
%%   $x\in\SETvar
%%   \Rightarrow
%%   \MEMflatcs{\cso{x}{y}{\METAcdepset}}=\{\asgn{x}{\MEMconsegid{y}{\METAcdepset}}\}$
%% \end{\sizeintables}
%% \end{center}


%% \intitle{Unification context updating.}
%% %% If $f,f'\in\func{s}{\MEMfintuple{s'}}$
%% %% then
%% %% $$\MEMpushenvid{f}{f'}
%% %% =
%% %% \MEMrestrictout{f}{\MEMdom{f'}}
%% %% \cup
%% %% \MEMrestrictout{f'}{\MEMdom{f}}
%% %% \cup
%% %% \{\asgn{x}{\afunc{f}{x}}@\afunc{f'}{x}
%% %% \mid
%% %% x \in \MEMdom{f}\cap\MEMdom{f'}\}$$
%% %
%% %% We update the different components of a unification context as
%% %% follows:
%% %% if
%% %
%% %% then
%% Our environment solver (Fig.~\ref{fig:buildenv}) updates the type
%% environment ($\METAcsenv$) part
%% % and the monomorphic type variable
%% %($\METAtvbinder$) parts
%% of a unification context
%% $\METAunifstate=\MEMconsStateEnvp{\METAunifstatety}{\METAcsenv}{\METAtvbinder}$
%% as follows:
%% \begin{center}
%%   \begin{\sizeintables}
%%     \begin{tabular}{ l l l }
%%       $\MEMupdateenv{\METAunifstate}{\METAcsenv'}$
%%       & $=$
%%       & $\MEMconsStateEnvp
%%       {\METAunifstatety}
%%       {\CONSenvenv{\METAcsenv'}{\METAcsenv}}
%%       {\MEMfdunion{\METAtvbinder}{\MEMgetmonobindb{\METAunifstate}{\METAcsenv'}}}$
%%       %% \\

%%       %% %% $\MEMupdatemtv{\METAunifstate}{\METAtvbinder'}$
%%       %% %% & $=$
%%       %% %% & $\MEMconsStateEnvp
%%       %% %% {\METAunifstatety}
%%       %% %% {\METAcsenv}
%%       %% %% {\MEMfdunion{\METAtvbinder}{\METAtvbinder'}}$
%%       %% %% \\

%%       %% $\MEMupdatemtv{\METAunifstate}{\METAbind}$
%%       %% & $=$
%%       %% & $\MEMconsStateEnvp
%%       %% {\METAunifstatety}
%%       %% {\METAcsenv}
%%       %% {\MEMfdunion{\METAtvbinder}{\MEMgetmonobindb{\METAbind}{\METAunifstate}}}$
%%       %% \\
%%     \end{tabular}
%%   \end{\sizeintables}
%% \end{center}


%% Our constraint set solver (Fig.~\ref{fig:unifAlgoOpen})
%% updates the unifier ($\METAunifstatety$) part
%% % and the monomorphic type
%% % variable ($\METAtvbinder$) parts
%% of a unification context
%% $\METAunifstate=\MEMconsStateEnvp{\METAunifstatety}{\METAcsenv}{\METAtvbinder}$
%% as follows:
%% \begin{center}
%% \begin{\sizeintables}
%%   \begin{tabular}{ l l l }
%%     $\MEMupdateuni{\METAunifstate}{\mytuple{\METAvar,x}}$
%%     & $=$
%%     & $\left\{
%%     \begin{array}{l}
%%       \METAunifstate,
%%       \mbox{if }\METAvar\in\SETfreshvar
%%       \\
%%       \MEMconsStateEnvp
%%           {\MEMfdunion{\METAunifstatety}{\{\asgn{\METAvar}{x}\}}}
%%           {\METAcsenv}
%%           {\MEMfdunion{\METAtvbinder}{\MEMgetmonobindb{\METAunifstate}{\CONSdepss{x}{\METAcdepset}}}},
%%         \mbox{otherwise}
%%     \end{array}
%%     \right.$
%%   \end{tabular}
%% \end{\sizeintables}
%% \end{center}

%% \hidden{
%% \begin{center}
%% \begin{\sizeintables}
%%   \begin{tabular}{ l l l }
%%     $\MEMupdateuni{\METAunifstate}{\mytuple{\METAvar,x}}$
%%     & $=$
%%     &
%%     \\
%%     \multicolumn{3}{l}{
%%       $\left\{
%%       \begin{array}{l}
%%         \METAunifstate,
%%         \mbox{if }\METAvar\in\SETfreshvar
%%         \\
%%         \MEMconsStateEnvp
%%             {\MEMfdunion{\METAunifstatety}{\{\asgn{\METAvar}{x}\}}}
%%             {\METAcsenv}
%%             {\MEMfdunion{\METAtvbinder}{\MEMgetmonobindb{\METAunifstate}{\CONSdepss{x}{\METAcdepset}}}}
%%         \\
%%         \hspace*{0.1in}\mbox{if }\METAvar\mbox{ is an }\METAtyvar\mbox{ not in }\SETfreshvar
%%         \mbox{ and }\afunc{\METAtvbinder}{\METAtyvar}=\METAcdepset
%%         \\
%%         \MEMconsStateEnvp{\MEMfdunion{\METAunifstatety}{\{\asgn{\METAvar}{x}\}}}{\METAcsenv}{\METAtvbinder},
%%         \mbox{otherwise}
%%       \end{array}
%%       \right.$
%%     }
%%   \end{tabular}
%% \end{\sizeintables}
%% \end{center}
%% }

%% Our environment solver updates the type environment of a unification
%% environment while our equality constraint set solver updates the
%% unifier.


%% \mynote{2010-03-17}{$\METAunifstate$ should be called ``state'' and
%%   $\METAunifstatety$ should be called ``uni''.}


%% \intitle{Dependencies updating.}
%% %% (on $\mytuple{x,\METAlabset,\METAidset}$ and $\METAenvterm$)
%% %
%% During unification, $\MEMupdatelabsSYMB$ updates the dependencies of
%% some annotated syntactic forms:
%% \begin{center}
%% \begin{\sizeintables}
%%   \begin{tabular}{ l l l }
%%     %% $\MEMupdatelabs{\mytuple{x,\METAcdepset}}{\METAcdepset'}$
%%     %% & $=$
%%     %% & $\mytuple{x,\METAcdepset\cup\METAcdepset'}$
%%     %% \\

%%     $\MEMupdatelabs{\CONSenvtermsucc{\METAcsenv}{\METAunifstate}}{\METAcdepset}$
%%     & $=$
%%     & $\CONSenvtermsucc{\CONSdepss{\METAcsenv}{\METAcdepset}}{\METAunifstate}$
%%     \\

%%     $\MEMupdatelabs{\CONSenvtermerr{\CONSerror{\METAuniferrorkind}{\METAcdepset'}}}{\METAcdepset}$
%%     & $=$
%%     & $\CONSenvtermerr{\CONSerror{\METAuniferrorkind}{\METAcdepset\cup\METAcdepset'}}$
%%     %% \\

%%     %% $\MEMupdatelabs{\METAunifterm}{\METAcdepset}$
%%     %% & $=$
%%     %% &
%%     %% $\left\{
%%     %% \begin{array}{l}
%%     %%   \CONSenvtermsucc{\MEMupdatelabs{\METAbinds}{\METAcdepset}}{\METAunifstate}
%%     %%   \\
%%     %%   \hspace*{0.1in}\mbox{if }\METAunifterm=\CONSenvtermsucc{\METAbinds}{\METAunifstate}
%%     %%   \\
%%     %%   \CONSenvtermerr{\MEMupdatelabs{\METAerror}{\METAcdepset}}
%%     %%   \\
%%     %%   \hspace*{0.1in}\mbox{if }\METAunifterm=\CONSenvtermerr{\METAerror}
%%     %% \end{array}
%%     %% \right.$
%%   \end{tabular}
%% \end{\sizeintables}
%% \end{center}

%% This function is only partially defined for the cases used by our
%% unification algorithm.

%% We do not update a $\CONSenvtermerr{\METAerror}$ because it means that
%% the error $\METAerror$ has been found at environment solving and that
%% this error does not need more labels/context dependencies to exist.






%% \intitle{Renamings.}
%% %
%% %% A renaming is defined as follows:
%% %% $$
%% %% \METAren\in\SETren=\{\METAren\in\funci{\SETvar}{\SETvar}
%% %% \mid
%% %% \forallexp
%% %%     {\METAs'\in\METAs}
%% %%     {\METAvar\in\METAs'\Rightarrow\afunc{\METAren}{\METAvar}\in\METAs'}
%% %% \wedge
%% %% \MEMdisj{\MEMdom{\METAren},\MEMran{\METAren}}\}
%% %% $$
%% %% where $\METAs\in\{\SETtyvar,\SETtynamevar,\SETseqvar,\SETenvvar\}$.
%% %
%% The application of a renaming is defined as usual and, is denoted
%% $\MEMrenaming{\METAren}{x}$.  A renaming can be applied to any
%% syntactic form.  A renaming is used to instantiate a type scheme.



%% \hidden{
%% \intitle{Looking static semantics up in environments.}
%% %
%% Fig.~\ref{fig:freshening} defines $\MEMfreshSYMB$ which
%% %% allows access to the type environment of
%% %% a unification context $\METAunifstate$.  It
%% computes an identifier's static semantics w.r.t.\ a unification
%% environment $\METAunifstate$.  Type schemes are then instantiated.
%% %
%% For example, in
%% \inexamplebody{let val rec f = fn x => x in f 1 end},
%% \inexamplebody{f}'s second occurrence's type is an instance
%% of the type scheme associated to \inexamplebody{f}'s first occurrence.
%% %Some variables are not ``freshened'': the monomorphic type variables recorded in $\METAunifstate$.
%% A type scheme is instantiated via a renaming.
%% The application of a renaming is defined as usual, and is denoted
%% $\MEMrenaming{\METAren}{x}$.
%% %
%% %
%% \begin{\myfigure}[!th]
%%   \begin{\sizetables}
%%     \begin{tabular}{ l }
%%       $\MEMinferdd
%%       {\MEMfreshstates{\CONSsemi{\METAid}}{\METAvarset}{\METAunifstate}{\mytuple{\MEMrenaming{\METAren}{\METAlabty},\METAstatus}}}
%%       {\afunc{\METAunifstate}{\METAid}=\CONSvidsem{\CONSscheme{\METAtyvarset}{\METAlabty}}{\METAstatus}}
%%       {\MEMdom{\METAren}=\METAtyvarset}
%%       {\MEMdisjvs{\METAvarset\setminus\SETfreshvar,\MEMran{\METAren}}}
%%       {}$

%%       \\

%%       $\MEMinferbb
%%       {\MEMfreshstates{\CONSsemi{\METAgenid}}{\METAvarset}{\METAunifstate}{\afunc{\METAunifstate}{\METAgenid}}}
%%       {\METAgenid\mbox{ is not a }\METAid}
%%       {}$
%%     \end{tabular}
%%   \end{\sizetables}
%%   \caption{Looking identifiers' static semantics up in unification contexts}
%%   \label{fig:freshening}
%% \end{\myfigure}
%% }


%% \intitle{State constraining.}
%% %
%% An environment $\METAcsenv$ constrains a unification state $\METAenvterm$ as follows:
%% \begin{center}
%% \begin{\sizeintables}
%%   $\begin{array}{l}
%%     \MEMcompenvterm{\METAcsenv}{\METAenvterm}
%%     =\left\{
%%     \begin{array}{l}
%%       \CONSenvtermsucc{\CONSenvenv{\METAcsenv'}{\METAcsenv}}{\METAunifstate}
%%       \\
%%       \hspace*{0.1in}\mbox{if }\METAenvterm=\CONSenvtermsucc{\METAcsenv'}{\METAunifstate}
%%       \\
%%       \METAenvterm\mbox{ otherwise}
%%     \end{array}
%%     \right.
%%   \end{array}$
%% \end{\sizeintables}
%% \end{center}

%% Our environment solver uses $\MEMcompenvtermSYMB$ to constrain the
%% results of $\METAcsenv_1$'s solving with the result of
%% $\METAcsenv_2$'s solving when solving a constrained environment
%% $\CONSenvenv{\METAcsenv_1}{\METAcsenv_2}$.


%% \intitle{Dependency extraction.}
%% %
%% The function $\MEMbindtobindsSYMB$ is used by our binding solver and
%% by the function $\MEMtopolySYMB$, both defined in
%% Fig.~\ref{fig:buildenv}, to transform a $\METAbind$ into a
%% $\METAbinds$:
%% %
%% \begin{center}
%% \begin{\sizeintables}
%%   $\MEMbindtobinds{\METAbind}
%%   =
%%   \MEMbindss{\METAbind}{\cup_{\METAgenid\in\MEMdom{\METAbind}}\afunc{\afunc{\METAbind}{\METAgenid}}{1}}$
%% \end{\sizeintables}
%% \end{center}


%% \mynote{2010-03-19}{It seems that these functions
%%   ($\MEMgetlabsenvSYMB$ and $\MEMgetvidsenvSYMB$) are now used only on
%%   $\METAbind$s.  They are used when building a binding during
%%   unification and also during minimisation.}


%% \intitle{Monomorphic to polymorphic environments.}
%% %
%% \begin{center}
%%   \begin{\sizeintables}
%%   \end{\sizeintables}
%% \end{center}

%% \mynote{(2010-04-15)}{The $\METAbind$ is always a monomorphic
%%   environment for (one) value identifiers.}

%% %% \begin{center}
%% %%   \begin{\sizeintables}
%% %%     $\MEMtopoly{\METAenvterm}
%% %%     =\left\{
%% %%     \begin{array}{l}
%% %%       \CONSenvtermsucc{\METAbinds'}{\METAunifstate'},
%% %%       \\
%% %%       \hspace*{0.1in}\mbox{if }\METAenvterm=\CONSenvtermsucc{\METAbinds}{\METAunifstate}
%% %%       \\
%% %%       \hspace*{0.1in}\mbox{and }\mytuple{\METAunifstate',\METAbinds'}
%% %%       =\MEMtopolyu{\METAunifstate}{\METAbinds}
%% %%       \\
%% %%       \METAenvterm, \mbox{ otherwise}
%% %%     \end{array}
%% %%     \right.$
%% %%   \end{\sizeintables}
%% %% \end{center}

%% \mynote{(2010-04-15)}{This division needs to be merged with the other
%%   one with the same name.}

%% \mynote{(2010-04-15)}{TO FINISH!}

%% \hidden{
%% \subsubsection{Building of constraint terms}
%% %
%% We defined a substitution operation in
%% Sec.~\ref{sec:constraintsystem}.  Let us now define a new substitution
%% operation called ``build'' that differs from the one defined in
%% Sec.~\ref{sec:constraintsystem} by the facts that:
%% %% it does not descend
%% %% into environments (this is not required because our constraint solver
%% %% defined in Fig.~\ref{fig:unifAlgoOpen} does the work of building up
%% %% environments, and especially makes use of $\MEMbuildtySYMB$ to build
%% %% up environment variables),
%% %
%% it is recursively called in the variable
%% case, it is undefined on $\CONSschemeSYMB$ schemes and environments,
%% and it collapses dependencies.  The constraint solver defined in
%% Fig.~\ref{fig:unifAlgoOpen} uses $\MEMbuildtySYMB$ to generate,
%% w.r.t.\ a given \CONTEXT, polymorphic types from monomorphic ones
%% ($\MEMbuildtySYMB$ is called by $\MEMtopolySYMB$ in
%% Fig.~\ref{fig:monotopoly}) and check circularity errors (in order not to
%% generate a unifier where, e.g.,
%% $\METAtyvar=\CONSarrowty{\METAlabty}{\METAtyvar}$):
%% %% , and build up some
%% %% forms of environments (environment variables):
%% \begin{center}
%% \begin{\sizeintablesp}
%% \begin{tabular}{ l l l }
%%     %% \multicolumn{3}{l}{
%%     %%   \mytitle{Type building}
%%     %% }
%%     %% \\

%%     $\MEMbuildty{\METAvar}{\METAunifstatety}$
%%     & $=$
%%     & $\left\{
%%     \begin{array}{ll}
%%       \MEMbuildty{x}{\METAunifstatety},
%%       &
%%       \mbox{if }\afunc{\METAunifstatety}{\METAvar}=x
%%       \\
%%       \METAvar,
%%       &
%%       \mbox{otherwise}
%%     \end{array}
%%     \right.$
%%     \\

%%     $\MEMbuildty{\CONSconsty{\METAnamety}{\METAlabty}}{\METAunifstatety}$
%%     & $=$
%%     & $\CONSconsty{\MEMbuildty{\METAnamety}{\METAunifstatety}}{\MEMbuildty{\METAlabty}{\METAunifstatety}}$
%%     \\
%% \end{tabular}
%% \hspace{0.1in}
%% \begin{tabular}{ l l l }
%%     $\MEMbuildty{\CONSarrowty{\METAlabty_1}{\METAlabty_2}}{\METAunifstatety}$
%%     & $=$
%%     & $\CONSarrowty{\MEMbuildty{\METAlabty_1}{\METAunifstatety}}{\MEMbuildty{\METAlabty_2}{\METAunifstatety}}$
%%     \\

%%     $\MEMbuildty{\CONSdepss{x}{\METAcdepset}}{\METAunifstatety}$
%%     & $=$
%%     & $\MEMcollapse{\CONSdepss{\MEMbuildty{x}{\METAunifstatety}}{\METAcdepset}}$
%%     \\

%%     $\MEMbuildty{x}{\METAunifstatety}$
%%     & $=$
%%     & $x$,
%%     otherwise
%%     %if none of the above applies
%%     %if $x$ is $\CONSint$ or a $\METAtyname$
%% \end{tabular}
%% \end{\sizeintablesp}
%% \end{center}
%% We also extend the $\MEMbuildtySYMB$ function to \CONTEXTS\ as
%% follows:
%% \begin{center}
%%   \begin{\sizeintablesp}
%%     $\MEMbuildty{x}{\MEMconsStateEnvp{\METAunifstatety}{\METAcsenv}{}}$
%%     $=$
%%     $\MEMbuildty{x}{\METAunifstatety}$.
%%   \end{\sizeintablesp}
%% \end{center}

%% Types have to be built up when generating polymorphic environments
%% (see Sec.~\ref{sec:topoly}) for efficiency issues (to avoid
%% duplicating constraints).
%% %
%% %% NOTE (jbw): As specified here can also cause catastrophic
%% %% efficiency losses due to exponential explosions in the sizes of
%% %% types.  For example:
%% %% $\MEMbuildty{\METAtyvar_1}{\{\asgn{\METAtyvar_i}{\CONSarrowty{\METAtyvar_{i+1}}{\METAtyvar_{i+1}}}\mid{i}\in\{1,\dots,100\}\}}$.
%% %
%% Also, because \SML\ does not allow infinite types, we use
%% $\MEMbuildtySYMB$ to detect circularity issues.  During constraint
%% solving, before augmenting any \CONTEXT, we check if the augmentation
%% could lead to the generation of infinite types (see rule
%% $\unifrulenineteen$
%% % of our constraint solver defined
%% in Fig.~\ref{fig:unifAlgoOpen}).  For example, given the unifier
%% $\{\asgn{\METAtyvar_1}{\CONSdepss{\METAtyvar_2}{\METAcdepset_1}},
%% \asgn{\METAtyvar_2}{\CONSdeps{\CONSarrowty{\CONSdepss{\METAtyvar_3}{\METAcdepset_3}}{\CONSdepss{\METAtyvar_4}{\METAcdepset_4}}}{\METAcdepset_2}}\}$,
%% we do not allow its augmentation with, e.g.,
%% $\{\asgn{\METAtyvar_3}{\CONSdeps{\CONSarrowty{\CONSdepss{\METAtyvar_5}{\METAcdepset_6}}{\CONSdepss{\METAtyvar_1}{\METAcdepset_7}}}{\METAcdepset_5}}\}$
%% because it would allow one to generate infinite types.

%% Note that $\MEMsubstitution{\METAunifstatety}{\METAlabty}$ and
%% $\MEMbuildty{\METAlabty}{\METAunifstatety}$ do not always yield the
%% same result.
%% %
%% Consider the unifier
%% $\METAunifstatety=\{\asgn{\METAtyvar_1}{\METAtyvar_2},\asgn{\METAtyvar_2}{\METAtyvar_3}\}$
%% where $\MEMdisjvs{\METAtyvar_1,\METAtyvar_2,\METAtyvar_3}$.  Then
%% $\MEMsubstitution{\METAunifstatety}{\METAtyvar_1}=\METAtyvar_2$ but
%% $\MEMbuildty{\METAtyvar_1}{\METAunifstatety}=\METAtyvar_3$.  The
%% result would be the same if $\METAunifstatety$ was idempotent (i.e.,
%% if we had
%% $\MEMsubstitution{\METAunifstatety}{\METAunifstatety}=\METAunifstatety$).
%% }



%% \subsubsection{Environment difference}
%% %
%% We now define the difference operation on environements (used by rules
%% $\unifruleesone$ and
%% %$\unifrulebinda$,
%% $\unifrulepolya$
%% % and $\unifrulepolyb$
%% of our constraint solver (see Fig.~\ref{fig:unifAlgoOpen}) to extract
%% environments generated during solving).
%% %
%% %
%% It is defined as follows:
%% \begin{center}
%%   \begin{\sizeintables}
%%     \begin{tabular}{llll}
%%       $\MEMsolvedenv{\METAcsenv}{\METAcsenv}$
%%       & $=$
%%       & $\CONSenvnul$
%%       &\\

%%       $\MEMsolvedenv{\METAcsenv_1}{(\CONSenvenv{\METAcsenv_3}{\METAcsenv_2})}$
%%       & $=$
%%       & $\CONSenvenv{\METAcsenv_3}{(\MEMsolvedenv{\METAcsenv_1}{\METAcsenv_2})}$
%%       & if $\METAcsenv_1\not=(\CONSenvenv{\METAcsenv_3}{\METAcsenv_2})$
%%     \end{tabular}
%%   \end{\sizeintables}
%% \end{center}
%% %
%% \newtext{When solving an environment, it allows one to get back its
%% ``solved version'' once all of its constraints have been dealt with.
%% By ``solved version'' of an environment $\METAcsenv$, we mean the
%% %%% TODO: we use sequence here and not composition, and at this place
%% %%% it seems to fit more?!
%% sequence of environments that has been added to the
%% \CONTEXT\ of the state in which the constraint solving process
%% was when it started to solve $\METAcsenv$.}
%% %
%% For example, if
%% $\CONSunifenv
%% {\MEMconsStateEnvp{\METAunifstatety}{\METAcsenv}{}}
%% {\METAcdepset}
%% {\METAcsenv_0}
%% \ffra
%% \CONSunifsuccess{\MEMconsStateEnvp{\METAunifstatety'}{\METAcsenv'}{}}{}$
%% then
%% %$\METAcsenv'=\CONSenvenv{\METAcsenv_n}{\cdots\CONSenvenv{\METAcsenv_2}{\CONSenvenv{\METAcsenv_1}{\METAcsenv}}\cdots}$
%% $\METAcsenv'=\CONSenvenvn{\METAcsenv_n}{}{\CONSenvenv{\METAcsenv_1}{\METAcsenv}}$
%% and
%% %$\MEMsolvedenv{\METAcsenv}{\METAcsenv'}=\CONSenvenv{\METAcsenv_n}{\cdots\CONSenvenv{\METAcsenv_2}{\CONSenvenv{\METAcsenv_1}{\CONSenvnul}}\cdots}$
%% $\MEMsolvedenv{\METAcsenv}{\METAcsenv'}=\CONSenvenvn{\METAcsenv_n}{}{\CONSenvenv{\METAcsenv_1}{\CONSenvnul}}$
%% which is the ``solved version'' of $\METAcsenv_0$ w.r.t.\ $\METAcsenv$.
%% %
%% %Let $\MEMsolvedenv{\METAcsenv_1}{\METAcsenv_2}$ be:
%% %
%% %% \begin{center}
%% %% \begin{\sizeintables}
%% %% \begin{tabular}{lll}
%% %%   $\MEMsolvedenv{\METAcsenv}{\METAcsenv}$
%% %%   & $=$
%% %%   & $\CONSenvnul$
%% %%   \\
%% %% \end{tabular}
%% %% \hspace{0.2in}
%% %% \begin{tabular}{lll}
%% %%   $\MEMsolvedenv{\METAcsenv_1}{\CONSenvenv{\METAcsenv_3}{\METAcsenv_2}}$
%% %%   & $=$
%% %%   & $\CONSenvenv{\METAcsenv_3}{\MEMsolvedenv{\METAcsenv_1}{\METAcsenv_2}}$,
%% %%   if $\METAcsenv_1\not=(\CONSenvenv{\METAcsenv_3}{\METAcsenv_2})$
%% %% \end{tabular}
%% %% \end{\sizeintables}
%% %% \end{center}



%% %% \subsubsection{Polymorphic environments}
%% %% \label{sec:topoly}

%% %% %
%% %% The function $\MEMmonosSYMB$ computes the set of dependent monomorphic
%% %% type variables occurring in an environment w.r.t.\ a unifier as
%% %% follows (the type variables occurring in the types of the monomorphic
%% %% binders):
%% %% \begin{center}
%% %%   \begin{\sizeintablesp}
%% %%     $\MEMmonos{\METAunifstate}
%% %%     =\{\CONSdepss{\METAtyvar}{\MEMdepset{\METAlabty}}
%% %%     \mid
%% %%     \existsexp{\METAid}{
%% %%       \METAlabty=\MEMbuildty{\afunc{\METAunifstate}{\METAid}}{\METAunifstate}
%% %%       \wedge
%% %%       \METAtyvar\in\MEMnondumvarset{\METAlabty}
%% %%     }\}$
%% %% %%\setminus\{\CONSfreshvar{\METAtyvar}\}
%% %%   \end{\sizeintablesp}
%% %% \end{center}
%% %% %
%% %% Note that in $\MEMmonosSYMB$' definition,
%% %% $\METAlabty=\MEMbuildty{\afunc{\METAunifstate}{\METAid}}{\METAunifstate}$
%% %% enforces that $\METAid$ has a monomorphic binder in
%% %% $\METAunifstate$.
%% %% For example, in
%% %% $\MEMconsStateEnvp{\METAunifstatety}{\CONSenvenv{(\CONSbindl{\METAid}{\METAlabty}{\METAcdepset})}{\METAcsenv}}{}$,
%% %% $\METAid$ has a monomorphic binder because $\METAlabty$ is not a
%% %% $\CONSschemeSYMB$ (dependent or not) type scheme.

%% %% Fig.~\ref{fig:monotopoly} defines $\MEMtopolySYMB$ which, given a
%% %% \CONTEXT\ $\METAunifstate$ and a dependent monomorphic value
%% %% identifier binder, generates a polymorphic binder by quantifying the
%% %% type variables not occurring in the types of the monomorphic binders
%% %% of $\METAunifstate$.  The function $\MEMtopolySYMB$ is used by the
%% %% semantic rule~$\RULEsemPoly$ and by the constraint solving
%% %% rule~$\unifrulepolya$.

%% %% \hidden{
%% %% \begin{\myfigure}[t]
%% %%   \begin{\sizeintables}
%% %%     $\begin{array}{l}
%% %%       \MEMtopolyu
%% %%           {\METAunifstate}
%% %%           {\CONSbindl{\METAid}{\METAlabty}{\METAcdepset}}
%% %%       \\
%% %%       =\CONSenvenv
%% %%       {(\CONSbindl
%% %%         {\METAid}
%% %%         {\CONSscheme{\METAtyvarset}{\METAlabty'}}
%% %%         {\METAcdepset\cup\METAcdepset'})
%% %%       }
%% %%       {\METAunifstate}
%% %%       \end{array}$
%% %%     \hspace{0.1in}where
%% %%   $\left\{
%% %%   \begin{array}{lll}
%% %%     \METAlabty'
%% %%     & =
%% %%     & \MEMbuildty{\METAlabty}{\METAunifstate}%
%% %% %     \\
%% %% %%     \METAlabtyset
%% %% %%     =\{\METAlabty_0
%% %% %%     \mid
%% %% %%     \existsexp{\METAid}{
%% %% %%       \METAlabty_1=\afunc{\METAcsenv}{\METAid}
%% %% %%       \wedge
%% %% %%       \METAlabty_0=\MEMbuildty{\METAlabty_1}{\METAunifstatety}\}
%% %% %% %      \wedge
%% %% %% %      \neg\MEMdisj{\MEMvarset{\METAlabty_0},(\MEMvarset{\METAlabty'}\cap\SETtyvar)\setminus\{\CONSfreshvar{\METAtyvar}\}}
%% %% %%     }\}
%% %%     \\
%% %%     \METAtyvarset
%% %%     & =
%% %%     & (\MEMvarset{\METAlabty'}\cap\SETtyvar)\setminus(\MEMvarset{\MEMmonos{\METAunifstate}}\cup\{\CONSfreshvar{\METAtyvar}\})
%% %%     \\
%% %%     \METAcdepset'
%% %%     & =
%% %%     & \{\METAcdep
%% %%     \mid
%% %%     \CONSdepss{\METAtyvar}{\METAcdepset_0\cup\{\METAcdep\}}\in\MEMmonos{\METAunifstate}
%% %%     \wedge
%% %% %    \MEMvarset{\METAlabty_0}\setminus\METAtyvarset\not=\emptyset\}
%% %%     \METAtyvar\in\MEMvarset{\METAlabty'}\setminus\METAtyvarset\}
%% %%   \end{array}
%% %%   \right.$
%% %%   \end{\sizeintables}
%% %%   \caption{Monomorphic to polymorphic environment}
%% %%   \label{fig:monotopoly}
%% %% \end{\myfigure}
%% %% }


%% %% \begin{\myfigure}[t]
%% %%   \begin{\sizeintables}
%% %%     \begin{tabular}{llll}
%% %%       $\MEMtopolyu
%% %%       {\METAunifstate}
%% %%       {\CONSbind{\METAid}{\METAlabty}}$
%% %%       & $=$
%% %%       & $(\CONSbindl
%% %%       {\METAid}
%% %%       {\CONSscheme{\METAtyvarset}{\METAlabty'}}
%% %%       {\METAcdepset})$,
%% %%       & if
%% %%       $\left\{
%% %%       \begin{array}{lll}
%% %%         \METAlabty'
%% %%         & =
%% %%         & \MEMbuildty{\METAlabty}{\METAunifstate}
%% %%         \\
%% %%         \METAtyvarset
%% %%         & =
%% %%         & (\MEMvarset{\METAlabty'}\cap\SETtyvar)\setminus(\MEMvarset{\MEMmonos{\METAunifstate}}\cup\{\CONSfreshvar{\METAtyvar}\})
%% %%         \\
%% %%         \METAcdepset
%% %%         & =
%% %%         & \{\METAcdep
%% %%         \mid
%% %%         \CONSdepss{\METAtyvar}{\METAcdepset_0\cup\{\METAcdep\}}\in\MEMmonos{\METAunifstate}
%% %%         \wedge
%% %%         \METAtyvar\in\MEMvarset{\METAlabty'}\setminus\METAtyvarset\}
%% %%       \end{array}
%% %%       \right.$
%% %%       \\

%% %%       $\MEMtopolyu{\METAunifstate}{\CONSdepss{\METAcsenv_0}{\METAcdepset}}$
%% %%       & $=$
%% %%       & $\CONSdepss{\METAcsenv_1}{\METAcdepset}$,
%% %%       & if
%% %%       $\MEMtopolyu{\METAunifstate}{\METAcsenv_0}
%% %%       =\METAcsenv_1$
%% %%       \\

%% %%       $\MEMtopolyu{\METAunifstate}{\CONSenvenv{\METAcsenv_2}{\METAcsenv_1}}$
%% %%       & $=$
%% %%       & $\METAcsenv'_2$,
%% %%       & if
%% %%       $\MEMtopolyu{\METAunifstate}{\METAcsenv_1}=\METAcsenv'_1$
%% %%       and
%% %%       $\MEMtopolyu{\CONSenvenv{\METAcsenv'_1}{\METAunifstate}}{\METAcsenv_2}=\METAcsenv'_2$
%% %%       \\

%% %%       $\MEMtopolyu{\METAunifstate}{\METAcsenv}$
%% %%       & $=$
%% %%       & $\METAcsenv$,
%% %%       & if none of the above applies
%% %%     \end{tabular}
%% %%   \end{\sizeintables}
%% %%   \caption{Monomorphic to polymorphic environment}
%% %%   \label{fig:monotopoly}
%% %% \end{\myfigure}

%% %% \newtext{In Fig.~\ref{fig:monotopoly}, $\METAlabty$ is the type from which
%% %% a type scheme is generated.  First, we build up $\METAlabty$, using
%% %% the \CONTEXT\ ($\METAunifstate$) of the current state,
%% %% %% (i.e., $\METAunifstatety$ in
%% %% %% $\METAunifstate=\MEMconsStateEnvp{\METAunifstatety}{\METAcsenv}{}$),
%% %% to obtain the type $\METAlabty'$.
%% %% %% The set
%% %% %% $\METAlabtyset$ is the set of types of the monomorphic bindings for
%% %% %% which, the binding currently being generalised, is in the scope.
%% %% The set $\METAtyvarset$ is the set of type variables that are
%% %% % allowed to be
%% %% quantified over because they do not depend on the types of
%% %% monomorphic binders.
%% %% %
%% %% The dependencies set $\METAcdepset'$ ``explains'' why the type variables not in
%% %% $\METAtyvarset$ but occurring in $\METAlabty'$ (therefore depending on
%% %% monomorphic binders) are not allowed to be quantified over.
%% %% %
%% %% Roughly speaking, $\METAtyvarset$ is the set of polymorphic type
%% %% variables in $\METAlabty'$ and
%% %% $\MEMvarset{\METAlabty'}\setminus\METAtyvarset$ is the set of
%% %% monomorphic type variables in $\METAlabty'$.}

%% %% Let us illustrate this mechanism using the fn-expression
%% %% $\METAexp$ defined as follows:
%% %% \begin{center}
%% %%   \begin{\sizeintablesp}
%% %%     \inexamplebody{fn x => let val rec f = fn z => x z in f end}
%% %%   \end{\sizeintablesp}
%% %% \end{center}
%% %% At initial constraint generation, an environment of the
%% %% form $\CONStopoly{\METAcsenv_1}$\footnote{When considering the
%% %%   following labelling:
%% %% $\LABdecVal
%% %% {\LABvalbind
%% %%   {\LABpatAtpat{\LABpatId{\mbox{\inexamplebody{f}}}{\METAlab_6}}}
%% %%   {\LABexpFnp
%% %%     {\LABmrule
%% %%       {\LABpatAtpat{\LABpatId{\mbox{\inexamplebody{z}}}{\METAlab_4}}}
%% %%       {\LABexpApp
%% %%         {\LABexpAtexp{\LABexpId{\mbox{\inexamplebody{x}}}{\METAlab_1}}}
%% %%         {\LABexpId{\mbox{\inexamplebody{z}}}{\METAlab_2}}
%% %%         {\METAlab_3}
%% %%       }
%% %%       {\METAlab_5}
%% %%     }
%% %%     {\METAlab_5}
%% %%   }
%% %%   {\METAlab_7}
%% %% }$,
%% %% the environment $\METAcsenv_1$ is of the form
%% %% $\CONSenvenv
%% %%   {\CONSenvenv
%% %%     {\cso{\METAtyvar_6}{\METAtyvar_5}{\METAlab_7}}
%% %%     {\csbind
%% %%       {\CONSenvenv
%% %%         {\CONSenvenv
%% %%           {\CONSenvenv
%% %%             {\CONSenvenv
%% %%               {\CONSenvenv
%% %%                 {\cso{\METAtyvar_5}{\CONSarrowty{\METAtyvar_4}{\METAtyvar_3}}{\METAlab_5}}
%% %%                 {\cso{\METAtyvar_1}{\CONSarrowty{\METAtyvar_2}{\METAtyvar_3}}{\METAlab_3}}
%% %%               }
%% %%               {\CONSaccl{\mbox{\inexamplebody{z}}}{\METAtyvar_2}{\METAlab_2}}
%% %%             }
%% %%             {\CONSaccl{\mbox{\inexamplebody{x}}}{\METAtyvar_1}{\METAlab_1}}
%% %%           }
%% %%           {\CONSdepss{\METAenvvar}{\METAlab_5}}
%% %%         }
%% %%         {\csou{\METAenvvar}{(\CONSbindl{\mbox{\inexamplebody{z}}}{\METAtyvar_4}{\METAlab_4})}}
%% %%       }
%% %%     }
%% %%   }
%% %%   {\CONSbindl{\mbox{\inexamplebody{f}}}{\METAtyvar_6}{\METAlab_6}}$.}
%% %% is generated for the recursive declaration
%% %% \inexamplebody{val rec f = fn z => x z}.
%% %% When solving the constraints generated for $\METAexp$, the
%% %% constraint solver eventually applies $\MEMtopolySYMB$ to
%% %% a \CONTEXT\
%% %% $\MEMconsStateEnvp{\METAunifstatety}{\METAcsenv}{}$
%% %% and a binder of the form
%% %% $\CONSdeps{\CONSbind{\mbox{\inexamplebody{f}}}{\METAtyvar_1}}{\METAcdepset}$
%% %% (which is the ``solved version'' of $\METAcsenv_1$).
%% %% Building up $\METAtyvar_1$ results in a type $\METAlabty'$ of the form
%% %% $\CONSdeps{\CONSarrowty{\CONSdepss{\METAtyvar_2}{\METAcdepset_2}}{\CONSdepss{\METAtyvar_3}{\METAcdepset_3}}}{\METAcdepset_1}$.
%% %% Because \inexamplebody{x}'s type is monomorphic, a monomorphic binder
%% %% (the only one)
%% %% of the form $\CONSbind{\mbox{x}}{\METAtyvar_0}$
%% %% occurs in $\METAcsenv$ and so
%% %% $\MEMvarset{\MEMmonos{\MEMconsStateEnvp{\METAunifstatety}{\METAcsenv}{}}}=\MEMvarset{\METAlabty_0}$
%% %% % we build a $\METAlabtyset$ (see
%% %% % Fig.~\ref{fig:monotopoly}) of the form $\{\METAlabty_0\}$
%% %% where $\METAlabty_0$ is obtained by building up $\METAtyvar_0$ and is of
%% %% the form
%% %% $\CONSdeps{\CONSarrowty{\CONSdepss{\METAtyvar_2}{\METAcdepset_5}}{\CONSdepss{\METAtyvar_3}{\METAcdepset_6}}}{\METAcdepset_4}$
%% %% (equivalent to $\METAlabty'$ up to dependencies because
%% %% \inexamplebody{f} eta-reduces to \inexamplebody{x}).
%% %% We therefore build a $\METAtyvarset$ (see Fig.~\ref{fig:monotopoly}) of the
%% %% form $\emptyset$ because $\METAtyvar_2$ and $\METAtyvar_3$ both occur
%% %% in $\METAlabty_0$.  We also build a $\METAcdepset'$ of the form
%% %% $\METAcdepset_4\cup\METAcdepset_5\cup\METAcdepset_6$ which are
%% %% the ``reasons'' for not allowing $\METAtyvar_2$ and $\METAtyvar_3$ to
%% %% be in $\METAtyvarset$ (type variable set allowed to be
%% %% generalised over when building the type scheme returned by
%% %% $\MEMtopolySYMB$).  Finally, $\METAcsenv$ is augmented with
%% %% $\CONSdeps{\CONSbind
%% %% {\mbox{\inexamplebody{f}}}
%% %% {\CONSscheme
%% %%   {\emptyset}
%% %%   {\CONSdeps
%% %%     {\CONSarrowty
%% %%       {\CONSdepss{\METAtyvar_2}{\METAcdepset_2}}
%% %%       {\CONSdepss{\METAtyvar_3}{\METAcdepset_3}}
%% %%     }
%% %%     {\METAcdepset_1}
%% %%   }
%% %% }}
%% %% {\METAcdepset\cup\METAcdepset'}$.


%% %% %%% OTHER EXAMPLE



%% %% When solving constraints generated by our constraint
%% %% generator, $\MEMtopolySYMB$ is only applied to
%% %% $\CONSdepss{\METAbind}{\METAcdepset}$'s
%% %% resulting from the solving of an environment wrapped by
%% %% $\CONStopolySYMB$ which in turn is only used to wrap environments built from:
%% %% dependencies, a single monomorphic binder, equality constraints, and accessors
%% %% (see $\SETcsenvp$'s definition in Sec.~\ref{sec:constraintgen}).
%% %% %%  (When
%% %% %% applied on filtered constraints (see Fig.~\ref{fig:csfiltering}),
%% %% %% $\MEMtopolySYMB$ can be applied to $\CONSenvnul$.)



%% %% \newtext{Extracting the monomorphic type
%% %% variables of a binder's type is
%% %% % an
%% %% expensive.
%% %% % computation.
%% %% We only
%% %% perform it once per polymorphic binder by, given a
%% %% \CONTEXT, first building the type of a given binder
%% %% and by then looking up
%% %% %in the environment
%% %% in the \CONTEXT\
%% %% %which type variables cannot
%% %% %be quantified over because they are monomorphic.
%% %% which type variables are monomorphic.
%% %% When accessing the type
%% %% of a polymorphic binder we then only have to generate an instance of
%% %% its type scheme (see rule~$\unifruleacca$ of our constraint solver).}


%% %% \tocheck{In Fig.~\ref{fig:monotopoly}, the computation of $\METAcdepset'$ and
%% %% our constraining of the generated type scheme with $\METAcdepset'$,
%% %% even though a correct approximation (that cannot generate false errors
%% %% and that will eventually allow one to obtain minimal type errors), could
%% %% be refined, thereby speeding up minimisation.  This refinement is
%% %% presented in Sec.~\ref{sec:improvedpoly}.}


%%% (2011-06-20) MARK

\subsubsection{Polymorphic environments}
\label{sec:topoly}
\label{sec:improvedpoly}
%
Let us define the function $\MEMtopolySYMB$
which is used by rule~$\unifrulepolya$ of our constraint solver to
generate polymorphic environments from monomorphic ones by
quantifying the type variables not occurring in the types of the
monomorphic bindings of the current \CONTEXT.
%
%% In this figure
%% %%  $\METAlabtyset$ is the set of types of the monomorphic
%% %% bindings from the current unification context.  The set
%% $\METAtyvarset$
%% is the set of type variables occurring in $\METAlabty'$ (the type that
%% we want to generalise to a $\CONSschemeSYMB$ scheme) that can be
%% generalised and quantified over.  The dependencies in the dependency
%% set $\METAcdepset'$ are the
%% reasons for not generalising the type variables occurring in
%% $\METAlabty'$ that are not in $\METAtyvarset$ (these dependencies are
%% the reasons why some type variables are not allowed to be quantified
%% over).

%% As mentioned in Sec.~\ref{sec:topoly}, the computation of
%% $\METAcdepset'$ and our constraining of the generated type scheme with
%% $\METAcdepset'$, even though a correct approximation, could be
%% refined, thereby speeding up minimisation.  We now present how
%% this can be done.

First, we define functions from internal type variables to dependency
sets as follows:
\begin{center}
  \begin{\sizeintables}
    $\METAtvdeps\in\SETtvdeps=\func{\SETtyvar}{\MEMpowset{\SETdependency}}$
  \end{\sizeintables}
\end{center}
These functions are used to associate blames with type variables as
to why they are monomorphic (because occurring in the type of a
monomorphic binder such as a fn-binder).

Let us now define the two functions $\MEMgetdepsvarSYMB$ and
$\MEMputdepsvarSYMB$.  The application
$\MEMgetdepsvarp{\METAunifstatety}{\METAlabty}$ results in a function
that associates the dependency set occurring in $\METAlabty$ on the
paths from its root node to any free occurrence of $\METAtyvar$, for
each $\METAtyvar$ occurring free in $\METAcsterm$,
w.r.t.\ $\METAunifstatety$.  The application
$\MEMputdepsvar{\METAcsterm}{\METAtvdeps}$ results in the precise constraining
of the free occurrences of $\METAtyvar$ in $\METAcsterm$ with the
dependency set $\afunc{\METAtvdeps}{\METAtyvar}$.  The function
$\MEMgetdepsvarSYMB$ is defined as follows:
\begin{center}
  \begin{\sizeintables}
    \begin{tabular}{lll}
      $\MEMgetdepsvarp{\METAunifstatety}{\METAtyvar}$
      & $=$
      & $\left\{
      \begin{array}{ll}
        \MEMgetdepsvarp{\METAunifstatety}{\METAlabty},
        &
        \mbox{if }\afunc{\METAunifstatety}{\METAtyvar}=\METAlabty
        \\
        \{\asgn{\METAtyvar}{\emptyset}\},
        &
        \mbox{otherwise}
      \end{array}
      \right.$
      \\

      $\MEMgetdepsvarp{\METAunifstatety}{\CONSconsty{\METAnamety}{\METAlabty}}$
      & $=$
      & $\MEMgetdepsvarp{\METAunifstatety}{\METAlabty}$
      \\

      $\MEMgetdepsvarp{\METAunifstatety}{\METAlabtyarrowp{\METAlabty_1}{\METAlabty_2}{}}$
      & $=$
      & $\MEMuenv
      {\MEMgetdepsvarp{\METAunifstatety}{\METAlabty_1}}
      {\MEMgetdepsvarp{\METAunifstatety}{\METAlabty_2}}$
      \\

      $\MEMgetdepsvarp{\METAunifstatety}{\CONSdepss{\METAlabty}{\METAcdepset}}$
      & $=$
      & $\{\asgn{\METAtyvar}{\METAcdepset\cup\METAcdepset'}
      \mid
      \afunc{\MEMgetdepsvarp{\METAunifstatety}{\METAlabty}}{\METAtyvar}=\METAcdepset'\}$
      \\

      $\MEMgetdepsvarp{\MEMconsStateEnvp{\METAunifstatety}{\METAcsenv}{}}{\METAlabty}$
      & $=$
      & $\MEMgetdepsvarp{\METAunifstatety}{\METAlabty}$
    \end{tabular}
  \end{\sizeintables}
\end{center}

The function $\MEMputdepsvarSYMB$ is defined as follows:
\begin{center}
  \begin{\sizeintables}
    \begin{tabular}{lll}
      $\MEMputdepsvar{\METAtyvar}{\METAtvdeps}$
      & $=$
      & $\left\{
      \begin{array}{ll}
        \CONSdepss{\METAtyvar}{\METAcdepset},
        &
        \mbox{if }\afunc{\METAtvdeps}{\METAtyvar}=\METAcdepset
        \\
        \METAtyvar,
        &
        \mbox{otherwise}
      \end{array}
      \right.$
      \\

      $\MEMputdepsvar{\CONSconsty{\METAnamety}{\METAlabty}}{\METAtvdeps}$
      & $=$
      & $\CONSconsty{\METAnamety}{\MEMputdepsvar{\METAlabty}{\METAtvdeps}}$
      \\

      $\MEMputdepsvar{\METAlabtyarrowp{\METAlabty_1}{\METAlabty_2}{}}{\METAtvdeps}$
      & $=$
      & $\CONSarrowty
      {\MEMputdepsvar{\METAlabty_1}{\METAtvdeps}}
      {\MEMputdepsvar{\METAlabty_2}{\METAtvdeps}}$
      \\

      $\MEMputdepsvar{\CONSbind{\METAgenid}{\METAscheme}}{\METAtvdeps}$
      & $=$
      & $(\CONSbind
      {\METAgenid}
      {\MEMputdepsvar{\METAscheme}{\METAtvdeps}})$
      \\

      $\MEMputdepsvar{\CONScsscheme{\METAvarset}{\METAcsenv}{\METAcsterm}}{\METAtvdeps}$
      & $=$
      & $\CONScsscheme
      {\METAvarset}
      {\MEMputdepsvar{\METAcsenv}{\MEMrestrictout{\METAtvdeps}{\METAvarset}}}
      {\MEMputdepsvar{\METAcsterm}{\MEMrestrictout{\METAtvdeps}{\METAvarset}}}$
      \\

      $\MEMputdepsvar{\CONSacc{\METAgenid}{\METAtyvar}}{\METAtvdeps}$
      & $=$
      & $\CONSdepss{(\CONSacc{\METAgenid}{\METAvar})}{\METAcdepset}$,
      if $\afunc{\METAtvdeps}{\METAvar}=\METAcdepset$
      \\

      $\MEMputdepsvar{\csou{\METAcsterm_1}{\METAcsterm_2}}{\METAtvdeps}$
      & $=$
      & $(\csou{\MEMputdepsvar{\METAcsterm_1}{\METAtvdeps}}{\MEMputdepsvar{\METAcsterm_2}{\METAtvdeps}})$
      \\

      $\MEMputdepsvar{\CONStopoly{\METAcsenv}}{\METAtvdeps}$
      & $=$
      & $\CONStopoly{\MEMputdepsvar{\METAcsenv}{\METAtvdeps}}$
      \\

      $\MEMputdepsvar{\CONSexistsenv{\METAatom}{\METAcsenv}}{\METAtvdeps}$
      & $=$
      & $\CONSexistsenv{\METAatom}{\MEMputdepsvar{\METAcsenv}{\MEMrestrictout{\METAtvdeps}{\{\METAatom\}}}}$
      \\

      $\MEMputdepsvar{\CONSenvenv{\METAcsenv_2}{\METAcsenv_1}}{\METAtvdeps}$
      & $=$
      & $\CONSenvenv
      {\MEMputdepsvar{\METAcsenv_2}{\METAtvdeps}}
      {\MEMputdepsvar{\METAcsenv_1}{\METAtvdeps}}$
      \\

      $\MEMputdepsvar{\CONSdepss{\METAcsterm}{\METAcdepset}}{\METAtvdeps}$
      & $=$
      & $\CONSdepss{\MEMputdepsvar{\METAcsterm}{\METAtvdeps}}{\METAcdepset}$
      \\

      $\MEMputdepsvar{\METAcsterm}{\METAtvdeps}$
      & $=$
      & $\METAcsterm$, otherwise
    \end{tabular}
  \end{\sizeintables}
\end{center}

%% Let us now present another way of constraining $\METAlabty'$ from the
%% one in Fig.~\ref{fig:monotopoly} (different from constraining it with
%% $\METAcdepset'$).  In the following, $\METAlabty'$ and $\METAtyvarset$
%% are the same as in Fig.~\ref{fig:monotopoly}.

The function $\MEMmonosSYMB$ computes the set of dependent monomorphic
type variables occurring in an environment w.r.t.\ a unifier as
follows (the type variables occurring in the types of the monomorphic
binders):
\begin{center}
  \begin{\sizeintables}
    $\MEMmonos{\METAunifstate}
    =\MEMuenvp
    {\METAlabty\mbox{ s.t. }\existsexp{\METAid}{\afunc{\METAunifstate}{\METAid}=\CONScsscheme{\emptyset}{\CONSenvnul}{\METAlabty}}}
    {\MEMgetdepsvarp{\METAunifstate}{\METAlabty}}$
  \end{\sizeintables}
\end{center}

For example,
$\MEMmonos
{\MEMconsStateEnvp
  {\{\asgn
    {\METAtyvar}
    {\CONSdepss
      {(\CONSarrowty
        {\CONSdepss{\METAtyvar_1}{\METAcdepset_1}}
        {\CONSdepss{\METAtyvar_2}{\METAcdepset_2}})
      }
      {\METAcdepset_0}}
    \}
  }
  {\CONSbind{\METAid}{\METAtyvar}}
  {}
}
=
\{
\asgn{\METAtyvar_1}{\METAcdepset_0\cup\METAcdepset_1},
\asgn{\METAtyvar_2}{\METAcdepset_0\cup\METAcdepset_2}
\}$.
The type variable $\METAtyvar_1$ occurring in the monomorphic type
associated with $\METAid$,
does not depend on the dependency set $\METAcdepset_2$ but only on
$\METAcdepset_0\cup\METAcdepset_1$ (and similarly for $\METAtyvar_2$).

\hidden{
Now, given a monomorphic binder $\CONSbind{\METAid}{\METAlabty}$ that
we want to transform into a polymorphic binder, and a
\CONTEXT\ $\METAunifstate$ (the context in which
$\CONSbind{\METAid}{\METAlabty}$ is analyzed), $\MEMgettvdepsSYMB$
computes the set of type variables occurring in $\METAlabty$ that are
not allowed to be quantified over (because they occur in
$\MEMmonos{\METAunifstate}$) along with the precise reasons as why
they are not allowed to be quantified over:
\begin{center}
  \begin{\sizeintablesp}
    $\MEMgettvdeps{\METAlabty}{\METAunifstate}
    =
    \{
    \asgn{\METAtyvar}{\cup_{i=1}^{m}\METAcdepset_i}
    \mid
    \MEMmonos{\METAunifstate}=\{\CONSdepss{\METAtyvar}{\METAcdepset_1},\dots,\CONSdepss{\METAtyvar}{\METAcdepset_m}\}\dunion\METAlabtyset
    \wedge
    \METAtyvar\in\MEMvarset{\METAlabty}\setminus\MEMvarset{\METAlabtyset}
    \}$
  \end{\sizeintablesp}
\end{center}
%% is the set of type variables that are not allowed to be quantified
%% in the generated type scheme.  Then,
%% $$
%% \begin{\sizeintables}
%% \forallexp
%% {i\in\{1,\dots,n\}}
%% {\METAcdepset_i=\{\METAcdep
%% \mid
%% \METAlabty_0\in\METAlabtyset
%% \wedge
%% \METAcdep\in\MEMgetdepsvar{\METAlabty_0}{\METAtyvar_i}{\emptyset}\}}
%% \end{\sizeintables}
%% $$
%% is the set of reasons for $\METAtyvar_i$ for not being quantified
%% over.
}

The function $\MEMgatherSYMB$ is used to gather the constraints on a
variable, w.r.t.\ a \CCONTEXT:
\begin{center}
  \begin{\sizeintables}
    \begin{tabular}{lll}
      $\MEMgatherp{\METAunifstate}{\METAvar_1}{\METAvar_2}$
      & $=$
      &
      $\left\{
      \begin{array}{ll}
        \MEMgatherp{\METAunifstate}{\METAvar_1}{\METAcsterm},
        & \mbox{if }\afunc{\METAunifstate}{\METAvar_2}=\METAcsterm
        \\
        \{\csou{\METAvar_1}{\METAvar_2}\}
        & \mbox{if }\afunc{\METAunifstate}{\METAvar_2}\mbox{ is undefined and }
        \METAvar_1\not=\METAvar_2
        \\
        \emptyset
        & \mbox{if }\afunc{\METAunifstate}{\METAvar_2}\mbox{ is undefined and }
        \METAvar_1=\METAvar_2
      \end{array}
      \right.$
      \\

      $\MEMgatherp{\METAunifstate}{\METAvar}{\METAcsterm}$
      & $=$
      & $\{\csou{\METAvar}{\METAcsterm}\}\cup\MEMgather{\METAunifstate}{\METAcsterm}$,
      if $\METAcsterm\not\in\SETvar$
      \\

      $\MEMgather{\METAunifstate}{\METAcsterm}$
      & $=$
      & $\cup_{i\in\{1,\dots,n\}}\MEMgatherp{\METAunifstate}{\METAvar_i}{\METAvar_i}$,
      if $\{\METAvar_1,\dots,\METAvar_n\}=\MEMfreevarset{\METAcsterm}$
      \\

      $\MEMgathera{\METAunifstate}{\METAcsterm}$
      & $=$
      & $\CONSenvenvn{\METAcs_n}{}{\METAcs_1}$,
      if $\MEMgather{\METAunifstate}{\METAcsterm}=\{\METAcs_1\}\dunion\cdots\dunion\{\METAcs_n\}$
    \end{tabular}
  \end{\sizeintables}
\end{center}


Finally, Fig.~\ref{fig:monotopoly} defines $\MEMtopolySYMB$.

\begin{\myfigure}[t]
  \begin{\sizeintables}
    \begin{tabular}{llll}
      $\MEMtopolyu
      {\METAunifstate}
      {\CONSbind{\METAgenid}{\CONScsscheme{\emptyset}{\CONSenvnul}{\METAcsterm}}}$
      & $=$
      & $\CONScsscheme{\METAvarset}{\METAcsenv'}{\METAcsterm'}$,
      & if
      $\left\{
      \begin{array}{lll}
        \METAcsenv
        & =
        & \MEMgathera{\METAunifstate}{\METAcsterm}
        \\
        \METAvarset
        & =
        & \MEMfreevarset{\mytuple{\METAcsenv,\METAcsterm}}\setminus\MEMdom{\MEMmonos{\METAunifstate}}
        \\
        \METAcsterm'
        & =
        & \MEMputdepsvar{\METAcsterm}{\MEMmonos{\METAunifstate}}
        \\
        \METAcsenv'
        & =
        & \MEMputdepsvar{\METAcsenv}{\MEMmonos{\METAunifstate}}
      \end{array}
      \right.$
      \\

      $\MEMtopolyu{\METAunifstate}{\CONSdepss{\METAcsenv}{\METAcdepset}}$
      & $=$
      & $\CONSdepss{\METAcsenv'}{\METAcdepset}$,
      & if $\METAcsenv'=\MEMtopolyu{\METAunifstate}{\METAcsenv}$
      \\

      $\MEMtopolyu{\METAunifstate}{\CONSenvenv{\METAcsenv_2}{\METAcsenv_1}}$
      & $=$
      & $\CONSenvenv{\METAcsenv'_2}{\METAcsenv'_1}$
      & if $\METAcsenv'_1=\MEMtopolyu{\METAunifstate}{\METAcsenv_1}$
      and $\METAcsenv'_2=\MEMtopolyu{\CONSenvenv{\METAcsenv'_1}{\METAunifstate}}{\METAcsenv_2}$
      \\

      $\MEMtopolyu{\METAunifstate}{\METAcsenv}$
      & $=$
      & $\METAcsenv$,
      & if none of the above applies
    \end{tabular}
  \end{\sizeintables}
  \caption{Monomorphic to polymorphic environment}
  \label{fig:monotopoly}
\end{\myfigure}


\subsubsection{Algorithm}
%
%% \begin{\myfigure}[!th]
%%   \input{included/unificationEnv}
%%   \caption{Environment solver}
%%   \label{fig:buildenv}
%% \end{\myfigure}
%

%% Let
%% $\MEMpushunifier{\METAunifstatety_1}{\METAunifstatety_2}$
%% be
%% $\{(\asgn{\METAvar}{x})\in\METAunifstatety_1\cup\METAunifstatety_2
%% \mid
%% \MEMdisj{\{\METAvar,\MEMundep{x}\},\SETfreshvar}\}$
%% if
%% $\MEMdisj{
%%   \MEMrestrictout{\MEMdom{\METAunifstatety_1}}{\SETfreshvar},
%%   \MEMrestrictout{\MEMdom{\METAunifstatety_2}}{\SETfreshvar}
%% }$,
%% and undefined otherwise.
%% %
%% This function allows us, at constraint solving (see
%% rules~$\unifruletwentyone$ and rule~$\unifruleesone$ of our constraint
%% solved defined in Fig.~\ref{fig:unifAlgoOpen}), to generate
%% unifiers which do not constrain dummy variables.
%% % (in $\SETfreshvar$).
%% For example,
%% $\MEMpushunifier{\METAunifstatety}{\{\asgn{\CONSfreshvar{\METAtyvar}}{\METAlabty}\}}
%% = \MEMpushunifier{\METAunifstatety}{\{\asgn{\METAtyvar}{\CONSdepss{\CONSfreshvar{\METAtyvar}}{\METAcdepset}}\}}
%% = \METAunifstatety$.

\begin{\myfigure}[!t]
  \input{included/unificationAlgoOpen}
  \caption{Constraint solver}
  \label{fig:unifAlgoOpen}
\end{\myfigure}
%
Fig.~\ref{fig:unifAlgoOpen} defines
%
\index{constraint solver}%
%
our constraint solver
%
which can be regarded as a rewriting system.
%
A finite computation is then a finite sequence of states
$\mytuple{\METAunifterm_1,\dots,\METAunifterm_n}$ such that for each
$i\in\{1,\dots,n-1\}$, the state $\METAunifterm_{i+1}$ is obtained by
applying one of the constraint solving rules as defined in
Fig.~\ref{fig:unifAlgoOpen} to the state $\METAunifterm_i$ (i.e., the
pair $\mytuple{\METAunifterm_i,\METAunifterm_{i+1}}$ is obtained by
instantiating one of the constraint solving rules, where
$\METAunifterm_i$ is the instantiation of the left-hand-side of the
rule and $\METAunifterm_{i+1}$ is the instantiation of the
right-hand-side).

\newtext{
%The accessor
Rule~$\unifruleaccd$ can be used to report free
identifiers.  If
$\CONSunifenv
{\METAunifstate}
{\METAcdepset}
{\CONSacc{\METAgenid}{\METAvar}}
{\METAcsenv}
\fra
\CONSunifsuccess{\METAunifstate}{\METAcsenv}$ and
$\neg\MEMhidden{\METAunifstate}$ then it means that there is no binder
for $\METAgenid$ and so that it is a free identifier.
%
%
Free identifiers are in any case important to report, but it is
especially vital for structure identifiers in \inexamplebody{open} declarations.
%
In our approach, a free opened structure is considered as potentially
redefining its entire context.
% (via an environment variable).
%
Hence, \inexamplebody{val x = 1; open S; val y = x 1}
%is typable
does not have an error involving \inexamplebody{x}
because
\inexamplebody{x}'s first occurrence is hidden by the declaration
\inexamplebody{open S}.  This could be confusing if \inexamplebody{S}
was not reported as being free.
%
Let us explain how a free opened structure shadows its context.  Given a
declaration \inexamplebody{open S} labelled by $\METAlab$, our initial
constraint generation algorithm generates an environment of the form
$\CONSenvenv
{\CONSdepss{\METAenvvar}{\METAlab}}
{(\CONSaccl{\mbox{\inexamplebody{S}}}{\METAenvvar}{\METAlab})}$.
%where $\METAlab$ is the label labelling the declaration.
Because \inexamplebody{S} is free, rule~$\unifruleaccd$ applies when
solving $\CONSacc{\mbox{\inexamplebody{S}}}{\METAenvvar}$.
The environment variable $\METAenvvar$ is then unconstrained.
Hence, when solving $\METAenvvar$, rule~$\unifrulevara$ applies and
$\CONSenvenv{\METAenvvar}{\METAcsenv}$ (from the right-hand-side of
rule~$\unifrulevara$) results in the shadowing of all the binders in
$\METAcsenv$ by $\METAenvvar$.}


%% Fig.~\ref{fig:buildenv} also defines two functions $\MEMbuildtySYMB$
%% which builds up a type using a unifier $\METAunifstatety$ and
%% $\MEMtopolySYMB$ which transforms a monomorphic environment into a
%% polymorphic one.
%
%% (e.g.,
%% when solvable, solving a $\CONSenvenv{\CONSdepss{\METAbind}{\METAcdep}}{\METAcs}$
%% always produces a $\CONSdepss{\METAbind'}{\METAcdepset}$).
%
%% Our environment solver does not solve accessors because, as explained
%% above, they are transformed or discarded when solving equality
%% constraints.
%
%\intitle{Unification computation predicates.}
%
%Let $\METAunifstate_0=\MEMconsStateEnvp{\emptyset}{\CONSenvnul}{}$.
Let the relations $\MEMgetuniferrorSYMB$ and $\MEMissuccessSYMB$ be
defined as follows:
%
\begin{center}
\begin{\sizeintables}
  \begin{tabular}{ l c l }
    %% $\MEMgetunifsuccess{\METAunifterm}{\METAunifstate}$
    %% & $\iff$
    %% & $\existsexp{\METAbinds}{\METAunifterm\ffra\CONSenvtermsucc{\METAbinds}{\METAunifstate}}$
    %% \\

    %% $\MEMgetuniferror{\METAunifterm}{\METAerror}$
    %% & $\iff$
    %% & $\METAunifterm\ffra\CONSuniferror{\METAerror}$
    %% \\

    %% $\MEMgetunifsuccess{\METAcsenv}{\METAunifstate}$
    %% & $\iff$
    %% & $\CONSunifenv{\METAunifstate_0}{\emptyset}{\METAcsenv}\ffra\CONSunifsuccess{\METAunifstate}{\METAcsenv}$
    %% \\

    $\MEMgetuniferror{\METAcsenv}{\METAerror}$
    & $\iff$
    & $\CONSunifenv{\MEMconsStateEnvp{\emptyset}{\CONSenvnul}{}}{\emptyset}{\METAcsenv}{\CONSenvnul}\ffra\CONSuniferror{\METAerror}$
    \\

    $\MEMissuccess{\METAcsenv}$
    & $\iff$
    & $\existsexp{\METAunifstate}{\CONSunifenv{\MEMconsStateEnvp{\emptyset}{\CONSenvnul}{}}{\emptyset}{\METAcsenv}{\CONSenvnul}\ffra\CONSunifsuccess{\METAunifstate}{\METAcsenv}}$
    \\

    $\MEMissuccess{\METAstrdec}$
    & $\iff$
    & $\existsexp{\METAcsenv}{\typingSCS{\METAstrdec}{\METAcsenv}\wedge\MEMissuccess{\METAcsenv}}$
    %% \\

    %% $\MEMissuccess{\{\csbind{\METAcsenv}{\emptyset}\}}$
    %% & $\iff$
    %% & $\MEMissuccess{\METAcsenv}$
  \end{tabular}
\end{\sizeintables}
\end{center}

These relations are used, among other things, to define our
minimisation and enumeration algorithms in Sec.~\ref{sec:minenum}.

%% \mynote{2010-03-19}{These are not functions because the unification
%%   process is not deterministic.}


\mynote{(2010-04-22)}{There is a problem with freshness.  For example
  when solving a $\CONSenvenv{\METAcsenv_1}{\METAcsenv_2}$, it might
  happen that fresh variables will be generated when first solving
  $\METAcsenv_2$ and that these fresh variables also occur in
  $\METAcsenv_1$.  This might also happen when solving a $\METAbind$.
  To solve this problem we could simply when solving $\METAcsenv_2$,
  add in $\METAunifstate$ an new entry
  $\asgn{\METAenvvar}{\mytuple{\METAcsenv_1,\emptyset}}$ where
  $\METAenvvar$, so that $\METAcsenv_1$ is in $\METAunifstate$ when
  solving $\METAcsenv_2$.  Once $\METAcsenv_2$ is solved we can get
  rid of this entry (we could let it in as well because it does not
  interfere with anything).  To solve the problem we could also add an
  argument when solving environments, but this would be messy.}

\mynote{(2010-04-14)}{We never build an accessor because they are
  never stored in our \CONTEXT\ $\METAunifstate$, they
  are always transformed into non-accessors or discarded when unifying
  equality constraint sets.}

\mynote{2010-03-16}{The building of a $\METAbind$ is non-deterministic
  because of the error we pick.  These functions should be relations
  presented as rewriting systems.}

\mynote{2010-03-19}{We might want to have ``applied and not applied
  value variable'' for, e.g.: \inexamplebody{fn f => fn (f x) => x}.
  There is another kind of error that we might want to report in the
  paper (with extra constraints in
  $\MEMtrimreboundenvSYMB$):
  \inexamplebody{let datatype t = c of int in fn c => c end}
  where \inexamplebody{c} is not applied in the pattern.
  For the other case (c not declared applied but applied in pattern)
  we simply return a type constructor clash when in the implementation
  we report a more specific error
  (\inexamplebody{let datatype t = c in fn (c x) => x end}).}

\mynote{(2010-03-29)}{The problem right now is that we don't catch
  arity clashes for free type constructors.  We would need another
  mapping in the states as in the implementation that records
  information on free type constructors.  Because of the way we
  discard non involved environment, the slicer presented here would
  crash on \inexamplebody{datatype 'a t = C of t -> 'a t} because the
  arity clash involving the two last occurrences of \inexamplebody{t}
  gets caught by the slicer but the minimality would then brake
  because we don't record information on \inexamplebody{t}'s first
  occurrence in rule $\unifruleaeone$ when creating the equality
  constraint on sequence variables.  This could either be solved by
  adding a new field in the constraint solver states for free type
  constructors or by returning more labels for errors such as the one
  presented above.}

\mynote{(2010-03-29)}{A major difference between what we do here and
  what we do in the implementation is that in the here we assume that
  a free structure can declare anything, so the opening of a free
  structure results in the hiding of the whole current typing
  environment.  We might want to put that in the implementation
  section.}


\hidden{
\subsubsection{Shape of the environments generated during constraint solving}
\label{sec:shapeenvsolving}


%
During constraint solving (see Fig.~\ref{fig:unifAlgoOpen}), a
\CONTEXT\ of the form
$\MEMconsStateEnvp{\METAunifstatety}{\METAcsenv}{}$ is maintained.
%
No $\METAcs$ or $\METAacc$ occurs in $\METAcsenv$
because they are transformed instead into unifiers
$\METAunifstatety$ (rules~$\unifruletwentyone$ and~$\unifruleesone$
in Fig.~\ref{fig:unifAlgoOpen}).
%
Similarly, the $\CONStopoly{\METAcsenv'}$ forms are eliminated.
%
%% Moreover, given that a constraint solving process always starts with
%% the initial environment $\CONSenvnul$,
The environment $\METAcsenv$ is
then of the form
%$\CONSenvenv{\METAcsenv_n}{\cdots\CONSenvenv{\METAcsenv_2}{\CONSenvenv{\METAcsenv_1}{\CONSenvnul}}\cdots}$,
$\CONSenvenvn{\METAcsenv_n}{\cdots}{\METAcsenv_1}$,
where each $\METAcsenv_i$
is built from dependencies, binders, environment variables,
\COMPENVS, and $\CONSenvnul$.
%
Such an environment $\METAcsenv$ is of the form $\METAcsenvsolv$
defined as follows:
\begin{center}
  \begin{\sizeintablesp}
    \begin{tabular}{lllrl}
      $\METAbindsolv$
      & $\in$
      & $\SETbindsolv$
      & $::=$
      & $\CONSbind{\METAtypename}{\METAnamety}
      \mid\CONSbind{\METAstrid}{\METAcsenvsolv}
      \mid\CONSbind{\METAtypevar}{\METAtyvar}
      \mid\CONSbind{\METAid}{\METAscheme}$
      \\
      %% &&& $\mid\CONSbind{\METAid}{\METAstatus}$
      %% \\

      $\METAcsenvsolvrhs$
      & $\in$
      & $\SETcsenvsolvrhs$
      & $::=$
      & $\CONSenvnul
      \mid\METAenvvar
      \mid\METAbindsolv
      \mid\CONSenvenv{\METAcsenvsolvrhs_2}{\METAcsenvsolvrhs_1}
      \mid\CONSdepss{\METAcsenvsolvrhs}{\METAcdepset}$
      \\
      $\METAcsenvsolv$
      & $\in$
      & $\SETcsenvsolv$
      & $::=$
      & $\CONSenvnul
      \mid\CONSenvenv{\METAcsenvsolvrhs}{\CONSenvnul}$

    \end{tabular}
  \end{\sizeintablesp}
\end{center}

\hidden{Moreover, if $\MEMconsStateEnvp{\METAunifstatety}{\METAcsenv}{}$ at
constraint solving occurs
in a constraint solving state $\METAunifterm$ and $\METAenvvar$ occurs in
$\METAcsenv$ then $\METAenvvar\not\in\MEMdom{\METAunifstatety}$.
%
This is enforced by rule~$\unifrulevara$ of our constraint solver.}
%
It is also the case that, for any environment variable
$\METAenvvar\in\MEMdom{\METAunifstatety}$,
$\afunc{\METAunifstatety}{\METAenvvar}\in\SETcsenvsolv$.
%
This is obtained by a simple inspection of the constraint solving rules.


We sometimes call an environment of the form $\METAcsenvsolv$, a
``solved'' environment.
}

%% Note that the environments returned by $\MEMsolvedenvSYMB$ are of
%% the form $\METAcsenvsolv$.




\subsubsection{Solving of the constraint generated for example~$\examplerun$}
\label{sec:solvexamplerun}



Sec.~\ref{sec:syntax} introduced the untypable piece of
code~$\examplerun$ which declares
$\METAstrdec_{\mathrm{EX}}$.
%
%% Let us repeat example~$\examplerun$ (the declaration called
%% $\METAstrdec_{\mathrm{EX}}$):
%% \begin{center}
%%   \begin{\sizeintablesp}
%%     $\LABstrdecStr
%%     {\LABstrbindBas
%%       {\mbox{\inexamplebody{X}}}
%%       {\LABstrexpFourp
%%         {\LABstrdecStr
%%           {\LABstrbindBas
%%             {\mbox{\inexamplebody{S}}}
%%             {\LABstrexpOne
%%               {\LABstrdecDec
%%                 {\LABdecDat
%%                   {\LABspdatbind
%%                     {\LABdatnamep{\mbox{\inexamplebody{'a}}}{\mbox{\inexamplebody{u}}}{\METAlab_6}}
%%                     {\LABtypeconId{\mbox{\inexamplebody{U}}}{\METAlab_7}}
%%                     {\METAlab_5}
%%                   }
%%                 }
%%               }
%%               {}
%%               {\METAlab_4}
%%             }
%%             {\METAlab_3}
%%           }
%%         }
%%         {\LABstrdecDec
%%           {\LABdecDat
%%             {\LABspdatbind
%%               {\LABdatnamep{\mbox{\inexamplebody{'a}}}{\mbox{\inexamplebody{t}}}{\METAlab_9}}
%%               {\LABtypeconId{\mbox{\inexamplebody{T}}}{\METAlab_{10}}}
%%               {\METAlab_8}
%%             }
%%           }
%%         }
%%         {\LABstrdecDec
%%           {\LABdecVal
%%             {\LABvalbind
%%               {\LABpatAtpat{\LABpatId{\mbox{\inexamplebody{f}}}{\METAlab_{12}}}}
%%               {\LABexpFnp
%%                 {\LABmrule
%%                   {\LABpatAtpat{\LABpatId{\mbox{\inexamplebody{T}}}{\METAlab_{14}}}}
%%                   {\LABexpAtexp{\LABexpId{\mbox{\inexamplebody{T}}}{\METAlab_{15}}}}
%%                   {\METAlab_{13}}
%%                 }
%%                 {}
%%               }
%%               {\METAlab_{11}}
%%             }
%%           }
%%         }
%%         {\LABstrdecDec
%%           {\LABdecVal
%%             {\LABvalbind
%%               {\LABpatAtpat{\LABpatId{\mbox{\inexamplebody{g}}}{\METAlab_{17}}}}
%%               {\LABexpAtexp
%%                 {\LABexpLet
%%                   {\LABdecOpen{\mbox{\inexamplebody{S}}}{\METAlab_{19}}}
%%                   {\LABexpApp
%%                     {\LABexpAtexp{\LABexpId{\mbox{\inexamplebody{f}}}{\METAlab_{21}}}}
%%                     {\LABexpId{\mbox{\inexamplebody{U}}}{\METAlab_{22}}}
%%                     {\METAlab_{20}}
%%                   }
%%                   {\METAlab_{18}}
%%                 }
%%               }
%%               {\METAlab_{16}}
%%             }
%%           }
%%         }
%%         {\METAlab_2}
%%       }
%%       {\METAlab_1}
%%     }$
%%   \end{\sizeintablesp}
%% \end{center}
%
%
%
Sec.~\ref{sec:genexamplerun} presented the environment
$\METAcsenv_{\mathrm{EX}}$ generated by our initial constraint generation
algorithm given the input~$\examplerun$.
%
%Let us now present the solving of $\METAcsenv_{\mathrm{EX}}$.
%
We present below the solving of the environment
$(\CONSenvenvfour
{\METAcsenv_4}
{\METAcsenv_3}
{\METAcsenv_2}
{\METAcsenv_1})$
which is part of $\METAcsenv_{\mathrm{EX}}$.
% as defined in Sec.~\ref{sec:genexamplerun}.
%
Let us consider the solving of $\METAcsenv_1$
generated for the declaration
\inexamplebody{structure S = struct datatype 'a u = U end}.
%
Let us repeat $\METAcsenv_1$'s definition:
\begin{center}
  \begin{\sizeintables}
    \begin{tabular}{l}
      $\METAcsenv_1$
      \hspace{0.05in}$=$\hspace{0.05in}
      $\CONSexistsenv
             {\mytuple{\METAenvvar_1,\METAenvvar_2}}
             {\CONSenvenv
               {\CONSdepss{\METAenvvar_1}{\METAlab_3}}
               {\CONSenvenv
                 {(\csou
                   {\METAenvvar_1}
                   {(\CONSbindl{\mbox{\inexamplebody{S}}}{\METAenvvar_2}{\METAlab_3})})
                 }
                 {\csbind
                   {\CONSexistsenv
                     {\mytuple{\METAenvvar_3}}
                     {(\CONSenvenv
                       {(\csou
                         {\METAenvvar_3}
                         {\METAcsenv_0})
                       }
                       {(\cso{\METAenvvar_2}{\METAenvvar_3}{\METAlab_4})})
                     }
                   }
                 }
               }
             }$
      \\

      \hspace*{0.2in}
      such that
      $\left\{
      \begin{array}{l@{\hspace{0.1in}}l@{\hspace{0.1in}}l}
        \METAcsenv'_0
        & \mbox{is}
        & \CONStopoly{\CONSbindl{\mbox{\inexamplebody{U}}}{\METAtyvar_2}{\METAlab_7}}
        \\
        \METAcsenv''_0
        & \mbox{is}
        & \CONSenvenv
                    {\CONSenvenv
                      {(\CONSbindl{\mbox{\inexamplebody{'a}}}{\METAtyvar'_1}{\METAlab_6})}
                      {(\CONSbindl{\mbox{\inexamplebody{u}}}{\METAtyname_1}{\METAlab_6})}}
                    {(\cso{\METAtyvar_1}{\CONSconsty{\METAtyname_1}{\METAtyvar'_1}}{\METAlab_6})}
        \\
        \METAcsenv_0
        & \mbox{is}
        & \CONSenvenv
                  {\CONSdepss{\METAenvvar_4}{\METAlab_5}}
                  {(\csou
                    {\METAenvvar_4}
                    {(\CONSenvenv
                      {\CONSenvenv
                        {\METAcsenv'_0}
                        {\METAcsenv''_0}
                      }
                      {(\cso{\METAtyvar_1}{\METAtyvar_2}{\METAlab_5})})
                    })
                  }
      \end{array}
      \right.$
    \end{tabular}
  \end{\sizeintables}
\end{center}
%
The solved version of $\METAcsenv_1$ is as follows:
\begin{center}
  \begin{\sizeintables}
    \begin{tabular}{l}
      $\CONSdepss{\METAenvvar_1}{\METAlab_3}$
      such that
      $\left\{
      \begin{array}{l}
        \asgn{\METAenvvar_1}
             {\CONSbindl{\mbox{\inexamplebody{S}}}{\METAenvvar_2}{\METAlab_3}}
        \\
        \asgn{\METAenvvar_2}
             {\CONSdepss{\METAenvvar_3}{\METAlab_4}}
        \\
        \asgn{\METAenvvar_3}
             {\CONSdepss
               {(\CONSenvenv
                 {(\CONSbindl
                   {\mbox{\inexamplebody{U}}}
                   {\CONScsscheme
                     {\{\METAtyvar'_1,\METAtyvar_2\}}
                     {\csou{\METAtyvar_2}{\CONSdepss{(\CONSconsty{\METAtyname_1}{\METAtyvar'_1})}{\{\METAlab_5,\METAlab_6\}}}}
                     {\METAtyvar_2}
                   }
                   {\METAlab_7})
                 }
                 {\CONSenvenv
                   {(\CONSbindl
                     {\mbox{\inexamplebody{'a}}}
                     {\METAtyvar'_1}
                     {\METAlab_6})
                   }
                   {(\CONSbindl
                     {\mbox{\inexamplebody{u}}}
                     {\METAtyname_1}
                     {\METAlab_6})
                   }
                 })
               }
               {\METAlab_5}
             }
      \end{array}
      \right.$
    \end{tabular}
  \end{\sizeintables}
\end{center}

Note that $\METAenvvar_3$ is mapped to an environment containing a
binder for \inexamplebody{'a} because we have not yet introduced any
mechanism to partially export environments (we want a mechanism
other than $\CONSenvenv{\METAcsenv_2}{\METAcsenv_1}$ that exports,
e.g., the binders of $\METAcsenv_1$ but not those of $\METAcsenv_2$).
This issue is resolved in \FORMTES~\cite{Rahli:2011} using local
environments.
%This is done in Sec.~\ref{sec:localdecs} below.

Let us now consider the solving of $\METAcsenv_2$
generated for \inexamplebody{datatype 'a t = T}.
%
First, let us repeat $\METAcsenv_2$'s definition:
\begin{center}
  \begin{\sizeintables}
    \begin{tabular}{l}
      $\METAcsenv_2$
      \hspace{0.05in}$=$\hspace{0.05in}
      $\CONSexistsenv
             {\mytuple{\METAtyvar_3,\METAtyvar_4,\METAenvvar_5}}
             {\CONSenvenv
               {\CONSdepss{\METAenvvar_5}{\METAlab_8}}
               {(\csou
                 {\METAenvvar_5}
                 {(\CONSenvenv
                   {\CONSenvenv
                     {\METAcsenv'_2}
                     {\METAcsenv''_2}
                   }
                   {(\cso{\METAtyvar_3}{\METAtyvar_4}{\METAlab_8})})
                 })
               }
             }$
      \\

      \hspace*{0.2in}
      such that
      $\left\{
      \begin{array}{l@{\hspace{0.1in}}l@{\hspace{0.1in}}l}
        \METAcsenv'_2
        & \mbox{is}
        & \CONStopoly{\CONSbindl{\mbox{\inexamplebody{T}}}{\METAtyvar_4}{\METAlab_{10}}}
        \\
        \METAcsenv''_0
        & \mbox{is}
        & \CONSexistsenv
                    {\mytuple{\METAtyvar'_3,\METAtyname_2}}
                    {\CONSenvenv
                      {\CONSenvenv
                        {(\CONSbindl{\mbox{\inexamplebody{'a}}}{\METAtyvar'_3}{\METAlab_9})}
                      {(\CONSbindl{\mbox{\inexamplebody{t}}}{\METAtyname_2}{\METAlab_9})}
                      }
                      {(\cso{\METAtyvar_3}{\CONSconsty{\METAtyname_2}{\METAtyvar'_3}}{\METAlab_9})}
                    }
      \end{array}
      \right.$
    \end{tabular}
  \end{\sizeintables}
\end{center}
%
The solved version of $\METAcsenv_2$ is as follows:
\begin{center}
  \begin{\sizeintables}
    \begin{tabular}{l}
      $\CONSdepss{\METAenvvar_5}{\METAlab_8}$
      such that
      $\asgn
      {\METAenvvar_5}
      {\CONSenvenv
        {(\CONSbindl
          {\mbox{\inexamplebody{T}}}
          {\CONScsscheme
            {\{\METAtyvar'_3,\METAtyvar_4\}}
            {\csou{\METAtyvar_4}{\CONSdepss{(\CONSconsty{\METAtyname_2}{\METAtyvar'_3})}{\{\METAlab_8,\METAlab_9\}}}}
            {\METAtyvar_4}
          }
          {\METAlab_{10}})
        }
        {\CONSenvenv
          {(\CONSbindl
            {\mbox{\inexamplebody{'a}}}
            {\METAtyvar'_3}
            {\METAlab_9})
          }
          {(\CONSbindl
            {\mbox{\inexamplebody{t}}}
            {\METAtyname_2}
            {\METAlab_9})
          }
        }
      }$
    \end{tabular}
  \end{\sizeintables}
\end{center}

Let us now consider the solving of $\METAcsenv_3$
generated for \inexamplebody{val rec f = fn T => T}.
%
First, let us repeat $\METAcsenv_3$'s definition:
\begin{center}
  \begin{\sizeintables}
    \begin{tabular}{l}
      $\METAcsenv_3$
      \hspace{0.05in}$=$\hspace{0.05in}
      $\CONSexistsenv
             {\mytuple{\METAtyvar_5,\METAtyvar_6,\METAenvvar_6}}
             {\CONSenvenv
               {\CONSdepss{\METAenvvar_6}{\METAlab_{11}}}
               {(\csou
                 {\METAenvvar_6}
                 {\CONStopoly
                   {\CONSenvenv
                     {\CONSenvenv
                       {(\cso{\METAtyvar_5}{\METAtyvar_6}{\METAlab_{11}})}
                       {\METAcsenv'_3}}
                     {(\CONSbindl{\mbox{\inexamplebody{f}}}{\METAtyvar_5}{\METAlab_{12}})}
                   }
                 })
               }
             }$
      \\

      \hspace*{0.2in}
      such that
      $\METAcsenv'_3
      =\csbind
      {\CONSexistsenv
        {\mytuple{\METAtyvar_7,\METAtyvar_8,\METAenvvar_7}}
        {\CONSenvenv
          {\CONSenvenv
            {\CONSenvenv
              {(\cso
                {\METAtyvar_6}
                {\METAlabtyarrowp{\METAtyvar_7}{\METAtyvar_8}{}}
                {\METAlab_{13}})
              }
              {(\CONSaccl{\mbox{\inexamplebody{T}}}{\METAtyvar_8}{\METAlab_{15}})}
            }
            {\CONSdepss{\METAenvvar_7}{\METAlab_{13}}}
          }
          {(\csou
            {\METAenvvar_7}
            {(\CONSaccl{\mbox{\inexamplebody{T}}}{\METAtyvar_7}{\METAlab_{14}})})
          }
        }
      }$
    \end{tabular}
  \end{\sizeintables}
\end{center}
%
The solved version of $\METAcsenv_3$ is as follows:
\begin{center}
  \begin{\sizeintables}
    \begin{tabular}{l}
      $\CONSdepss{\METAenvvar_6}{\METAlab_{11}}$
      such that
      $\left\{
      \begin{array}{l}
      \asgn
      {\METAenvvar_6}
      {(\CONSbindl
        {\mbox{\inexamplebody{f}}}
        {\CONScsscheme
          {\{\METAtyvar''_3,\METAtyvar'''_3,\METAtyvar_5,\METAtyvar_7,\METAtyvar_8\}}
          {\CONSenvenv{\CONSenvenv{\METAcs_3}{\METAcs_2}}{\METAcs_1}}
          {\METAtyvar_5}
        }
        {\METAlab_{12}})
      }
      \\
      \METAcs_1
      =\csou
      {\METAtyvar_7}
      {(\CONSdepss
        {(\CONSconsty{\METAtyname_2}{\METAtyvar''_3})}
        {\{\METAlab_{8},\METAlab_{9},\METAlab_{10},\METAlab_{14}\}})
      }
      \\
      \METAcs_2
      =\csou
      {\METAtyvar_8}
      {(\CONSdepss
        {(\CONSconsty{\METAtyname_2}{\METAtyvar'''_3})}
        {\{\METAlab_{8},\METAlab_{9},\METAlab_{10},\METAlab_{15}\}})
      }
      \\
      \METAcs_3
      =\csou
      {\METAtyvar_5}
      {(\CONSdepss
        {(\CONSarrowty{\METAtyvar_7}{\METAtyvar_8})}
        {\{\METAlab_{11},\METAlab_{13}\}})
      }
      \end{array}
      \right.$
    \end{tabular}
  \end{\sizeintables}
\end{center}

Note that in the binder generated at constraint solving for
\inexamplebody{f}, $\METAlab_{15}$ only labels
$(\CONSconsty{\METAtyname_2}{\METAtyvar'''_3})$ and does not label the
whole binder.  Having dependencies on types as well as on
environments allows a precise blaming (dependency tracking).

Let us present the solving of $\METAcsenv_4$
generated for
\inexamplebody{val rec g = let open S in f U end}.
%
First, let us repeat $\METAcsenv_4$'s definition:
%
\begin{center}
  \begin{\sizeintables}
    \begin{tabular}{l}
      $\METAcsenv_4$
      \hspace{0.05in}$=$\hspace{0.05in}
      $\CONSexistsenv
             {\mytuple{\METAtyvar_9,\METAtyvar_{10},\METAenvvar_8}}
             {\CONSenvenv
               {\CONSdepss{\METAenvvar_8}{\METAlab_{16}}}
               {(\csou
                 {\METAenvvar_8}
                 {\CONStopoly
                   {\CONSenvenv
                     {\CONSenvenv
                       {(\cso{\METAtyvar_{9}}{\METAtyvar_{10}}{\METAlab_{16}})}
                       {\csbind
                         {\CONSexistsenv
                           {\METAtyvar_{11}}
                           {\CONSenvenv
                             {\CONSenvenv
                               {(\cso{\METAtyvar_{10}}{\METAtyvar_{11}}{\METAlab_{18}})}
                               {\METAcsenv''_4}
                             }
                             {\METAcsenv'_4}
                           }
                         }
                       }
                     }
                     {(\CONSbindl{\mbox{\inexamplebody{g}}}{\METAtyvar_{9}}{\METAlab_{17}})}
                   }
                 })
               }
             }$
      \\

      \hspace*{0.2in}
      such that
      $\left\{
      \begin{array}{l@{\hspace{0.1in}}l@{\hspace{0.1in}}l}
        \METAcsenv'_4
        & \mbox{is}
        & \CONSexistsenv
                   {\METAenvvar_9}
                   {\CONSenvenv
                     {\CONSdepss{\METAenvvar_{9}}{\METAlab_{19}}}
                     {(\CONSaccl{\mbox{\inexamplebody{S}}}{\METAenvvar_{9}}{\METAlab_{19}})}
                   }
        \\
        \METAcsenv''_4
        & \mbox{is}
        &
        \CONSexistsenv
            {\mytuple{\METAtyvar_{12},\METAtyvar_{13}}}
            {\CONSenvenv
              {\CONSenvenv
                {(\cso{\METAtyvar_{12}}{\METAlabtyarrowp{\METAtyvar_{13}}{\METAtyvar_{11}}{}}{\METAlab_{20}})}
                {(\CONSaccl{\mbox{\inexamplebody{U}}}{\METAtyvar_{13}}{\METAlab_{22}})}
              }
              {(\CONSaccl{\mbox{\inexamplebody{f}}}{\METAtyvar_{12}}{\METAlab_{21}})}
            }
      \end{array}
      \right.$
    \end{tabular}
  \end{\sizeintables}
\end{center}
%
We start by solving $\METAcsenv'_4$.  Its solved version is as follows:
\begin{center}
  \begin{\sizeintables}
    \begin{tabular}{l}
      $\CONSdepss{\METAenvvar_{9}}{\METAlab_{19}}$
      such that
      $\asgn
      {\METAenvvar_{9}}
      {\CONSdepss{\METAenvvar_2}{\{\METAlab_{3},\METAlab_{19}\}}}$
    \end{tabular}
  \end{\sizeintables}
\end{center}
%%%%%%%%%%%%%% MARK (2011-07-07)
Then, we solve $\METAcsenv''_4$.
The dependent accessor
$(\CONSaccl{\mbox{\inexamplebody{f}}}{\METAtyvar_{12}}{\METAlab_{21}})$
accesses \inexamplebody{f}'s binder through $\METAenvvar_6$.
It leads to the generation of the following mapping:
\begin{center}
  \begin{\sizeintables}
    $\asgn
    {\METAtyvar_{12}}
    {\CONSdepss
      {(\CONSarrowty
        {\CONSdepss
          {(\CONSconsty{\METAtyname_2}{\METAtyvar''_4})}
          {\{\METAlab_{8},\METAlab_{9},\METAlab_{10},\METAlab_{14}\}}
        }
        {\CONSdepss
          {(\CONSconsty{\METAtyname_2}{\METAtyvar'''_4})}
          {\{\METAlab_{8},\METAlab_{9},\METAlab_{10},\METAlab_{15}\}}
        })}
      {\{\METAlab_{11},\METAlab_{12},\METAlab_{13},\METAlab_{21}\}}
    }$
  \end{\sizeintables}
\end{center}
The dependent accessor
$(\CONSaccl{\mbox{\inexamplebody{U}}}{\METAtyvar_{13}}{\METAlab_{22}})$
accesses to \inexamplebody{U}'s binder through $\METAenvvar_9$,
$\METAenvvar_2$, and $\METAenvvar_3$.
It leads to the generation of the following mapping:
\begin{center}
  \begin{\sizeintables}
    $\asgn
    {\METAtyvar_{13}}
    {\CONSdepss
      {(\CONSconsty{\METAtyname_1}{\METAtyvar''_1})}
      {\{\METAlab_{3},\METAlab_{4},\METAlab_{5},\METAlab_{6},\METAlab_{7},\METAlab_{19},\METAlab_{22}\}}
    }$
  \end{\sizeintables}
\end{center}
Finally, our constraint solver returns a type error (terminates in an
error state) when dealing with the equality constraint
$(\cso{\METAtyvar_{12}}{\METAlabtyarrowp{\METAtyvar_{13}}{\METAtyvar_{11}}{}}{\METAlab_{20}})$,
because $\METAtyname_1\not=\METAtyname_2$.
The error is as follows:
$\CONSerror
{\CONSuniferrortyconsclashp{\METAtyname_1}{\METAtyname_2}}
{
  \{
  \METAlab_{3},
  \METAlab_{4},
  \METAlab_{5},
  \METAlab_{6},
  \METAlab_{7},
  \METAlab_{8},
  \METAlab_{9},
  \METAlab_{10},
  \METAlab_{11},
  \METAlab_{12},
  \METAlab_{13},
  \METAlab_{14},
  \METAlab_{19},
  \METAlab_{20},
  \METAlab_{21},
  \METAlab_{22}
  \}
}$.
%
We call this error $\METAerror_{\mathrm{EX}}$.
Let
$\METAerror_{\mathrm{EX}}=\CONSerror{\METAuniferrorkind_{\mathrm{EX}}}{\METAcdepset_{\mathrm{EX}}}$.



\subsection{\SECminenum}
\label{sec:minenum}
\label{sec:filtering}
\label{sec:minimisation}
\label{sec:enumeration}




\hidden{
First constraints are generated for \SML\ code
(Sec.~\ref{sec:constraintgen}).  Then, type errors of the constraints
are enumerated and each is minimised relying on constraint solving
(Sec.~\ref{sec:unification}).}

%%   Given
%% constraints, our enumeration algorithm
%% % defined in Sec.~\ref{sec:enumeration}
%% takes over to enumerate all the type errors
%% of the code.  Our enumeration algorithm minimises each found
%% error using the minimisation algorithm presented in this section.
%% Both our minimisation and enumeration algorithms rely heavily on
%% unification.




\subsubsection{Extraction of environment labels}
\label{sec:extractlabelsbind}

%
Given an environment $\METAcsenv$, $\MEMgetbindingsSYMB$ extracts the
labels labelling binders
% ($\METAbind$)
occurring in $\METAcsenv$.
It is used during the first phase
of our minimisation algorithm which consists in trying to remove
entire sections of code
(datatype declarations, functions, structures, \dots)
by ``disconnecting'' accessors from their binders:
\begin{center}
  \begin{\sizeintablesp}
    $\MEMgetbindingspp{\METAcsenv}=\{\METAlab\mid\CONSdepss{\METAbind}{\METAlab}\mbox{ occurs in }\METAcsenv\}$
  \end{\sizeintablesp}
\end{center}

%% \hidden{
%% \begin{center}
%% \begin{\sizeintables}
%%   \begin{tabular}[t]{ l l l }
%%     $\MEMgetbindingspp{\CONSdeps{\METAcsenv}{\METAlab}}$
%%     & $=$
%%     & $\left\{
%%     \begin{array}{ll}
%%       \{\METAlab\},
%%       &
%%       \mbox{if }\METAcsenv\mbox{ is of the form }\METAbind
%%       \\
%%       \MEMgetbindingspp{\METAcsenv},
%%       &
%%       \mbox{otherwise}
%%     \end{array}
%%     \right.$
%%     \\

%%     $\MEMgetbindingspp{\CONStopoly{\METAcsenv}}$
%%     & $=$
%%     & $\MEMgetbindingspp{\METAcsenv}$
%%     \\

%%     $\MEMgetbindingspp{\csou{\METAcsenv_1}{\METAcsenv_2}}$
%%     & $=$
%%     & $\MEMgetbindingspp{\METAcsenv_1}\cup\MEMgetbindingspp{\METAcsenv_2}$
%%     \\

%%     $\MEMgetbindingspp{\CONSenvenv{\METAcsenv_2}{\METAcsenv_1}}$
%%     & $=$
%%     & $\MEMgetbindingspp{\METAcsenv_1}\cup\MEMgetbindingspp{\METAcsenv_2}$
%%     \\

%%     $\MEMgetbindingspp{\METAcsenv}$
%%     & $=$
%%     & $\emptyset$,
%%     if none of the above applies
%%   \end{tabular}
%% \end{\sizeintables}
%% \end{center}}
%% %
%% \hidden{For example, if $\METAcsenv$ is
%% \begin{center}
%% \begin{\sizeintables}
%% $\CONSenvenv
%% {\CONSenvenv
%%   {(\CONSaccl{\mbox{\inexamplebody{x}}}{\METAlabty}{\METAlab})}
%%   {(\CONSbindl{\mbox{\inexamplebody{x}}}{\CONSvidsem{\METAlabty_2}{\METAstatus_2}}{\METAlab_2})}
%% }
%% {(\CONSbindl{\mbox{\inexamplebody{x}}}{\CONSvidsem{\METAlabty_1}{\METAstatus_1}}{\METAlab_1})}$
%% \end{\sizeintables}
%% \end{center}
%% then $\MEMgetbindingspp{\METAcsenv}=\{\METAlab_1,\METAlab_2\}$.}



%% \intitle{Extraction of environment labels.}
%% %
%% Fig.~\ref{fig:getlabbind} defines our algorithm to extract labels
%% labelling the environments in a constraint set.  The relation
%% $\MEMgetbindingsSYMB$ is used during the first phase of our
%% minimisation algorithm which consists in trying to remove entire
%% sections of code (datatype declarations, functions, structures,
%% \dots).
%% %
%% \begin{\myfigure}[!th]
%% \begin{\sizetables}
%%   \begin{tabular}[t]{ l l l }
%%     $\MEMgetbindingsp{\CONStopoly{\METAcsenv}}{\METAlabseq}$
%%     & $\fra$
%%     & $\MEMgetbindingsp{\METAcsenv}{\METAlabseq}$
%%     \\

%%     $\MEMgetbindingsp{\CONSdeps{\METAcsenv}{\METAlab}}{\METAlabseq}$
%%     & $\fra$
%%     & $\MEMgetbindingsp{\METAcsenv}{\MEMconcat{\METAlabseq}{\mytuple{\METAlab}}}$
%%     \\

%%     $\MEMgetbindingsp{\CONSdeps{\METAcsenv}{\METAid}}{\METAlabseq}$
%%     & $\fra$
%%     & $\MEMgetbindingsp{\METAcsenv}{\METAlabseq}$
%%     \\

%%     $\MEMgetbindingsp{\CONSenvenv{\METAcsenv_1}{\METAcsenv_2}}{\METAlabseq}$
%%     & $\fra$
%%     & $\MEMgetbindingsp{\METAcsenv_1}{\METAlabseq'}$,
%%     if $\MEMgetbindingsp{\METAcsenv_2}{\METAlabseq}\ffra\MEMgetbindingsend{\METAlabseq'}$
%%     \\

%%     $\MEMgetbindingsp{\METAcsenv}{\METAlabseq}$
%%     & $\fra$
%%     & $\MEMgetbindingsend{\METAlabseq}$,
%%     if $\METAcsenv$ is a $\METAenvvar$, a $\METAbind$ or a $\CONSsems{\METAstrid}{}$
%%   \end{tabular}
%%   \hspace*{-0.8in}
%%   \begin{tabular}[t]{ r l l }
%%     $\MEMgetbindingsp{\{\csou{\METAcsenv_1}{\METAcsenv_2}\}\dunion\METAcsset}{\METAlabseq}$
%%     & $\fra$
%%     & $\MEMgetbindingsp{\CONSenvenv{\CONSenvenv{\METAcsset}{\METAcsenv_2}}{\METAcsenv_1}}{\METAlabseq}$
%%     \\

%%     $\MEMgetbindingsp{\{\csou{x_1}{x_2}\}\dunion\METAcsset}{\METAlabseq}$
%%     & $\fra$
%%     & $\MEMgetbindingsp{\METAcsset}{\METAlabseq}$,
%%     if $x_1\not\in\SETcsenv$
%%     \\

%%     $\MEMgetbindingsp{\emptyset}{\METAlabseq}$
%%     & $\fra$
%%     & $\MEMgetbindingsend{\METAlabseq}$
%%   \end{tabular}
%% \end{\sizetables}
%% \caption{Extraction of environment labels}
%% \label{fig:getlabbind}
%% \end{\myfigure}

%% \begin{center}
%% \begin{tabular}{ l l l }
%%   %% $\MEMgetbindings
%%   %% {\{\csbind{\METAcsenv}{\METAcsset_1}\}\dunion\METAcsset_2}
%%   %% {\mytuple{\MEMgetlabsenv{\METAcsenv}}@\METAlabsetseq_1@\METAlabsetseq_2}$
%%   %% & $\ \ \ $
%%   %% & if
%%   %% $\forallexp{i\in\{1,2\}}{\MEMgetbindings{\METAcsset_i}{\METAlabsetseq_i}}$
%%   %% \\

%%   $\MEMgetbindings{\{\cso{x_1}{x_2}{\METAlabset}{}{\METAidset}\}\dunion\METAcsset}{\METAlabsetseq}$
%%   & & if $\MEMgetbindings{\METAcsset}{\METAlabsetseq}$
%%   and $x_1,x_2\not\in\SETcsenv$
%%   \\

%%   $\MEMgetbindings
%%   {\{\cso{\METAcsenv_1}{\METAcsenv_2}{\METAlabset}{}{\METAidset}\}\dunion\METAcsset}
%%   {\METAlabsetseq_1@\METAlabsetseq_2@\METAlabsetseq}$
%%   & & if $\MEMgetbindings{\METAcsset}{\METAlabsetseq}$
%%   and $\forallexp{i\in\{1,2\}}{\MEMgetbindings{\METAcsenv_i}{\METAlabsetseq_i}}$
%%   \\

%%   $\MEMgetbindings{\METAbind}{\mytuple{\MEMgetlabsenv{\METAbind}}}$
%%   & &
%%   \\

%%   $\MEMgetbindings{\CONSenvenv{\METAcsenv}{\METAcsorenv}}{\METAlabsetseq_1@\METAlabsetseq_2}$
%%   & & if $\MEMgetbindings{\METAcsorenv}{\METAlabsetseq_1}$
%%   and $\MEMgetbindings{\METAcsenv}{\METAlabsetseq_2}$
%%   \\

%%   $\MEMgetbindings{\METAcsenv}{\emptyset}$
%%   & & if $\METAcsenv\in\{\METAenvvar,\CONSsems{\METAstrid}{}\}$
%% \end{tabular}
%% \end{center}


\subsubsection{Constraint filtering}
\label{sec:csfiltering}

%
\begin{\myfigure}[t]
  \begin{\sizeintables}

    \mytitle{filtering function}

    \begin{tabular}{lll}
      $\MEMcsprojp{\METAcsenv}{\METAlabset_1}{\METAlabset_2}$
      & $=$
      & $\left\{
      \begin{array}{ll}
        &
        \{\asgn{\METAlab}{\CONSdepstatusK}\mid\METAlab\in\METAlabset_1\setminus\METAlabset_2\}
        \\
        \cup
        &
        \{\asgn{\METAlab}{\CONSdepstatusB}\mid\METAlab\in\METAlabset_2\}
        \\
        \cup
        &
        \{\asgn{\METAlab}{\CONSdepstatusD}\mid\METAlab\in\MEMlabelset{\METAcsenv}\setminus(\METAlabset_1\cup\METAlabset_2)\}
      \end{array}
      \right.$
      \\

      $\MEMcsproj{\CONSdepss{\METAcsenv}{\METAcdepset}}{\METAdepenv}$
      & $=$
      & $\left\{
      \begin{array}{ll}
        \CONSdepss{\MEMcsproj{\METAcsenv}{\METAdepenv}}{\METAcdepset},
        &
        \mbox{if }\afunc{\METAdepenv}{\METAcdepset}=\{\CONSdepstatusK\}
        \\
        \CONSenvnul,
        &
        \mbox{if }\CONSdepstatusD\in\afunc{\METAdepenv}{\METAcdepset}
        \\
        \CONSdepss{\MEMunlab{\METAcsenv}}{\emptyset},
        &
        \mbox{if }\{\CONSdepstatusB\}=\afunc{\METAdepenv}{\METAcdepset}\setminus\{\CONSdepstatusK\}
      \end{array}
      \right.$
      \\
    \end{tabular}
    %% \hspace{0.2in}
    %% \begin{tabular}{lll}
    %%   $\MEMcsprojp{\CONSdepss{\METAcsenv}{\METAlab}}{\METAlabset_1}{\METAlabset_2}$
    %%   & $=$
    %%   & $\left\{
    %%   \begin{array}{ll}
    %%     \CONSdepss{\METAcsenv}{\METAlab},
    %%     &
    %%     \mbox{if }\METAlab\in\METAlabset_1\setminus\METAlabset_2
    %%     \\
    %%     \CONSdepss{\MEMunlab{\METAcsenv}}{\emptyset},
    %%     &
    %%     \mbox{if }\METAlab\in\METAlabset_2
    %%     \\
    %%     \CONSenvnul,
    %%     &
    %%     \mbox{otherwise}
    %%   \end{array}
    %%   \right.$
    %%   \\
    %% \end{tabular}
    \hspace{0.2in}
    \begin{tabular}{lll}
      $\MEMcsproj{\csou{\METAcsenv_1}{\METAcsenv_2}}{\METAdepenv}$
      & $=$
      & $(\csou{\MEMcsproj{\METAcsenv_1}{\METAdepenv}}{\MEMcsproj{\METAcsenv_2}{\METAdepenv}})$
      \\

      $\MEMcsproj{\CONSenvenv{\METAcsenv_2}{\METAcsenv_1}}{\METAdepenv}$
      & $=$
      & $\CONSenvenv{\MEMcsproj{\METAcsenv_2}{\METAdepenv}}{\MEMcsproj{\METAcsenv_1}{\METAdepenv}}$
      \\

      $\MEMcsproj{\CONStopoly{\METAcsenv}}{\METAdepenv}$
      & $=$
      & $\CONStopoly{\MEMcsproj{\METAcsenv}{\METAdepenv}}$
      \\

      $\MEMcsproj{\CONSexistsenv{\METAatom}{\METAcsenv}}{\METAdepenv}$
      & $=$
      & $\CONSexistsenv{\METAatom}{\MEMcsproj{\METAcsenv}{\METAdepenv}}$
      \\

      $\MEMcsproj{\METAcsenv}{\METAdepenv}$
      & $=$
      & $\METAcsenv$, otherwise
    \end{tabular}
    %% \begin{tabular}{lll}
    %%   $\MEMcsprojp{\csou{\METAenvvar}{\METAcsenv}}{\METAlabset_1}{\METAlabset_2}$
    %%   & $=$
    %%   & $(\csou{\METAenvvar}{\MEMcsprojp{\METAcsenv}{\METAlabset_1}{\METAlabset_2}})$
    %%   \\

    %%   $\MEMcsprojp{\CONSenvenv{\METAcsenv_2}{\METAcsenv_1}}{\METAlabset_1}{\METAlabset_2}$
    %%   & $=$
    %%   & $\CONSenvenv{\MEMcsprojp{\METAcsenv_2}{\METAlabset_1}{\METAlabset_2}}{\MEMcsprojp{\METAcsenv_1}{\METAlabset_1}{\METAlabset_2}}$
    %%   \\

    %%   $\MEMcsprojp{\CONStopoly{\METAcsenv}}{\METAlabset_1}{\METAlabset_2}$
    %%   & $=$
    %%   & $\CONStopoly{\MEMcsprojp{\METAcsenv}{\METAlabset_1}{\METAlabset_2}}$
    %%   \\

    %%   $\MEMcsprojp{\CONSenvnul}{\METAlabset_1}{\METAlabset_2}$
    %%   & $=$
    %%   & $\CONSenvnul$
    %%   %% $\MEMcsprojp{\csou{\METAvar}{x}}{\METAlabset_1}{\METAlabset_2}$
    %%   %% & $=$
    %%   %% & $(\csou{\METAvar}{x})$,
    %%   %% if $x\not\in\SETcsenv$
    %%   %% \\

    %%   %% $\MEMcsprojp{x}{\METAlabset_1}{\METAlabset_2}$
    %%   %% & $=$
    %%   %% & $x$
    %%   %% if $x$ is of the form
    %%   %% $\METAbind$,
    %%   %% $\METAacc$, or
    %%   %% $\METAenvvar$
    %% \end{tabular}

    \vspace{0.05in}
    \mytitle{conversion of environments into dummy environments}
    \vspace{0.02in}

    \begin{tabular}[t]{lll}
      $\MEMunlab{\CONSbind{\METAid}{\METAityscheme}}$
      & $=$
      & $\CONSbind{\METAid}{\CONSscheme{\METAtyvar}{\METAtyvar}}$
      \\

      $\MEMunlab{\CONSbind{\METAtypevar}{\METAityscheme}}$
      & $=$
      & $\CONSbind{\METAtypevar}{\CONSscheme{\METAtyvar}{\METAtyvar}}$
      \\

      $\MEMunlab{\CONSbind{\METAtypename}{\METAityconscheme}}$
      & $=$
      & $\CONSbind{\METAtypename}{\CONSscheme{\METAtynamevar}{\METAtynamevar}}$
      \\

      $\MEMunlab{\CONSbind{\METAstrid}{\METAenvscheme}}$
      & $=$
      & $\CONSbind{\METAstrid}{\CONSscheme{\METAenvvar}{\METAenvvar}}$
      \\
    \end{tabular}
    \hspace{0.1in}
    \begin{tabular}[t]{lll}
      $\MEMunlab{\METAenvvar}$
      & $=$
      & $\CONSexistsenv{\METAenvvar}{\METAenvvar}$
      \\
      %% $\MEMunlab{\CONSbindu{\METAgenid}{x}}$
      %% & $=$
      %% & $(\CONSbindu{\METAgenid}{\MEMunlabvar{x}})$
      %% \\

      $\MEMunlab{\CONSenvenv{\METAcsenv_2}{\METAcsenv_1}}$
      & $=$
      & $\CONSenvenv{\MEMunlab{\METAcsenv_2}}{\MEMunlab{\METAcsenv_1}}$
      \\

      $\MEMunlab{\CONStopoly{\METAcsenv}}$
      & $=$
      & $\MEMunlab{\METAcsenv}$
      \\

      $\MEMunlab{\CONSexistsenv{\METAatom}{\METAcsenv}}$
      & $=$
      & $\MEMunlab{\METAcsenv}$
      \\
      %% How is the existential instantiated?
      %% 'dum' has to be a relation here doesn't it?
    \end{tabular}
    \hspace{0.1in}
    \begin{tabular}[t]{lll}
      $\MEMunlab{\CONSdepss{\METAcsenv}{\METAcdepset}}$
      & $=$
      & $\MEMunlab{\METAcsenv}$
      \\

      $\MEMunlab{\METAcs}$
      & $=$
      & $\CONSenvnul$
      \\

      $\MEMunlab{\METAacc}$
      & $=$
      & $\CONSenvnul$
      \\

      $\MEMunlab{\CONSenvnul}$
      & $=$
      & $\CONSenvnul$
    \end{tabular}
    %% \hspace{0.4in}
    %% \begin{tabular}[t]{lll}
    %%   $\MEMunlabvar{\METAscheme}$
    %%   & $=$
    %%   & $\CONSfreshvar{\METAtyvar}$
    %%   \\

    %%   %% $\MEMunlabvar{\METAlabty}$
    %%   %% & $=$
    %%   %% & $\CONSfreshvar{\METAtyvar}$
    %%   %% \\

    %%   $\MEMunlabvar{\METAnamety}$
    %%   & $=$
    %%   & $\CONSfreshvar{\METAtynamevar}$
    %%   \\

    %%   $\MEMunlabvar{\METAcsenv}$
    %%   & $=$
    %%   & $\CONSfreshvar{\METAenvvar}$
    %%   %% $\MEMunlabvar{\METAstatus}$
    %%   %% & $=$
    %%   %% & $\CONSstatusa$
    %% \end{tabular}
  \end{\sizeintables}
  \caption{Constraint filtering}
  \label{fig:csfiltering}
\end{\myfigure}
%
%%\mynote{(2010-04-13)}{$\MEMunlabSYMB$ is not defined yet.}
%


Fig.~\ref{fig:csfiltering} defines
%
\index{constraint filtering}%
%
the constraint filtering
function $\MEMcsprojSYMB$, used to check the
solvability of constraints in which some constraints are
discarded.
%
\hidden{Note that our filtering function is not defined on all environments.
The forms on which the filtering function is defined are the ones
generated by our initial constraint generator (these forms are defined
in Sec.~\ref{sec:shapegenenvs}).}
%
\hidden{When applied to unlabelled equality constraints on environments, our
filtering function is only applied to unlabelled equality constraints
of the form $\csou{\METAenvvar}{\METAcsenv}$ (and not of the general
form $\csou{\METAcsenv_1}{\METAcsenv_2}$) because our initial
constraint generator only generates variables as the left-hand-side of
unlabelled equality constraints on environments (see the definition of
$\SETcsenvg$ in Sec.~\ref{sec:shapegenenvs}).}
%
\hidden{Similarly, we only apply our filtering function to dependent
environments of the form $\CONSdepss{\METAcsenv}{\METAlab}$, i.e.,
depending on a single label.}
%
%% It is only applied to constraints generated by our
%% constraint generator.
%% This is why we only filter environment equality constraints of the
%% restricted form
%% $\csou{\METAenvvar}{\METAcsenv}$
%% and not of the general form
%% $\csou{\METAcsenv_1}{\METAcsenv_2}$.
%
%% In this figure the variables $\METAenvvar_1$ and $\METAenvvar_2$
%% are ``fresh'' variables (they are all distinct from each other and
%% are fresh w.r.t.\ $\MEMcsprojSYMB$'s input).
%
In $\MEMcsprojp{\METAcsenv}{\METAlabset_1}{\METAlabset_2}$,
$\METAlabset_1$ is the label set for which we want to keep the
annotated environments (first case of the filtering rule for
$\CONSdepss{\METAcsenv}{\METAlab}$), and $\METAlabset_2$ is the label
set for which we do not want to keep the equality constraints and
accessors but for which we want to turn the binders into dummy ones
and keep the environment variables (second case of the filtering rule
for $\CONSdepss{\METAcsenv}{\METAlab}$).  The environments annotated
by labels not in $\METAlabset_1\cup\METAlabset_2$ are
discarded (third case of the filtering rule for
$\CONSdepss{\METAcsenv}{\METAlab}$).
%
In the constraint filtering context, label sets are sometimes
called
%
\index{filters}%
%
\emph{filters}.
%
The distinction between binders to discard (not labelled by
a label in $\METAlabset_1\cup\METAlabset_2$) and binders to
turn into dummy ones (labelled by a label in $\METAlabset_2$) is
necessary because at minimisation, throwing away any environment
might result in different bindings in the filtered constraints
(corresponding to a different \SML\ code).
%
For example, removing the binder labelled by $\METAlab_2$
in
%\begin{center}
\begin{\sizeintablesp}
$\CONSenvenv
{\CONSenvenv
  {(\CONSaccl{\mbox{\inexamplebody{x}}}{\METAlabty}{\METAlab})}
  {(\CONSbindl{\mbox{\inexamplebody{x}}}{\METAlabty_2}{\METAlab_2})}
}
{(\CONSbindl{\mbox{\inexamplebody{x}}}{\METAlabty_1}{\METAlab_1})}$
\end{\sizeintablesp}
%\end{center}
results in \inexamplebody{x}'s accessor being bound to
\inexamplebody{x}'s first binder instead of its second.
%
Similarly,
removing the binder labelled by \inexamplebody{f}'s second
occurrence's label in the environment generated for


%\vspace*{-0.15in}
\examplebody{
\Bl
let val rec f = fn x => x 1
\\
in let val rec f = fn x => x + 1 in f true end
\\
end
\El
}
%\vspace*{-0.25in}

\noindent
\newtext{results in \inexamplebody{f}'s third occurrence
being bound to its first occurrence and so to
a non-existing (false) type error to be found at enumeration.}
%%
When a binder is labelled by a label from $\METAlabset_2$, it
is turned into a dummy unlabelled one that cannot be involved in any error
and it results that the same holds for its accessors.
%
%% Let $\MEMcsproj{\METAcsenv}{\METAlabset}$ be
%% $\MEMcsprojp{\METAcsenv}{\MEMlabelset{\METAcsenv}}{\METAlabset}$.

\hidden{\mynote{(2010-05-09)}{It is okay to throw away bindings when they do
  not occur in an error either found by our enumeration algorithm or
  in the process of being minimised because I believe that if a
  binding does not occur in an error then none of its accessors will
  either.}}

%% The variables $\METAtyvar_0$, $\METAtynamevar_0$, $\METAseqvar_0$ and
%% $\METAenvvar_0$ are distinguished variables that are never generated
%% at constraint generation and that are never unified at unification.
%% This part of minimisation is not fully formalised in order to keep the
%% presentation of the algorithm simple.



The intended meaning of a labelled constraint is that it only must
hold if the condition represented by the label is true.  The machinery
presented in this document is designed to implement this intended semantics.
%
\hidden{We therefore allow our filtering function to entirely discard labelled
equality constraints, bindings, accessors and environment variables
because when generated, these forms are always shallow.  As a matter
of fact, by definition, the right-hand-side of an accessor can only be
a variable $\METAvar$.  When generated, the right-hand-side of a
binder is either a variable $\METAvar$ or a type constructor name
$\METAtyname$ (see $\SETbindg$'s definition in
Sec.~\ref{sec:shapegenenvs}).  Concerning the generated equality
constraints, by shallow we mean a $\METAcsg$ constraint as defined in
Sec.~\ref{sec:shapegenenvs}.  The non-shallow generated equality
constraints are the non-labelled ones generated by
rules~$\MEMgencgruled$,~$\MEMgencgrulel$,~$\MEMgencgrulen$,~$\MEMgencgrulem$,~$\MEMgencgrulep$
and~$\MEMgencgruler$.  Because these constraints are not labelled,
they are then never filtered out but the filtering function is
recursively called on the right-hand-sides of these constraints as
they can be non shallow.}




\subsubsection{Why is minimisation necessary?}
\label{sec:whyminimisation}



%
Given an environment generated for a piece of code (given $\METAcsenv$
such that $\typingSCS{\METAstrdec}{\METAcsenv}$ for a given
$\METAstrdec$), our enumeration algorithm works as follows: it selects
a filter from its search space, it filters out the constraints
labelled by the filter in the environment and runs the constraint
solver on the filtered environment.  If the constraint solver succeeds
(terminates in a success state) then the enumerator keeps searching
for type errors using the rest of the search space.  If the constraint
solver fails (terminates in an error state) then the enumerator has
found a new error.  This new error might not be minimal.  The
enumerator runs then the minimiser on the found error and once a
minimal error has been found, keeps searching for other type errors.
The minimiser is necessary because when the constraint solver returns
an error at enumeration, this error might not be minimal.  An obvious
example is as follows:

\examplebody{
\Bl
val rec f = fn x => (x (fn z => z), x (fn () => ()))
\\
val rec g = fn y => y true
\\
val u = f g
\El
}

This piece of code is untypable and the highlighting of one of the
type errors of this piece of code is as follows:

\examplebody{
\Bl
\boxR{val} \boxR{rec} \boxR{f = fn} \boxR{x =>} (x (fn z => z), \boxR{x (fn} \boxG{()}\boxR{ =>} ()\boxR{)})
\\
\boxR{val} \boxR{rec} \boxR{g = fn} \boxR{y =>} \boxR{y }\boxB{true}
\\
val u = \boxR{f g}
\El
}

The corresponding type error slice is as follows (we have adapted the
slice returned by \IMPLTES\ to the restricted language presented in
this document):

\examplebody{
\Bl
\lslice\Bl..val rec f = fn x => \lslice..x (fn () => \lslice..\rslice)..\rslice
       \\
       ..val rec g = fn y => \lslice..y true..\rslice
       \\
       ..f g..\rslice
       \El
\El
}

The issue is that because of the first component returned by the
function \inexamplebody{f} (the application \inexamplebody{x (fn z => z)})
and because of \inexamplebody{x}'s monomorphism,
when the error presented above is first found at enumeration, it is
not minimal.  The error first found by the enumeration algorithm,
before minimisation, is as follows:

\examplebody{
\Bl
\lslice\Bl..val rec f = fn x => \lslice..x (fn z => \lslice..\rslice)..x (fn () => \lslice..\rslice)..\rslice
       \\
       ..val rec g = fn y => \lslice..y true..\rslice
       \\
       ..f g..\rslice
       \El
\El
}

Because \inexamplebody{x} is monomorphic, it is constrained by both
\inexamplebody{z} and \inexamplebody{()}.  This is a typical example
that shows the necessity of the minimisation algorithm.  We have not
yet found a way to directly obtain the first slice presented above
without the help of the minimiser.  The investigation of such a
system is left for future work.





%% TODO: give an example that shows that enum does not find minimal
%% errors from the start.


%%%% WE NEED CONSTRAINT SYNTAX TO HANDLE TYPE SEQUENCES FOR THAT
%%%% AND WE NEED TYPE FUNCTIONS.

%% \intitle{Reporting type constructor arity errors.}
%% %
%% In the simple labelled syntax presented in Fig.~\ref{fig:syntaxOpen},
%% we only allow used datatypes to be of arity 1.  We made this
%% simplification in order not to burden the paper with the report of
%% type constructor arity clashes.  For example,
%% \inexamplebody{datatype 'a t = T of ('a, 'a) t} is not typable because
%% \inexamplebody{t}'s first occurrence has arity 1 while
%% \inexamplebody{t}'s second occurrence has arity 2.

%% The issue with reporting such errors is that one of the minimal type
%% error in, e.g.,
%% \inexamplebody{datatype 'a t = T of 'a t -> ('a, 'a) t} is that
%% \inexamplebody{t}'s two last occurrence do not have the same
%% arity and that this minimal error does not need \inexamplebody{t}'s
%% binding occurring to exist.  The error would be similar if the type
%% constructor \inexamplebody{t} was free.

%% Being able to report these errors where we want to report the bound
%% occurrences of identifiers (accessors) without reporting their binding
%% occurrences (binders) is clearly not possible in the system as
%% presented above.  But this can be done without too much trouble by
%% slightly altering our constraint solver.




\subsubsection{Minimisation algorithm}
%
Fig.~\ref{fig:minalgo} defines
%
\index{minimisation algorithm}%
%
our minimisation algorithm: the
relation $\MEMminimiseSYMB$ that uses the relation $\fmin$ which tests
if a label can be removed from a slice and where $\ffmin$ is its
reflexive (w.r.t.\ $\SETcsenv\cprod\SETerror$) and transitive closure.
Minimisation consists of two main phases.  The first one (phase1)
% called ``unbind'',
tries to remove entire sections of code at once by turning bindings
into dummy ones using $\MEMgetbindingsSYMB$ (defined in
Sec.~\ref{sec:extractlabelsbind}).  In a fine-grained second phase
(phase2)
% called ``reduce'',
the algorithm tries to remove the remaining labels ($\METAlabset_1$ in
rule~$\minrulezero$ in Fig.~\ref{fig:minalgo}) one at a time.
%%   Our
%% minimisation algorithm is based on two other algorithms presented in
%% Fig.~\ref{fig:unbinding} and Fig.~\ref{fig:reduce}.

A step of our minimisation algorithm is as follow:
$\MEMreduce{\METAcsenv}{\METAlabset_1}{\{\METAlab\}\dunion\METAlabset_2}{}
\fmin
\MEMreduce{\METAcsenv}{\METAlabset_3}{\METAlabset_4}{}$
where $\METAlabset_3$ and $\METAlabset_4$ depend on the solvability of
$\MEMcsprojp{\METAcsenv}{\METAlabset_1\cup\METAlabset_2}{\{\METAlab\}}$.
Let
$\METAcsenv'=\MEMcsprojp{\METAcsenv}{\METAlabset_1\cup\METAlabset_2}{\{\METAlab\}}$.
The set $\METAlabset_1\cup\METAlabset_2\cup\{\METAlab\}$ is the label
set of the error that the minimisation algorithm is minimising at this
step,
and $\{\METAlab\}\dunion\METAlabset_2$ is the label set yet to try to
discard.
%
The environment $\METAcsenv'$ is obtained from $\METAcsenv$ by
filtering out the constraints that are not labelled by
$\METAlabset_1\cup\METAlabset_2\cup\{\METAlab\}$, by filtering out the
accessors and equality constraints that are labelled by $\METAlab$,
and by turning the binders labelled by $\METAlab$ into dummy ones (and
similarly for the environment variables labelled by $\METAlab$).
%
If $\METAcsenv'$ is solvable it means that $\METAlab$ is necessary for
an error to occur, and therefore
$\METAlabset_3=\METAlabset_1\cup\{\METAlab\}$ and
$\METAlabset_4=\METAlabset_2$.  If $\METAcsenv'$ is unsolvable (the
solver failed and we obtained a new smaller error, i.e., which
contains strictly less labels), it means that
$\METAlab$ is unnecessary for an error to occur and that any
environment labelled by $\METAlab$ can be completely filtered out in
the next step.  The label sets $\METAlabset_3$ and $\METAlabset_4$ are
then restricted to the newly found error (see rule~$\reduceruleone$).


Environments (bindings, environment variables, ...) can be completely
filtered out from one step to another because the labelled internal
syntax, our constraint generator and solver, together ensure that if a
binder is turned into a dummy one then none of its accessors will be
part of any error (see Sec.~\ref{sec:minbinddiscard} for more on this
matter).  This invariant could explicitly be enforced during
constraint solving by adding side conditions to rules~$\unifruleacca$
and~$\unifruleaccc$ checking that the accessed identifiers' types are
not dummy variables (in $\SETfreshvar$).  This enforcement is not
necessary.

Note that the minimisation algorithm fails if at the end of the second
phase, in rule~$\minrulezero$, the label set $\METAlabset_2$ does not
correspond to an error in $\METAcsenv$: because of
$\MEMgetuniferror{\MEMcsprojp{\METAcsenv}{\METAlabset_2}{\emptyset}}{\METAerror'}$,
rule~$\minrulezero$ is only defined if
$\MEMcsprojp{\METAcsenv}{\METAlabset_2}{\emptyset}$ is unsolvable.


%\mynote{(2010-04-13)}{The building of accessors can never occur.}

%% \begin{\myfigure}[!th]
%%   \begin{\sizetables}
%%   \begin{tabular}{ l l l l l }
%%     $\unbindruleone$
%%     & $\MEMunbind{\mytuple{\METAlabset}@\METAlabsetseq}{\METAlabset_1}{\METAlabset_2}{\METAlabset_3}{\METAcsset}$
%%     & $\fra$
%%     & $\MEMunbind{\METAlabsetseq}{\METAlabset_1}{\METAlabset'_2}{\METAlabset'_3}{\METAcsset}$,
%%     & if $\MEMissuccess{\MEMcsprojp{\METAcsset}{\METAlabset_1}{\METAlabset}}$
%%     \\

%%     $\unbindruletwo$
%%     & $\MEMunbind{\mytuple{\METAlabset}@\METAlabsetseq}{\METAlabset_1}{}{}{\METAcsset}$
%%     & $\fra$
%%     & $\MEMunbind{\METAlabsetseq}{\METAlabset_1\cap\afunc{\METAerror}{1}}{}{}{\METAcsset}$,
%%     & if $\MEMgetuniferror{\MEMcsprojp{\METAcsset}{\METAlabset_1}{\METAlabset}}{\METAerror}$
%%     \\
%% %%   \end{tabular}
%% %%   \caption{The ``unbinding'' algorithm}
%% %%   \label{fig:unbinding}
%% %% \end{\myfigure}


%% %% \begin{\myfigure}[!th]
%% %%   \begin{tabular}{ l l l l l }
%%     $\reduceruleone$
%%     & $\MEMreduce{\METAcsset}{\METAlabset_1}{\{\METAlab\}\cup\METAlabset_2}{\METAerror}$
%%     & $\fra$
%%     & $\MEMreduce{\METAcsset}{\METAlabset_1}{\METAlabset_2\cap\afunc{\METAerror}{1}}{\METAerror'}$,
%%     & if $\MEMgetuniferror{\MEMcsprojp{\METAcsset}{\METAlabset_1\cup\METAlabset_2}{\{\METAlab\}}}{\METAerror}$
%%     \\

%%     $\reduceruletwo$
%%     & $\MEMreduce{\METAcsset}{\METAlabset_1}{\{\METAlab\}\cup\METAlabset_2}{\METAerror}$
%%     & $\fra$
%%     & $\MEMreduce{\METAcsset}{\METAlabset_1\cup\{\METAlab\}}{\METAlabset_2}{\METAerror'}$,
%%     & if $\MEMissuccess{\MEMcsprojp{\METAcsset}{\METAlabset_1\cup\METAlabset_2}{\{\METAlab\}}}$
%%     \\
%% %%   \end{tabular}
%% %%   \caption{The ``reduce'' algorithm}
%% %%   \label{fig:reduce}
%% %% \end{\myfigure}


%% %% \begin{\myfigure}[!th]
%% %%   \begin{tabular}{ l l l l l }
%%     $\minrulezero$
%%     & $\MEMnewminimise{\mytuple{\METAuniferrorkind_1,\METAlabset_1,\METAidset_1}}{\METAcsset}$
%%     & $\fra$
%%     & $\MEMnewminimiseend{\METAerror}$,
%%     & if $\MEMgetbindingsp{\METAcsset}{\emptyset}\ffra\MEMgetbindingsend{\METAlabsetseq}$
%%     and
%%     $\MEMunbind{\METAlabsetseq}{\METAlabset_1}{\emptyset}{\emptyset}{\METAcsset}
%%     \ffra
%%     \MEMunbind{\emptyset}{\METAlabset_2}{}{}{\METAcsset}$
%%     \\

%%     & & & & and
%%     $\MEMreduce{\METAcsset}{\emptyset}{\METAlabset_2}{\METAerror}
%%     \ffra
%%     \MEMreduce{\METAcsset}{\METAlabset_3}{\emptyset}{}$
%%     and
%%     $\MEMgetuniferror{\MEMcsprojp{\METAcsset}{\METAlabset_3}{\emptyset}}{\METAerror}$
%%   \end{tabular}
%%   \end{\sizetables}
%%   \caption{Minimisation algorithm}
%%   \label{fig:minalgo}
%% \end{\myfigure}


\begin{\myfigure}[t]
  \begin{\sizeintables}

    \mytitle{minimisation}

  \begin{tabular}{ l l l l l }
    $\reduceruleone$
    & $\MEMreduce{\METAcsenv}{\METAlabset_1}{\{\METAlab\}\dunion\METAlabset_2}{\METAerror}$
    & $\fmin$
    & $\MEMreduce{\METAcsenv}{\METAlabset_1\cap\METAcdepset}{\METAlabset_2\cap\METAcdepset}{\METAerror'}$,
    & if $\MEMgetuniferror{\MEMcsprojp{\METAcsenv}{\METAlabset_1\cup\METAlabset_2}{\{\METAlab\}}}{\CONSerror{\METAuniferrorkind}{\METAcdepset}}$
    \\

    $\reduceruletwo$
    & $\MEMreduce{\METAcsenv}{\METAlabset_1}{\{\METAlab\}\dunion\METAlabset_2}{\METAerror}$
    & $\fmin$
    & $\MEMreduce{\METAcsenv}{\METAlabset_1\cup\{\METAlab\}}{\METAlabset_2}{\METAerror'}$,
    & if $\MEMissuccess{\MEMcsprojp{\METAcsenv}{\METAlabset_1\cup\METAlabset_2}{\{\METAlab\}}}$
    \\

    $\minrulezero$
    & \multicolumn{4}{l}{
      $\MEMminimisep{\METAcsenv}{\METAerror}{\METAerror'}$,
      $\begin{array}[t]{ll@{\hspace{0.2in}}l}
        \mbox{if}
        &
        \MEMgetbindingspp{\METAcsenv}=\METAlabset
        &
        \\
        \wedge
        &
        \MEMreduce{\METAcsenv}{\MEMlabelset{\METAerror}\setminus\METAlabset}{\MEMlabelset{\METAerror}\cap\METAlabset}{}
        \ffmin
        \MEMreduce{\METAcsenv}{\METAlabset_1}{\emptyset}{}
        &
        \mbox{(phase1)}
        \\
        \wedge
        &
        \MEMreduce{\METAcsenv}{\emptyset}{\METAlabset_1}{\METAerror}
        \ffmin
        \MEMreduce{\METAcsenv}{\METAlabset_2}{\emptyset}{}
        &
        \mbox{(phase2)}
        \\
        \wedge
        &
        \MEMgetuniferror{\MEMcsprojp{\METAcsenv}{\METAlabset_2}{\emptyset}}{\METAerror'}
        &
      \end{array}$
    }
    %% $\minrulezero$
    %% & $\MEMnewminimise{\METAerror}{\METAcsenv}$
    %% & $\fmin$
    %% & $\MEMnewminimiseend{\METAerror'}$,
    %% & if
    %% $\MEMgetbindingspp{\METAcsenv}=\METAlabset$
    %% \\
    %% & \multicolumn{4}{l}{
    %%   and
    %%   $\MEMreduce{\METAcsenv}{\MEMlabelset{\METAerror}\setminus\METAlabset}{\MEMlabelset{\METAerror}\cap\METAlabset}{}
    %%   \ffmin
    %%   \MEMreduce{\METAcsenv}{\METAlabset_1}{\emptyset}{}$
    %%   and
    %%   $\MEMreduce{\METAcsenv}{\emptyset}{\METAlabset_1}{\METAerror}
    %%   \ffmin
    %%   \MEMreduce{\METAcsenv}{\METAlabset_2}{\emptyset}{}$
    %%   and
    %%   $\MEMgetuniferror{\MEMcsprojp{\METAcsenv}{\METAlabset_2}{\emptyset}}{\METAerror'}$
    %% }
  \end{tabular}



%%     \vspace*{0.05in}
%%     \mytitle{minimisation}

%%   \begin{tabular}{ l l l l l }
%%     $\unbindruleone$
%%     & $\MEMunbind{\mytuple{\METAlab}@\METAlabseq}{\METAlabset}{}{}{\METAcsenv}$
%%     & $\fmin$
%%     & $\MEMunbind{\METAlabseq}{\METAlabset}{}{}{\METAcsenv}$,
%%     & if $\MEMissuccess{\MEMcsprojp{\METAcsenv}{\METAlabset}{\{\METAlab\}}}$
%%     \\

%%     $\unbindruletwo$
%%     & $\MEMunbind{\mytuple{\METAlab}@\METAlabseq}{\METAlabset}{}{}{\METAcsenv}$
%%     & $\fmin$
%%     & $\MEMunbind{\METAlabseq}{\METAlabset\cap\afunc{\METAerror}{1}}{}{}{\METAcsenv}$,
%%     & if $\MEMgetuniferror{\MEMcsprojp{\METAcsenv}{\METAlabset}{\{\METAlab\}}}{\METAerror}$
%%     \\
%% %%   \end{tabular}
%% %%   \caption{The ``unbinding'' algorithm}
%% %%   \label{fig:unbinding}
%% %% \end{\myfigure}


%% %% \begin{\myfigure}[!th]
%% %%   \begin{tabular}{ l l l l l }
%%     $\reduceruleone$
%%     & $\MEMreduce{\METAcsenv}{\METAlabset_1}{\{\METAlab\}\dunion\METAlabset_2}{\METAerror}$
%%     & $\fmin$
%%     & $\MEMreduce{\METAcsenv}{\METAlabset_1}{\METAlabset_2\cap\afunc{\METAerror}{1}}{\METAerror'}$,
%%     & if $\MEMgetuniferror{\MEMcsprojp{\METAcsenv}{\METAlabset_1\cup\METAlabset_2}{\{\METAlab\}}}{\METAerror}$
%%     \\

%%     $\reduceruletwo$
%%     & $\MEMreduce{\METAcsenv}{\METAlabset_1}{\{\METAlab\}\dunion\METAlabset_2}{\METAerror}$
%%     & $\fmin$
%%     & $\MEMreduce{\METAcsenv}{\METAlabset_1\cup\{\METAlab\}}{\METAlabset_2}{\METAerror'}$,
%%     & if $\MEMissuccess{\MEMcsprojp{\METAcsenv}{\METAlabset_1\cup\METAlabset_2}{\{\METAlab\}}}$
%% %%    \\
%% %%   \end{tabular}
%% %%   \caption{The ``reduce'' algorithm}
%% %%   \label{fig:reduce}
%% %% \end{\myfigure}
%%   \end{tabular}
%%   \hspace*{-0.1in}
%%   \begin{tabular}{ l l l l }
%% %% \begin{\myfigure}[!th]
%% %%   \begin{tabular}{ l l l l l }
%%     $\minrulezero$
%%     & $\MEMnewminimise{\METAerror}{\METAcsenv}$
%%     & $\fmin$
%%     & $\MEMnewminimiseend{\METAerror'}$,
%%     \\
%%     & \multicolumn{3}{l}{
%%       if
%%       $\MEMgetbindingspp{\METAcsenv}=\METAlabseq$
%%     }
%%     \\
%%     & \multicolumn{3}{l}{
%%       and
%%       $\MEMunbind{\METAlabseq}{\MEMlabelset{\METAerror}}{\emptyset}{\emptyset}{\METAcsenv}
%%       \ffmin
%%       \MEMunbind{\emptyset}{\METAlabset_2}{}{}{\METAcsenv}$
%%     }
%%     \\
%%     & \multicolumn{3}{l}{
%%       and
%%       $\MEMreduce{\METAcsenv}{\emptyset}{\METAlabset_2}{\METAerror}
%%       \ffmin
%%       \MEMreduce{\METAcsenv}{\METAlabset_3}{\emptyset}{}$
%%     }
%%     \\
%%     & \multicolumn{3}{l}{
%%       and
%%       $\MEMgetuniferror{\MEMcsprojp{\METAcsenv}{\METAlabset_3}{\emptyset}}{\METAerror'}$
%%     }
%%   \end{tabular}

%%   \end{\sizetables}
%%   \caption{Minimisation algorithm}
%%   \label{fig:minalgo}
%% \end{\myfigure}
%% \begin{\myfigure}[!th]
%%   \begin{\sizetables}

    %\mytitle{syntax}


    \vspace*{0.05in}

    \mytitle{enumeration}
    %\mytitle{syntax}
    %% \begin{tabular}{llll}
    %%   & $\SETmstate$
    %%   & $::=$
    %%   & $\MEMreduce{\METAcsenv}{\METAlabset_1}{\METAlabset_2}{}$
    %% \end{tabular}\hspace{0.1in} and \hspace{0.1in}

    %\vspace*{-0.05in}

    \begin{\enumtab}[t]{ l l c l }
      $\enumruleone$
      & $\MEMenum{\METAunifstate}{\METAcsenv}$
      & $\fenum$
      & $\MEMenumrun
      {\METAunifstate}
      {\METAcsenv}
      {\emptyset}
      {\{\emptyset\}}$
      \\

      $\enumruletwo$
      & $\MEMenumrun{\METAunifstate}{\METAcsenv}{\METAerrorset}{\emptyset}$
      & $\fenum$
      & $\MEMerrorset{\METAerrorset}$
      \\

      %% $\enumruletwo$
      %% & $\MEMenumrun{\METAunifstate}{\METAcsenv}{\METAerrorset}{\emptyset}$
      %% & $\fenum$
      %% & $\MEMerrorset{\METAerrorset}$
      %% \\

      $\enumrulethree$
      & $\MEMenumrun{\METAunifstate}{\METAcsenv}{\METAerrorset}{\METAlabsetset\dunion\{\METAlabset\}}$
      & $\fenum$
      & $\MEMenumrun
      {\METAunifstate}
      {\METAcsenv}
      {\METAerrorset}
      {\METAlabsetset}$,
      if
      $\MEMissuccess{\MEMcsprojp{\METAcsenv}{\MEMlabelset{\METAcsenv}}{\METAlabset}}$
      \\

      $\enumrulefour$
      & $\MEMenumrun{\METAunifstate}{\METAcsenv}{\METAerrorset}{\METAlabsetset \dunion \{\METAlabset\}}$
      & $\fenum$
      & $\MEMenumrun
      {\METAunifstate}
      {\METAcsenv}
      {\METAerrorset\cup\{\CONSerror{\METAuniferrorkind}{\METAcdepset}\}}
      {
        \METAlabsetset'
        \cup
        \METAlabsetset
      }$,
      \\
      & \multicolumn{3}{l}{%\hspace*{0.2in}if
        if
        $\MEMgetuniferror{\MEMcsprojp{\METAcsenv}{\MEMlabelset{\METAcsenv}}{\METAlabset}}{\METAerror}$
      }
      \\
      & \multicolumn{3}{l}{
        $\wedge$
        $\MEMminimisep{\METAcsenv}{\METAerror}{\CONSerror{\METAuniferrorkind}{\METAcdepset}}$
%      }
%      \\
%      & \multicolumn{3}{l}{%\hspace*{0.2in}and
      }
      \\
      & \multicolumn{3}{l}{
        $\wedge$
        $\METAlabsetset'
        =
        \{\METAlabset\cup\{\METAlab\}
        \mid
        \METAlab\in\METAcdepset
        \wedge
        \forallexp{\METAlabset_0\in\METAlabsetset}{\METAlabset_0\not\subseteq\METAlabset\cup\{\METAlab\}}\}$
      }
      %% \\
      %% & \multicolumn{3}{l}{%\hspace*{0.2in}and
      %%   and
      %%   $\METAlabsetset''=\{\METAlabset\in\METAlabsetset
      %%   \mid
      %%   \neg\MEMdisj{\MEMlabelset{\METAerror'},\METAlabset}\}$
      %% }
    \end{\enumtab}
  \end{\sizeintables}
  \caption{Minimisation and enumeration algorithms}
  \label{fig:minalgo}
  %\caption{Enumeration algorithm}
  \label{fig:enumalgo}
\end{\myfigure}



%\subsubsection{Enumeration}
%\label{sec:enumeration}


%% Let $\MEMenumdone{\METAerror}{\METAerrorset}{\METAcsset}{\METAerrorset'}{\METAlabset}$
%% be true iff:
%% \begin{center}
%%   \begin{tabular}{l}
%%     if
%%     $\existsexp
%%     {\METAerror'\in\METAerrorset}
%%     {
%%       \afunc{\METAerror'}{1} \subseteq \afunc{\METAerror}{1}
%%       \wedge
%%       \afunc{\METAerror'}{2} \subseteq \afunc{\METAerror}{2}
%%     }$
%%     \\
%%     then
%%     $\mytuple{\METAerrorset',\METAlabset}=\mytuple{\METAerrorset,\emptyset}$
%%     \\
%%     else
%%     $\mytuple{\METAerrorset',\METAlabset}=\mytuple{\METAerrorset\cup\{\METAerror''\},\afunc{\METAerror''}{1}}$
%%     \\
%%     \hspace*{0.2in}where
%%     $\MEMnewminimise{\METAerror}{\METAcsset} \ffra
%%     \MEMnewminimiseend{\METAerror''}$.
%%   \end{tabular}
%% \end{center}



\subsubsection{Enumeration algorithm}
\label{sec:enumalgo}
%

Enumeration states are defined as follows:
\begin{center}
  \begin{\sizeintablesp}
    \begin{tabular}{llll}
      $\SETestate$
      & $::=$
      & $\MEMenum{\METAunifstate}{\METAcsenv}
      \mid\MEMenumrun{\METAunifstate}{\METAcsenv}{\METAerrorset}{\METAlabsetset}
      \mid\MEMerrorset{\METAerrorset}$
    \end{tabular}
  \end{\sizeintablesp}
\end{center}

Fig.~\ref{fig:enumalgo} also defines our
%
\index{enumeration algorithm}%
%
enumeration algorithm: the
relation $\fenum$ where $\ffenum$ is its reflexive
(w.r.t.\ $\SETestate$) and transitive closure.
%
Assume that $\typingSCS{\METAstrdec}{\METAcsenv}$ for
a given piece of code $\METAstrdec$.
%
An enumeration process always starts in a state of the form
$\MEMenum{\METAunifstate}{\METAcsenv}$ and stops in a state of the
form $\MEMerrorset{\METAerrorset}$.
%
Enumerating the minimal type errors in a piece of code consists of
trying to solve diverse results of filtering
% (using $\MEMcsprojSYMB$)
the constraints generated for the piece of code.  The tested filters
(label sets) form the search space which is built while searching for
errors.  The enumeration algorithm starts with a single filter: the
empty set, so that the constraint solver is called on all the
generated constraints.  Then, when an error is found and minimised,
the labels of the error are used to build new filters (see
$\METAlabsetset'$ in rule~$\enumrulefour$).
%
Once the filters are exhausted the enumeration algorithm stops.
The found errors are then all the minimal type errors of the analysed
piece of code (see rule~$\enumruletwo$).
%
In an enumeration process, the second enumeration state is always (see
rule~$\enumruleone$):
$\MEMenumrun{}{\METAcsenv}{\emptyset}{\{\emptyset\}}$
where the first empty set is the set of found errors (empty at the
beginning) and where the second empty set is the first filter.
If $\METAstrdec$ is untypable, the constraint solver fails and
returns a type error $\METAerror_1$ of the form
$\CONSerror{\METAuniferrorkind_1}{\METAcdepset_1}$.
The minimisation algorithm
minimises $\METAerror_1$ and returns a minimal error
$\METAerror_2$ of the form
$\CONSerror{\METAuniferrorkind_2}{\METAcdepset_2}$ such that
$\METAcdepset_2\subseteq\METAcdepset_1$.
The error $\METAerror_2$ can be $\METAerror_1$ if it was already in a
minimal form when found by the enumerator.
%
New filters are computed based on the filter used to find this
new error ($\emptyset$ in our example) and the new error
$\METAerror_2$ itself:
$\{\{\METAlab\}\mid\METAlab\in\METAcdepset_2\}$.  The
enumerator keeps searching for errors using this updated search
space: the new state is
$\MEMenumrun{}{\METAcsenv}{\{\METAerror_2\}}{\{\{\METAlab\}\mid\METAlab\in\METAcdepset_2\}}$.
At the next step, one of the $\{\METAlab\}$ where
$\METAlab\in\METAcdepset_2$ will be picked as the filter to
try to find another error.  When a filter leads to a solvable filtered
environment, the filter is discarded (rule~$\enumrulethree$) otherwise
it is used to update the search space as explained above
(rule~$\enumrulefour$).



\subsubsection{Minimisation and binding discarding}
\label{sec:minbinddiscard}
%


Let us describe a step of the first phase of our minimisation
algorithm.  We test if we can remove a label $\METAlab$ associated
with a binder $\METAbind$ from the slice we want to minimise (and
still obtain a type error slice) by first filtering the constraints of
the original piece of code as follows:
$\MEMcsprojp{\METAcsenv}{\METAlabset}{\{\METAlab\}}$, to obtain
$\METAcsenv'$ and where $\METAcsenv$ is the environment generated for
the original piece of code and $\METAlabset\cup\{\METAlab\}$ is the
label set labelling the slice that is being minimised.  In order not
to mix up the bindings, at constraint filtering, the binder
$\METAbind$ associated with $\METAlab$ is not discarded but is
replaced by a non labelled dummy binder $\METAbind'$ (such that
$\METAbind'=\MEMunlab{\METAbind}$) that cannot participate to any
error but that still acts as a binder.  If we then solve $\METAcsenv'$
and obtain an error then no label labelling in $\METAcsenv'$ an
accessor to $\METAbind'$ will occur in the found error (we give below
an informal argument as why none of these accessors will be part of
the new error).  The bindings in this new error are then not mixed
up\footnote{Note that bindings can be mixed up in a filtered
  environment if and only if an accessor refers to a binder to which
  it does not refer to in the non filtered environment.}.
%
The found error is then the new slice to try to minimise further and
next time the constraints will be filtered w.r.t.\ this new slice, the
binder $\METAbind$ and its accessors will be completely thrown away
(as well as the other constraints not participating in the new error).

Let us consider the following unsolvable environment which we call $\METAcsenv$:
\begin{center}
  \begin{\sizeintablesp}
    $\CONSenvenv
    {\CONSenvenv
      {\CONSenvenv
        {\CONSenvenv
          {\cso{\METAtyvar_1}{\METAtyvar_3}{\METAlab_7}}
          {\CONSaccl{\METAid}{\METAtyvar_3}{\METAlab_6}}
        }
        {\cso{\METAtyvar_3}{\mbox{\inexamplebody{unit}}}{\METAlab_5}}
      }
      {\CONSenvenv
        {\CONSbindl{\METAid}{\METAtyvar_2}{\METAlab_4}}
        {\CONSbindl{\METAid}{\METAtyvar_1}{\METAlab_3}}
      }
    }
    {\CONSenvenv
      {\cso{\METAtyvar_2}{\mbox{\inexamplebody{unit}}}{\METAlab_2}}
      {\cso{\METAtyvar_1}{\mbox{\inexamplebody{int}}}{\METAlab_1}}
    }$
  \end{\sizeintablesp}
\end{center}
%
The only labels necessary for an error to occur are $\METAlab_1$,
$\METAlab_5$ and $\METAlab_7$.
%
Note that $\METAid$'s accessor refers to $\METAid$'s binder
labelled by $\METAlab_4$ (second binder) and not to the one labelled
by $\METAlab_3$ (first binder).
%
Let us run our minimisation algorithm on $\METAcsenv$ and let the
first step be to try to discard $\METAlab_4$.  First the filtering
function is called on $\METAcsenv$ as follows:
$\MEMcsprojp{\METAcsenv}{\{\METAlab_1,\METAlab_2,\METAlab_3,\METAlab_5,\METAlab_6,\METAlab_7\}}{\{\METAlab_4\}}$,
which results in the following environment, called
$\METAcsenv'$:
\begin{center}
  \begin{\sizeintablesp}
    $\CONSenvenv
    {\CONSenvenv
      {\CONSenvenv
        {\CONSenvenv
          {\cso{\METAtyvar_1}{\METAtyvar_3}{\METAlab_7}}
          {\CONSaccl{\METAid}{\METAtyvar_3}{\METAlab_6}}
        }
        {\cso{\METAtyvar_3}{\mbox{\inexamplebody{unit}}}{\METAlab_5}}
      }
      {\CONSenvenv
        {\CONSbind{\METAid}{\CONSfreshvar{\METAtyvar}}}
        {\CONSbindl{\METAid}{\METAtyvar_1}{\METAlab_3}}
      }
    }
    {\CONSenvenv
      {\cso{\METAtyvar_2}{\mbox{\inexamplebody{unit}}}{\METAlab_2}}
      {\cso{\METAtyvar_1}{\mbox{\inexamplebody{int}}}{\METAlab_1}}
    }$
  \end{\sizeintablesp}
\end{center}
At constraint solving, running on $\METAcsenv'$, when dealing with the
accessor $\CONSaccl{\METAid}{\METAtyvar_3}{\METAlab_6}$, the dummy
binder $\CONSbind{\METAid}{\CONSfreshvar{\METAtyvar}}$ is accessed and
the equality constraint
$\csou{\METAtyvar_3}{\CONSfreshvar{\METAtyvar}}$ is generated by
rule~$\unifruleaccc$.  This constraint is then discarded by
rule~$\unifruletwentyone$ thanks to the definition of
$\MEMpushunifierSYMB$ and because
$\CONSfreshvar{\METAtyvar}\in\SETfreshvar$.  Therefore, the accessor
and its label are discarded at constraint solving and cannot occur in
any error.  In our example, on $\METAcsenv'$, the constraint solver
terminates in an error state, which means that $\METAlab_4$ is
unnecessary for an error to occur.  The error returned by the
constraint solver does not involve $\METAlab_4$ or $\METAlab_6$ and
especially, in the next step of the minimisation process, $\METAid$'s
accessor cannot refer to $\METAid$'s first binder.


Note that filtering itself does not prevent bindings to get mixed up
because, e.g., filtering allows one to throw away the binder
generated for the second occurrence of \inexamplebody{x} in
\inexamplebody{fn x => fn x => x} while not throwing away the binder
generated for the first occurrence of \inexamplebody{x} and not
throwing away its accessor.  However, we give below an informal
argument as why we never filter a binder without filtering its
accessor.

Let us now present an informal argument as why when our constraint
solver returns an error, the error does not involve accessors to dummy
binders or accessors without their corresponding binders.

According to rules $\unifruleacca$-$\unifruleaccd$, during constraint
solving the label labelling an accessor only gets recorded in a
\CONTEXT\ $\METAunifstate$ of the form
$\MEMconsStateEnvp{\METAunifstatety}{\METAcsenv}{}$ if the accessed
identifier is in the type environment $\METAcsenv$ stored in
$\METAunifstate$ in the current state (the state in which the
constraint solving process is when the rule applies).
%
There are two possible scenarios.
%
In the environment $\METAcsenv$
(1) either the accessed identifier has a dummy static
semantics (resulting from filtering) and then, according to rules
$\unifruletwentyone$ and $\unifruleesone$,
% and $\unifrulestatone$,
the label of the accessor does not get recorded into the
\CONTEXT\ $\METAunifstate$.
%
In more details, given an accessor $\CONSacc{\METAgenid}{\METAvar}$,
according to rules~$\unifruleacca$ and $\unifruleaccc$, a constraint
of the form $\csou{\METAvar}{\METAvar'}$ is generated, where
$\METAvar'\in\SETfreshvar$ comes from the accessed $\METAgenid$ binder.
% and $x\in\SETvar$ or of the form
% $\csou{\CONSstatusa}{x}$ where $x\in\SETrawstatus$,
Then $\unifruletwentyone$ or $\unifruleesone$
% or $\unifrulestatone$
applies and the newly generated constraint is discarded without
generating anything.
%
(2) Or the accessed identifier has a labelled non-dummy static
semantics, and the labels associated with the binder and the label
associated with the bound occurrence will always occur together in the
\CONTEXT.
%
The main point being that in our system if a binder is not a dummy
binder then it is labelled.

This is why we strongly believe that an identifier occurring at a
non-binding position in a piece of code (represented by an accessor in
our constraint language) only occurs in a slice if it is bound and its
binder occurs in the slice as well.


\tocheck{This argumentation relies on the fact that our labelled external
syntax together with our initial constraint generation algorithm
enforce that each bound occurrence of an identifier is labelled by a
unique label that does not label a larger piece of code and therefore
the label labelling an accessor does not label any other constraint
term (see principle \principleF\ presented in
Sec.~\ref{sec:principles}).  Therefore in case (1) described above,
once the accessor and the generated equality constraint have been
dealt with and discarded, the label labelling the accessor does
not occur anymore in the state in which the constraint solver is.
This label cannot then be part of any error.  Note that this would not
necessarily be the case with an initial constraint generation rule
that would generate
$\mytuple{
  \METAtyvar,
  (\CONSenvenv
            {(\CONSaccl{\METAgenid}{\METAtyvar_1}{\METAlab})}
            {(\cso{\METAtyvar}{\CONSarrowty{\METAtyvar_1}{\METAtyvar_2}}{\METAlab})})
}$
for some term.  As a matter of fact, we could imagine a scenario where
$\METAtyvar$ is further constrained to, e.g.,
\inexamplebody{int}.  We would therefore obtain a type constructor
clash (between \inexamplebody{int} and the arrow type constructor)
that involves $\METAlab$ but that does not require the accessor
to be resolved.  The accessor being kept alive in this error, at the
next step of the minimisation algorithm, we would have no guarantee
that it does not refer to a different binder from the one it refers to
(if referring to any) in the non filtered environment.}


%% This argument would be enough if only the rules
%% $\MEMgencgrulea$,
%% $\MEMgencgruleg$, and
%% $\MEMgencgruleq$
%% were generating accessors because
%% each of them generates a unique labelled accessor.
%% %
%% This is unfortunately not the case for
%% % the rules $\MEMgencgrulef$ and
%% rule~$\MEMgencgruleh$.
%% %These rules
%% This rule
%% generate labelled
%% accessors as well as labelled equality constraints.
%% %
%% %% Note that this can easily be solved by uniquely labelling the
%% %% identifiers in these two rules.
%% %
%% Such a labelled equality constraint could then potentially participate
%% in an error without having the accessor and its binder directly
%% participating.  We could then potentially have the label of an
%% identifier occurring at a bound position participate in an error
%% without having its binding occurrence participate.
%% %
%% We strongly believe that this is not the case in our system.
%% %We do not believe so.
%% %
%% First, let us point out that this issue could be fixed by enforcing in
%% our labelled syntax that each identifier must be labelled by a unique
%% label that does not label any larger piece of syntax.  This
%% enforcement can be considered as a design principle (which we name
%% design principle \principleF) concerning the labelled syntax, that was
%% not followed in this document for clarity purposes.
%% %
%% Let us now explain why the enforcement described above is superfluous
%% in the system described in this document.
%% %
%% %% Let us first consider
%% %% rule~$\MEMgencgrulef$.  The type $\METAtyvar_2$ returned in this rule
%% %% does not directly occur on the left or right-hand-side of the
%% %% generated constraint.  For $\METAtyvar_2$ (which is the link with the
%% %% context of the pattern) to be constrained to be equal to a type
%% %% (except through the context of the pattern), first $\METAtyvar_1$ has
%% %% to be constrained to be equal to a type.  The only way for
%% %% $\METAtyvar_1$ to be constrained is to solve the generated accessor
%% %% which would result in the case of an error in having the binder of the
%% %% identifier participate in the error.
%% %
%% %The same reasoning applies to rule~$\MEMgencgruleh$.  The type
%% In rule~$\MEMgencgruleh$,
%% the returned type $\METAtyvar'$ is constrained to be equal to
%% $\CONSconsty{\METAtynamevar}{\METAtyvar}$ which at this stage can be
%% equal to any other type.  This is true thanks to the internal type
%% constructor $\CONStyconnamearrow$ which corresponds to the arrow type
%% constructor $\MEMtyarrow$.  Without this type constructor
%% $\CONStyconnamearrow$, at constraint solving we could infer that
%% $\CONSconsty{\METAtynamevar}{\METAtyvar}$ cannot be an arrow type (of
%% the form $\METAlabtyarrowp{\METAlabty_1}{\METAlabty_2}{}$) and
%% generate an error.
%% % because $\METAtynamevar$ and $\MEMtyarrow$ do not have the same arity.
%% Because of that, we would obtain:

%% \examplebody{
%% \Bl
%% \lslice\Bl..datatype 'a t = U of 'a
%%     \\
%%     ..datatype \lslice..\rslice\ = T of \lslice..\rslice\ t
%%     \\
%%     ..val rec g = fn \lslice..\rslice\ => \lslice..\rslice
%%     \\
%%     \Bi\Bi
%%     ..\lslice\Bl..val rec h = fn U x => T x
%%                 \\
%%                 ..h (U g)..\rslice..\rslice
%%                 \El
%%     \Ei\Ei
%%  \El
%% \El
%% }

%% \noindent
%% as a minimal slice for:

%% \examplebody{
%% \Bl
%% structure S = struct
%% \\
%%   \Bi
%%   datatype 'a t = U of 'a
%%   \\
%%   datatype 'a t = T of 'a t
%%   \\
%%   val rec g = fn v => v
%%   \\
%%   val rec f = fn v => \Bl let val rec h = fn U x => T x
%%                           \\
%% 		          in h (U g)
%%                           \\
%% 		          end
%%                           \El
%%   \Ei
%% \\
%% end
%% \El
%% }

%% In the first slice \inexamplebody{t}'s occurrence in
%% \inexamplebody{T}'s declaration is not bound to the same occurrence of
%% \inexamplebody{t} as in the original code.

%% But because we allow $\CONSconsty{\METAtynamevar}{\METAtyvar}$ to be
%% equal to any type as long as $\METAtynamevar$ is not constrained to be
%% equal to a type constructor name or to $\CONStyconnamearrow$ we then
%% need to resolve the accessor generated in rule~$\MEMgencgruleh$ to
%% obtain a type error if any.  For the piece of code presented above we
%% then obtain the following minimal type error slice instead of the one
%% displayed above:

%% \examplebody{
%% \Bl
%% \lslice\Bl..datatype 'a t = U of 'a
%%        \\
%%        ..datatype 'a t = T of \lslice..\rslice\ t
%%        \\
%%        ..val rec g = fn \lslice..\rslice\ => \lslice..\rslice
%%        \\
%%        \Bi\Bi
%%        ..\lslice\Bl..val rec h = fn U x => T x
%%                  \\
%%                  ..h (U g)..\rslice..\rslice
%%                  \El
%%        \Ei\Ei
%%        \El
%% \El
%% }

%% This type error slice differs from the previous one by the presence of
%% \inexamplebody{t}'s second binding occurrence in the slice.


%% Can't have circularity neither.


\mynote{(2010-05-20)}{Testcase 463 is an example that shows that
  because of rule~$\MEMgencgruleh$, we can obtain type errors where
  the bindings are different from the bindings in the original code.
  It does not show that we can find wrong errors though.  For
  $\MEMgencgruleh$, we might to drop the constraint solving rule that say
  that a type constructor variable cannot be equal to an arrow type.
  Or we need to forbid $\MEMgencgruleh$ generating one of these type
  constructor variable.  Both solution have drawbacks: minimality for
  the first one and presentation for the second one (the type
  constructor accessor would have to get types and not type
  constructors or we would have to have two kinds of type constructor
  variables).  }

Thanks to the invariant that if a binder is filtered out then its
bound occurrences are also filtered out, we can then easily compute
free identifiers thanks to rule~$\unifruleaccd$ which is the rule
for an accessor for which no binder exists in the current
\CONTEXT\ (i.e., for free identifiers) or for which the binder is
hidden.

%% We could also enforce this invariant by (1)~ensuring that identifiers
%% are labelled independently from any other piece of syntax (design
%% principle \principleF\ presented above), (2)~ensuring that at
%% constraint generation, if a label $\METAlab$ labels an accessor then
%% it does not label any other constraint, and (3)~discarding accessors
%% when the corresponding binders are dummy binders (binding a dummy
%% variable).
% or the status $\CONSstatusa$).

%% Alternatively, we could enforce this invariant by adding an extra
%% component to unification contexts as follows:
%% $\MEMconsStateEnvpp{\METAunifstatety}{\METAcsenv}{\METAlabset}$, where
%% $\METAlabset$ indicates the labels that are not allowed to participate
%% in an error.  If an error is found involving a label in $\METAlabset$
%% then this error is not reported.



\hidden{
\subsubsection{Discussion of the search space used by our enumerator}
%


The search space used by our enumeration algorithm is a set of filters
(where a filter is a label set).  For example, given an environment
$\METAcsenv$, if using\footnote{Given an environment $\METAcsenv$, by
  using a filter $\METAlabset$ we mean running the constraint solver
  on $\MEMcsprojp{\METAcsenv}{\MEMlabelset{\METAcsenv}}{\METAlabset}$
  which is the environment $\METAcsenv$ where, among other things, the
  equality constraints labelled by $\METAlabset$ are filtered out.}
the filter $\METAlabset$ the enumeration algorithm finds a minimal
error labelled by the set $\{\METAlab_1,\METAlab_2\}$ then to search
for other type errors, it generates the two filters
$\METAlabset\cup\{\METAlab_1\}$ and $\METAlabset\cup\{\METAlab_2\}$
(if no smaller filter is already in the search space).  As a matter of
fact, if another error (different from the one labelled by
$\{\METAlab_1,\METAlab_2\}$) can be found in
$\MEMcsprojp{\METAcsenv}{\MEMlabelset{\METAcsenv}}{\METAlabset}$ then
this other error cannot be labelled by both $\METAlab_1$ and
$\METAlab_2$, otherwise it has to be the minimal type error
$\{\METAlab_1,\METAlab_2\}$.  So we want to search for errors that are
not labelled by $\METAlabset\cup\{\METAlab_1\}$ and for errors that are
not labelled by $\METAlabset\cup\{\METAlab_2\}$ (this allows one to
obtain a correct and terminating enumeration algorithm).
%

A particularity of the enumeration algorithm presented in
Sec.~\ref{sec:enumalgo} is that the search space stays ``relatively''
small.  However, because of the strategy used by the enumeration
algorithm to build new filters, it can happen that the same error is
generated twice (using two different filters).  Note that even though
an error can be generated twice using the algorithm presented in
Sec.~\ref{sec:enumalgo}, this cannot happen using \IMPLTES'
enumeration algorithm which differs as follows: before using a filter
$\METAlabset$, \IMPLTES' enumeration algorithm checks whether it has
already found an error $\METAerror$ using a filter at least as big as
$\METAlabset$ (superset of $\METAlabset$), and if it did it does not
use $\METAlabset$ (does not run the constraint solver) again but
instead directly generates new filters because $\METAerror$ can also
be found using $\METAlabset$.

Note that even though the enumeration algorithm presented in
Sec.~\ref{sec:enumalgo} can enumerate an error twice (using two
different filters), it terminates because no filter can be generated
twice.  (We strongly believe that the termination of our algorithm
follows from the one of \HWTES' algorithm~\cite{Haack+Wells:2004}.)

Let us explain why the enumeration algorithm presented in
Sec.~\ref{sec:enumalgo} can generate an error twice.
%
We describe a highly possible scenario.
%
Assume that $\METAcsenv$ has been generated by our initial
constraint generator for the structure declaration $\METAstrdec$,
i.e., $\typingSCS{\METAstrdec}{\METAcsenv}$.  Then, the enumeration
algorithm starts with the following transition:
\begin{center}
  \begin{\sizeintablesp}
    \begin{tabular}{l}
      $\MEMalgorule{TR1}$
    \end{tabular}
    \hspace{0.2in}
    \begin{tabular}{lll}
      $\MEMenum{\METAunifstate}{\METAcsenv}$
      & $\fra$
      & $\MEMenumrun{\METAunifstate}{\METAcsenv}{\emptyset}{\{\emptyset\}}$
    \end{tabular}
  \end{\sizeintablesp}
\end{center}
using rule~$\enumruleone$ (see Fig.~\ref{fig:enumalgo}), and where the
first $\emptyset$ is the set of found errors and $\{\emptyset\}$ is the
initial search space which only contains the empty filter $\emptyset$
at the beginning of the computation.
%

Let us now assume that the first found minimal error (using rule
$\enumrulefour$ in Fig.~\ref{fig:enumalgo}) is labelled by the label
set $\{\METAlab_1,\METAlab_4\}$
($\METAcdepset=\{\METAlab_1,\METAlab_4\}$ in rule $\enumrulefour$ in
Fig.~\ref{fig:enumalgo}).
%
The enumeration algorithm generates then the filters $\{\METAlab_1\}$
(which is the union of the filter $\emptyset$ and the set
$\{\METAlab_1\}$) and $\{\METAlab_4\}$ (which is the union of the
filter $\emptyset$ and the set $\{\METAlab_4\}$).
%
We obtain the following transition:
\begin{center}
  \begin{\sizeintablesp}
    \begin{tabular}{l}
      $\MEMalgorule{TR2}$
    \end{tabular}
    \hspace{0.2in}
    \begin{tabular}{lll}
    $\MEMenumrun
    {\METAunifstate}
    {\METAcsenv}
    {\emptyset}
    {\{\emptyset\}}$
    & $\fra$
    & $\MEMenumrun
    {\METAunifstate}
    {\METAcsenv}
    {\{\CONSerror{\METAuniferrorkind_1}{\{\METAlab_1,\METAlab_4\}}\}}
    {\{\{\METAlab_1\},\{\METAlab_4\}\}}$
    \end{tabular}
  \end{\sizeintablesp}
\end{center}
%

Using the filter $\{\METAlab_1\}$ let us assume that the enumeration
algorithm finds an other minimal error labelled by the set
$\{\METAlab_2,\METAlab_3\}$.  From the filter $\{\METAlab_1\}$, the
following filters are then generated: $\{\METAlab_1,\METAlab_2\}$ and
$\{\METAlab_1,\METAlab_3\}$.
%
The search space (set of filters yet to try) is now
$\{\{\METAlab_1,\METAlab_2\},\{\METAlab_1,\METAlab_3\},\{\METAlab_4\}\}$.
%
At this stage, the minimal type error set is
$\{\{\METAlab_1,\METAlab_4\},\{\METAlab_2,\METAlab_3\}\}$.
%
We obtain the following transition:
\begin{center}
  \begin{\sizeintablesp}
    \begin{tabular}{l}
      $\MEMalgorule{TR3}$
    \end{tabular}
    \hspace{0.2in}
    \begin{tabular}{l}
    $\MEMenumrun
    {\METAunifstate}
    {\METAcsenv}
    {\{\CONSerror{\METAuniferrorkind_1}{\{\METAlab_1,\METAlab_4\}}\}}
    {\{\{\METAlab_1\},\{\METAlab_4\}\}}$
    \\

    $\fra$
    \\

    $\MEMenumrun
    {\METAunifstate}
    {\METAcsenv}
    {
      \{
      \CONSerror{\METAuniferrorkind_1}{\{\METAlab_1,\METAlab_4\}},
      \CONSerror{\METAuniferrorkind_2}{\{\METAlab_2,\METAlab_3\}}
      \}
    }
    {
      \{
      \{\METAlab_1,\METAlab_2\},
      \{\METAlab_1,\METAlab_3\},
      \{\METAlab_4\}
      \}
    }$
    \end{tabular}
  \end{\sizeintablesp}
\end{center}
%

Let us assume now that using the filter $\{\METAlab_1,\METAlab_2\}$
the enumeration algorithm finds an error labelled by the set
$\{\METAlab_4,\METAlab_5\}$.  The enumeration algorithm generates from
the filter $\{\METAlab_1,\METAlab_2\}$, the two following filters:
$\{\METAlab_1,\METAlab_2,\METAlab_4\}$ which is immediately discarded
because it is a superset of the filter $\{\METAlab_4\}$ which is
already in our search space, and
$\{\METAlab_1,\METAlab_2,\METAlab_5\}$ which is not discarded and then
added to the search space.  The search space is then
$\{\{\METAlab_1,\METAlab_2,\METAlab_5\},\{\METAlab_1,\METAlab_3\},\{\METAlab_4\}\}$.
%
At this stage, the minimal type error set is
$\{\{\METAlab_1,\METAlab_4\},\{\METAlab_2,\METAlab_3\},\{\METAlab_4,\METAlab_5\}\}$.
%
We obtain the following transition:
\begin{center}
  \begin{\sizeintablesp}
    \begin{tabular}{l}
      $\MEMalgorule{TR4}$
    \end{tabular}
    \hspace{0.1in}
    \begin{tabular}{l}
      $\MEMenumrun
      {\METAunifstate}
      {\METAcsenv}
      {
        \{
        \METAerror_1,
        \METAerror_2
        \}
      }
      {
        \{
        \{\METAlab_1,\METAlab_2\},
        \{\METAlab_1,\METAlab_3\},
        \{\METAlab_4\}
        \}
      }$
      \\

      $\fra$
      \\

      $\MEMenumrun
      {\METAunifstate}
      {\METAcsenv}
      {
        \{
        \METAerror_1,
        \METAerror_2,
        \METAerror_3
        \}
      }
      {
        \{
        \{\METAlab_1,\METAlab_2,\METAlab_5\},
        \{\METAlab_1,\METAlab_3\},
        \{\METAlab_4\}
        \}
      }$
    \end{tabular}
    \hspace{0.1in}
    \begin{tabular}{l}
      where
      $\left\{
      \begin{array}{l}
          \METAerror_1=\CONSerror{\METAuniferrorkind_1}{\{\METAlab_1,\METAlab_4\}}
          \\
          \METAerror_2=\CONSerror{\METAuniferrorkind_2}{\{\METAlab_2,\METAlab_3\}}
          \\
          \METAerror_3=\CONSerror{\METAuniferrorkind_3}{\{\METAlab_4,\METAlab_5\}}
      \end{array}
      \right.$
    \end{tabular}
  \end{\sizeintablesp}
\end{center}
%

Let us assume that the enumeration algorithm does not generate any
error with the filter $\{\METAlab_1,\METAlab_2,\METAlab_5\}$.  It is
then discarded.  Assume that the enumeration algorithm uses then the
filter $\{\METAlab_1,\METAlab_3\}$.  The enumeration algorithm has
already found an error that can be obtained using this filter:
$\METAerror_3$ which is labelled by $\{\METAlab_4,\METAlab_5\}$, and
might then generate this error a second time.  If it does, we obtain
the following transitions:
\begin{center}
  \begin{\sizeintablesp}
    \begin{tabular}{l}
      $\MEMalgorule{TR5}$
    \end{tabular}
    \hspace{0.05in}
    \begin{tabular}{l}
      $\MEMenumrun
      {\METAunifstate}
      {\METAcsenv}
      {
        \{
        \METAerror_1,
        \METAerror_2,
        \METAerror_3
        \}
      }
      {
        \{
        \{\METAlab_1,\METAlab_2,\METAlab_5\},
        \{\METAlab_1,\METAlab_3\},
        \{\METAlab_4\}
        \}
      }$
      \\

      $\fra$
      \\

      $\MEMenumrun
      {\METAunifstate}
      {\METAcsenv}
      {
        \{
        \METAerror_1,
        \METAerror_2,
        \METAerror_3
        \}
      }
      {
        \{
        \{\METAlab_1,\METAlab_3\},
        \{\METAlab_4\}
        \}
      }$
      \\

      $\fra$
      \\

      $\MEMenumrun
      {\METAunifstate}
      {\METAcsenv}
      {
        \{
        \METAerror_1,
        \METAerror_2,
        \METAerror_3
        \}
      }
      {
        \{
        \{\METAlab_1,\METAlab_3,\METAlab_4\},
        \{\METAlab_1,\METAlab_3,\METAlab_5\},
        \{\METAlab_4\}
        \}
      }$
    \end{tabular}
    \hspace{0.0in}
    \begin{tabular}{l}
      where
      $\left\{
      \begin{array}{l}
          \METAerror_1=\CONSerror{\METAuniferrorkind_1}{\{\METAlab_1,\METAlab_4\}}
          \\
          \METAerror_2=\CONSerror{\METAuniferrorkind_2}{\{\METAlab_2,\METAlab_3\}}
          \\
          \METAerror_3=\CONSerror{\METAuniferrorkind_3}{\{\METAlab_4,\METAlab_5\}}
      \end{array}
      \right.$
    \end{tabular}
  \end{\sizeintablesp}
\end{center}
%

Now, let us present an alternative strategy to generate new filters.
%
In transition~$\MEMalgorule{TR3}$ above, instead of only generating the
filters $\{\METAlab_1,\METAlab_2\}$ and $\{\METAlab_1,\METAlab_3\}$
from the filter $\{\METAlab_1\}$ and the error
$\{\METAlab_2,\METAlab_3\}$, we also could generate the extra filters
$\{\METAlab_4,\METAlab_2\}$ and $\{\METAlab_4,\METAlab_3\}$ (and
remove $\{\METAlab_4\}$ from the search space) because
$\{\METAlab_4\}$ is a filter which is yet to try (is in the search
space) and which is disjoint from the error
$\{\METAlab_2,\METAlab_3\}$ (the error $\{\METAlab_2,\METAlab_3\}$ can
be found using the filter $\{\METAlab_4\}$).
%
Then, as before when using the filter $\{\METAlab_1,\METAlab_2\}$ (see
transition~$\MEMalgorule{TR4}$ above), this variant of our enumeration
algorithm finds an error labelled by the set
$\{\METAlab_4,\METAlab_5\}$.  As before, the filter
$\{\METAlab_1,\METAlab_2,\METAlab_5\}$ is generated and we also
replace the filter $\{\METAlab_1,\METAlab_3\}$ by the filter
$\{\METAlab_1,\METAlab_3,\METAlab_5\}$ because the filter
$\{\METAlab_1,\METAlab_3\}$ and the error $\{\METAlab_4,\METAlab_5\}$
are disjoint (we do not generate the filter
$\{\METAlab_1,\METAlab_3,\METAlab_4\}$ because it is a superset of the
already existing filter $\{\METAlab_3,\METAlab_4\}$).  The error
labelled by $\{\METAlab_4,\METAlab_5\}$ is then not going to be found
again.
%
We would then, instead of the transitions as described above, obtain
the following transitions (transitions~$\MEMalgorule{TR1}$
and~$\MEMalgorule{TR2}$ stay the same):
\begin{center}
  \begin{\sizeintablesp}
    \begin{tabular}{l}
      $\MEMenumrun
      {\METAunifstate}
      {\METAcsenv}
      {
        \{
        \METAerror_1
        \}
      }
      {\{\{\METAlab_1\},\{\METAlab_4\}\}}$
      \\

      $\fra$
      \\

      $\MEMenumrun
      {\METAunifstate}
      {\METAcsenv}
      {
        \{
        \METAerror_1,
        \METAerror_2
        \}
      }
      {
        \{
        \{\METAlab_1,\METAlab_2\},
        \{\METAlab_1,\METAlab_3\},
        \{\METAlab_4,\METAlab_2\},
        \{\METAlab_4,\METAlab_3\}
        \}
      }$
      \\

      $\fra$
      \\

      $\MEMenumrun
      {\METAunifstate}
      {\METAcsenv}
      {
        \{
        \METAerror_1,
        \METAerror_2,
        \METAerror_3
        \}
      }
      {
        \{
        \{\METAlab_1,\METAlab_2,\METAlab_5\},
        \{\METAlab_1,\METAlab_3,\METAlab_5\},
        \{\METAlab_4,\METAlab_2\},
        \{\METAlab_4,\METAlab_3\}
        \}
      }$
    \end{tabular}
    \hspace*{-0.2in}
    \begin{tabular}{l}
      where
      $\left\{
      \begin{array}{l}
          \METAerror_1=\CONSerror{\METAuniferrorkind_1}{\{\METAlab_1,\METAlab_4\}}
          \\
          \METAerror_2=\CONSerror{\METAuniferrorkind_2}{\{\METAlab_2,\METAlab_3\}}
          \\
          \METAerror_3=\CONSerror{\METAuniferrorkind_3}{\{\METAlab_4,\METAlab_5\}}
      \end{array}
      \right.$
    \end{tabular}
  \end{\sizeintablesp}
\end{center}


%% However, it appeared that this solution is less efficient than the
%% previous one.  However, we improved the speed of the enumerator
%% checking if we have already found an error that can be generated using
%% the new current filter instead of just running again the constraint solver
%% using the current filter.  In our example the filter
%% $\{\METAlab_1,\METAlab_3\}$ is discarded because
%% $\{\METAlab_1,\METAlab_3\}\cap\{\METAlab_4,\METAlab_5\}=\emptyset$.

\begin{\myfigure}[!t]
  \subfloat[Enumeration algorithm of \IMPLTES]{
    \begin{\sizeintables}
      \begin{tabular}{ l l c l }
        $\enumrulefour$
        & $\MEMenumrun{\METAunifstate}{\METAcsenv}{\METAerrorset}{\METAlabsetset \dunion \{\METAlabset\}}$
        & $\fenum$
        & $\MEMenumrun
        {\METAunifstate}
        {\METAcsenv}
        {\METAerrorset\cup\{\CONSerror{\METAuniferrorkind}{\METAcdepset}\}}
        {
          \METAlabsetset'
          \cup
          \METAlabsetset
        }$,
        \\
        & \multicolumn{3}{l}{
          if
          (($\CONSerror{\METAuniferrorkind}{\METAcdepset}\in\METAerrorset$
            $\wedge$
          $\MEMdisj{\METAlabset,\METAcdepset}$)
        }
        \\
        & \multicolumn{3}{l}{
           \hspace*{0.2in}
           $\vee$
           (($\forallexp{\CONSerror{\METAuniferrorkind_0}{\METAcdepset_0}\in\METAerrorset}{\neg\MEMdisj{\METAlabset,\METAcdepset_0}}$)
            $\wedge$
            $\MEMgetuniferror{\MEMcsprojp{\METAcsenv}{\MEMlabelset{\METAcsenv}}{\METAlabset}}{\METAerror}$
            $\wedge$
            $\MEMminimisep{\METAcsenv}{\METAerror}{\CONSerror{\METAuniferrorkind}{\METAcdepset}}$))
        }
        \\
        & \multicolumn{3}{l}{
          $\wedge$
          $\METAlabsetset'
          =
          \{\METAlabset\cup\{\METAlab\}
          \mid
          \METAlab\in\METAcdepset
          \wedge
          \forallexp{\METAlabset_0\in\METAlabsetset}{\METAlabset_0\not\subseteq\METAlabset\cup\{\METAlab\}}\}$
        }
      \end{tabular}
      \vspace*{0.1in}
    \end{\sizeintables}
    \label{fig:enumvariant1}
  }
  \subfloat[Variant to generate each error exactly once]{
    \begin{\sizeintables}
      \begin{tabular}{ l l c l }
        $\enumrulefour$
        & $\MEMenumrun{\METAunifstate}{\METAcsenv}{\METAerrorset}{\METAlabsetset \dunion \{\METAlabset\}}$
        & $\fenum$
        & $\MEMenumrun
        {\METAunifstate}
        {\METAcsenv}
        {\METAerrorset\cup\{\CONSerror{\METAuniferrorkind}{\METAcdepset}\}}
        {
          \METAlabsetset_1
          \cup
          \METAlabsetset_2
          \cup
          \METAlabsetset_3
        }$,
        \\
        & \multicolumn{3}{l}{
          if
          $\MEMgetuniferror{\MEMcsprojp{\METAcsenv}{\MEMlabelset{\METAcsenv}}{\METAlabset}}{\METAerror}$
          $\wedge$
          $\MEMminimisep{\METAcsenv}{\METAerror}{\CONSerror{\METAuniferrorkind}{\METAcdepset}}$
        }
        \\
        & \multicolumn{3}{l}{
          $\wedge$
          $\METAlabsetset_1
          =
          \{\METAlabset\cup\{\METAlab\}
          \mid
          \METAlab\in\METAcdepset
          \wedge
          \forallexp{\METAlabset_0\in\METAlabsetset}{\METAlabset_0\not\subseteq\METAlabset\cup\{\METAlab\}}\}$
        }
        \\
        & \multicolumn{3}{l}{
          $\wedge$
          $\METAlabsetset_2
          =
          \{\METAlabset_0\cup\{\METAlab\}
          \mid
          \METAlab\in\METAcdepset
          \wedge
          \METAlabset_0\in\METAlabsetset
          \wedge
          \MEMdisj{\METAlabset_0,\METAcdepset}\}$
        }
        \\
        & \multicolumn{3}{l}{
          $\wedge$
          $\METAlabsetset_3
          =
          \{\METAlabset_0
          \mid
          \METAlabset_0\in\METAlabsetset
          \wedge
          \neg\MEMdisj{\METAlabset_0,\METAcdepset}\}$
        }
      \end{tabular}
    \end{\sizeintables}
    \label{fig:enumvariant2}
  }
  \caption{Variants of our enumeration algorithm}
  \label{fig:enumvariants}
\end{\myfigure}

Finally, let us formally present two alternatives of the enumeration
algorithm presented in Fig.~\ref{fig:enumalgo}.  We only present
variants of rule~$\enumrulefour$ because the other rules stay
unchanged.
%
Fig.~\ref{fig:enumvariants}\subref*{fig:enumvariant1} presents a first
variant which is used by \IMPLTES, and
Fig.~\ref{fig:enumvariants}\subref*{fig:enumvariant2} presents a
second variant which is the one described above.
}



\subsubsection{Enumerating all the errors in example~$\examplerun$}
\label{sec:examplerun}


%% First, let us repeat example~$\examplerun$
%% defined in Sec.~\ref{sec:syntax}:
%% \begin{center}
%%   \begin{\sizeintablesp}
%%     $\LABstrdecStr
%%     {\LABstrbindBas
%%       {\mbox{\inexamplebody{X}}}
%%       {\LABstrexpFourp
%%         {\LABstrdecStr
%%           {\LABstrbindBas
%%             {\mbox{\inexamplebody{S}}}
%%             {\LABstrexpOne
%%               {\LABstrdecDec
%%                 {\LABdecDat
%%                   {\LABspdatbind
%%                     {\LABdatnamep{\mbox{\inexamplebody{'a}}}{\mbox{\inexamplebody{u}}}{\METAlab_6}}
%%                     {\LABtypeconId{\mbox{\inexamplebody{U}}}{\METAlab_7}}
%%                     {\METAlab_5}
%%                   }
%%                 }
%%               }
%%               {}
%%               {\METAlab_4}
%%             }
%%             {\METAlab_3}
%%           }
%%         }
%%         {\LABstrdecDec
%%           {\LABdecDat
%%             {\LABspdatbind
%%               {\LABdatnamep{\mbox{\inexamplebody{'a}}}{\mbox{\inexamplebody{t}}}{\METAlab_9}}
%%               {\LABtypeconId{\mbox{\inexamplebody{T}}}{\METAlab_{10}}}
%%               {\METAlab_8}
%%             }
%%           }
%%         }
%%         {\LABstrdecDec
%%           {\LABdecVal
%%             {\LABvalbind
%%               {\LABpatAtpat{\LABpatId{\mbox{\inexamplebody{f}}}{\METAlab_{12}}}}
%%               {\LABexpFnp
%%                 {\LABmrule
%%                   {\LABpatAtpat{\LABpatId{\mbox{\inexamplebody{T}}}{\METAlab_{14}}}}
%%                   {\LABexpAtexp{\LABexpId{\mbox{\inexamplebody{T}}}{\METAlab_{15}}}}
%%                   {\METAlab_{13}}
%%                 }
%%                 {}
%%               }
%%               {\METAlab_{11}}
%%             }
%%           }
%%         }
%%         {\LABstrdecDec
%%           {\LABdecVal
%%             {\LABvalbind
%%               {\LABpatAtpat{\LABpatId{\mbox{\inexamplebody{g}}}{\METAlab_{17}}}}
%%               {\LABexpAtexp
%%                 {\LABexpLet
%%                   {\LABdecOpen{\mbox{\inexamplebody{S}}}{\METAlab_{19}}}
%%                   {\LABexpApp
%%                     {\LABexpAtexp{\LABexpId{\mbox{\inexamplebody{f}}}{\METAlab_{21}}}}
%%                     {\LABexpId{\mbox{\inexamplebody{U}}}{\METAlab_{22}}}
%%                     {\METAlab_{20}}
%%                   }
%%                   {\METAlab_{18}}
%%                 }
%%               }
%%               {\METAlab_{16}}
%%             }
%%           }
%%         }
%%         {\METAlab_2}
%%       }
%%       {\METAlab_1}
%%     }$
%%   \end{\sizeintablesp}
%% \end{center}

It turns out that example~$\examplerun$ has only one minimal type
error which is $\METAerror_{EX}$ defined in
Sec.~\ref{sec:solvexamplerun} as the pair
$\CONSerror{\METAuniferrorkind_{\mathrm{EX}}}{\METAcdepset_{\mathrm{EX}}}$
where $\METAcdepset_{\mathrm{EX}}$ is the following set:
\begin{center}
  \begin{\sizeintablesp}
    $\{
    \METAlab_{3},
    \METAlab_{4},
    \METAlab_{5},
    \METAlab_{6},
    \METAlab_{7},
    \METAlab_{8},
    \METAlab_{9},
    \METAlab_{10},
    \METAlab_{11},
    \METAlab_{12},
    \METAlab_{13},
    \METAlab_{14},
    \METAlab_{19},
    \METAlab_{20},
    \METAlab_{21},
    \METAlab_{22}
    \}$
  \end{\sizeintablesp}
\end{center}
This error is already minimal when
found by the enumeration algorithm and therefore the minimiser does
not do anything in this case, but is still called by the enumerator.
%
Therefore we obtain the following enumeration steps (we superscript
$\fenum$ and $\ffenum$ with the names of the rules used to obtain the
provided enumeration steps):
\begin{center}
  \begin{\sizeintablesp}
    \begin{tabular}{ll}
      & $\MEMenum{}{\METAcsenv_{\mathrm{EX}}}$
      \\

      $\fenum^{\enumruleone}$
      & $\MEMenumrun{}{\METAcsenv_{\mathrm{EX}}}{\emptyset}{\{\emptyset\}}$
      \\

      $\fenum^{\enumrulefour}$
      & $\MEMenumrun{}{\METAcsenv_{\mathrm{EX}}}{\{\METAerror_{\mathrm{EX}}\}}{\{\{\METAlab\}\mid\METAlab\in\METAcdepset_{\mathrm{EX}}\}}$
      \\

      ${\ffenum}^{\enumrulethree}$
      & $\MEMenumrun{}{\METAcsenv_{\mathrm{EX}}}{\{\METAerror_{\mathrm{EX}}\}}{\emptyset}$
      \\

      $\fenum^{\enumruletwo}$
      & $\MEMerrorset{\{\METAerror_{\mathrm{EX}}\}}$
    \end{tabular}
  \end{\sizeintablesp}
\end{center}




\subsection{\SECslicing}
\label{sec:slicing}



\subsubsection{Dot terms}
\label{sec:dotterms}


Our \TES' last phase consists of computing minimal type error slices
from untypable pieces of code and minimal errors found by the
enumerator.  This is performed by the slicing function $\MEMsliceSYMB$
(defined below in Fig.~\ref{fig:newslicingalgo}).
%
The nodes labelled by the labels not involved in the error are
discarded and replaced by ``dot'' terms.
%
For example, if we remove the node associated with the label
$\METAlab_2$ (the unit expression) in
$\LABexpApp{\LABexpAtexp{\LABexpInt{1}{\METAlab_1}}}{\LABexpUnit{\METAlab_2}}{\METAlab_3}$
then we obtain
$\LABexpApp{\LABexpAtexp{\LABexpInt{1}{\METAlab_1}}}{\LABexpDots{\emptyset}}{\METAlab_3}$,
displayed as \inexamplebody{1 \lslice..\rslice} in our implementation.
%
Dots are visually convenient to show that information has
been discarded.
%
Fig.~\ref{fig:dotterms} extends our syntax and constraint generator to
dot terms.  Our constraint generator is extended to dot terms so that
every piece of our extended syntax can be type checked (by generating
constraints and by then solving the constraints), which is needed to
define type error slices and to state our minimality criteria in
Sec.~\ref{sec:minimality}.
%
We call
%
\index{slice}%
%
\textit{slice}, any syntactic form that can be produced using
the grammar rules defined in Fig.~\ref{fig:syntaxOpen} and
Fig.~\ref{fig:dotterms} combined (i.e., a $\METAterm$ as defined in
Fig.~\ref{fig:syntaxOpen}).
%
We call
%
\index{slice!type error slice}%
%
\textit{type error slice}, any slice for which our constraint
generation algorithm (defined in Fig.~\ref{fig:consGenAlgo} and
Fig.~\ref{fig:dotterms} combined) only generates unsolvable
constraints.
%
If we restrict ourselves to structure declarations, formally a slice
is a $\METAstrdec$ and a type error slice is a $\METAstrdec$ such that
$\neg\MEMissuccess{\METAstrdec}$.


\begin{\myfigure}[t]
\begin{\sizeintables}
\mytitle{extension of the syntax}

\begin{\syntslicetab}[t]{rclrl}
%$\METApart$        & $\in$ & $\SETpart$         & $::=$  & $\METAstrdec\mid\METAexp\mid\METAtype\mid\METAstrexp\mid\METApat$\\
$\SETlabtypename$  & $::=$  & $\dots\mid\LABlabgenDots{\METAtermseq}$\\
$\SETlabdcon$      & $::=$  & $\dots\mid\LABlabgenDots{\METAtermseq}$\\
$\SETsltype$       & $::=$  & $\dots\mid\LABtypeDots{\METAtermseq}$\\
$\SETsltypecon$    & $::=$  & $\dots\mid\LABtypeconDots{\METAtermseq}$\\
\end{\syntslicetab}
\hspace{0.02in}
\begin{\syntslicetab}[t]{rclrl}
$\SETsldatname$    & $::=$  & $\dots\mid\LABdatnameDots{\METAtermseq}$\\
$\SETsldec$        & $::=$  & $\dots\mid\LABdecDots{\METAtermseq}$\\
$\SETslatexp$      & $::=$  & $\dots\mid\LABexpDots{\METAtermseq}$\\
$\SETslexp$        & $::=$  & $\dots\mid\LABatexpDots{\METAtermseq}$\\
\end{\syntslicetab}
\hspace{0.02in}
\begin{\syntslicetab}[t]{rclrl}
$\SETslatpat$      & $::=$  & $\dots\mid\LABatpatDots{\METApatseq}$\\
$\SETslpat$        & $::=$  & $\dots\mid\LABpatDots{\METApatseq}$\\
$\SETstrdec$       & $::=$  & $\dots\mid\LABstrdecDots{\METAtermseq}$\\
$\SETstrexp$       & $::=$  & $\dots\mid\LABstrexpDots{\METAtermseq}$\\
\end{\syntslicetab}
\end{\sizeintables}

  \vspace{0.1in}

\begin{\sizeintables}

\mytitle{extension of the constraint generator}

\begin{\consgenslicetab}{l}

%  \hline

%% \multicolumn{1}{l}{
%%   \myboxedtitle{Parts}{($\typingSCS{\METApart}{\METAcsenv}$)}
%% }

%\\

\multicolumn{1}{l}{
  $\MEMinferbb
  {\typingSCS
    {\METAepart}
    {\METAcsenv}
  }
  {\typingCS{\METAepart}{\METAvar}{\METAcsenv}}
  {\MEMgencgruleav}$
}
\vspace{0.05in}

\\

%% \multicolumn{1}{l}{
%%   \hspace{0.5in}
%%   \myboxedtitle{Datatype names}{}
%% }

%% &

%% \multicolumn{2}{l}{
%%   $\MEMinferaa{
%%     \typingSCS
%%     {\LABdatnameDots{\emptyset}}
%%     {\mytuple{\METAtyvar,\CONSenvnul}}
%%   }{}$
%% }

%% \multicolumn{1}{l}{
%%   \myboxedtitle{Declarations}{}
%% }

%% &

\multicolumn{1}{l}{
  $\MEMinferee
  {\typingSCS
    {\LABdecDots{\mytuple{\METAterm_1,\dots,\METAterm_n}}}
    {\csbind{\CONSenvenvn{\METAcsenv_n}{}{\METAcsenv_1}}}
    %\hspace{0.260in}
  }
  {\typingSCS{\METAterm_1}{\METAcsenv_1}}
  {\cdots}
  {\typingSCS{\METAterm_n}{\METAcsenv_n}}
  {\MEMdisjvs{\METAcsenv_1,\dots,\METAcsenv_n}}
  {\MEMgencgrulear}$
}
\vspace{0.05in}

\\

%% \multicolumn{1}{l}{
%%   \myboxedtitle{Patterns}{}
%% }

%% &

\multicolumn{1}{l}{
  $\MEMinferee
  {\typingPCS
    {\LABpatDots{\mytuple{\METApat_1,\dots,\METApat_n}}}
    {\METAtyvar}
    {\CONSenvenvn{\METAcsenv_n}{}{\METAcsenv_1}}
    %\hspace{0.280in}
  }
  {\typingSCS{\METApat_1}{\METAcsenv_1}}
  {\cdots}
  {\typingSCS{\METApat_n}{\METAcsenv_n}}
  {\MEMdisjvs{\METAcsenv_1,\dots,\METAcsenv_n,\METAtyvar}}
  {\MEMgencgruleas}$
}
\vspace{0.05in}

\\

%% \multicolumn{1}{l}{
%%   \myboxedtitle{Structure expressions}{}
%% }

%% &

\multicolumn{1}{l}{
  $\MEMinfereeee
  {\typingCS
    {\LABstrexpDots{\mytuple{\METAterm_1,\dots,\METAterm_n}}}
    {\METAenvvar}
    {\csbind{\CONSenvenvn{\METAcsenv_n}{}{\METAcsenv_1}}}
  }
  {\typingSCS{\METAterm_1}{\METAcsenv_1}}
  {\cdots}
  {\typingSCS{\METAterm_n}{\METAcsenv_n}}
  {\MEMdisjvs{\METAcsenv_1,\dots,\METAcsenv_n,\METAenvvar}}
  {\MEMgencgruleat}$
}
\vspace{0.05in}

\\

%% \multicolumn{6}{l}{
%%   \myboxedtitle{Expressions/Types/Constructor bindings/Datatype names}{}
%% }

%% \\

%% &

\multicolumn{1}{l}{
  $\MEMinfereeee
  {\typingCS
    {\LABexpDots{\mytuple{\METAterm_1,\dots,\METAterm_n}}}
    {\METAtyvar}
    {\csbind{\CONSenvenvn{\METAcsenv_n}{}{\METAcsenv_1}}}
    %\hspace{0.044in}
  }
  {\typingSCS{\METAterm_1}{\METAcsenv_1}}
  {\cdots}
  {\typingSCS{\METAterm_n}{\METAcsenv_n}}
  {\MEMdisjvs{\METAcsenv_1,\dots,\METAcsenv_n,\METAtyvar}}
  {\MEMgencgruleau}$
}
\end{\consgenslicetab}
\end{\sizeintables}
  \caption{Extension of our syntax and constraint generator to ``dot'' terms}
  \label{fig:dotterms}
\end{\myfigure}

%% \begin{\myfigure}[!th]
%%   \input{included/constraintGeneratorSliceOpen}
%%   \caption{Extension of the constraint generator with rules for dot terms}
%%   \label{fig:consgendot}
%% \end{\myfigure}


%% \ifthesis
%% \intitle{Flattening.}
%% %
%% \newtext{In addition to turning nodes not participating in errors into
%% dot nodes, our slicing algorithm uses two tidying functions
%% $\MEMflattenSYMB$ and $\MEMseqflattenSYMB$.}
%% %
%% The flattening function $\MEMflattenSYMB$ flattens sequences of parts
%% ($\METApart$).
%% %(We omit the definition of $\MEMseqflattenSYMB$ due to space
%% %limit.  It merely ``cleans'' the dot terms occurring in a
%% %sequence of structure declarations.)
%% %
%% %The function $\MEMflattenSYMB$ flattens nested dot terms.
%% %
%% For example, flattening
%% \inexamplebody{\lslice..1..\lslice..()..\rslice..\rslice}
%% results in
%% \inexamplebody{\lslice..1..()..\rslice}.
%% %
%% Not all nested dot terms are flattened:
%% in order not to mix up bindings in a slice, we do not let
%% declarations be $\METAepart$'s (expression term as
%% opposed to a declaration) and only allow $\METAepart$'s to be flattened,
%% so that declarations cannot escape the scoping of
%% dot terms.
%% For example, we do not flatten
%% \inexamplebody{\lslice..val x = ()..\lslice..val x = 1..\rslice..x + 1..\rslice}
%% to
%% \inexamplebody{\lslice..val x = ()..val x = 1..x + 1..\rslice}
%% because they have different semantics: the first slice is not
%% typable but the second is.
%% %
%% %% First let us define some syntactic forms:
%% %% \begin{center}
%% %% \begin{tabular}{ l l l l l }
%% %% %$\METAslsome$ & $\in$ & $\SETslsome$ & $::=$ & $\METAslpart\mid\METAlabexp\mid\METAlabtype$\\
%% %% $\METAspat$   & $\in$ & $\SETspat$   & $::=$ & $\METApat\mid\METAatpat$\\
%% %% $\METAslseq$  & $\in$ & $\SETslseq$  & $::=$ & $\METAtypecon$
%% %% \end{tabular}
%% %% \end{center}
%% %
%% %Our first flattening function $\MEMflattenSYMB$ is for non sequential terms:
%% %% \begin{center}
%% %% \begin{\sizeintables}
%% %%   \begin{tabular}{ l l l }
%% %%     $\MEMflatten{\emptyset}$
%% %%     & $=$
%% %%     & $\emptyset$\\
%% %%     %\noindent
%% %%     $\MEMflatten{\MEMconcat{\mytuple{\METApart}}{\METAtermseq}}$
%% %%     & &\\
%% %%     \multicolumn{3}{l}{$=$
%% %%       $\left\{
%% %%       \begin{array}{ l l }
%% %%         \MEMconcat{\METAepartseq}{\MEMflatten{\METAtermseq}},
%% %%         &
%% %%         \mbox{ if }\METApart = \LABdots{\METAepartseq}
%% %%         \\
%% %%         %% \MEMflatten{\MEMconcat{\mytuple{x}}{\METAtermseq}}
%% %%         %% &
%% %%         %% \mbox{ if }\METApart = \LABlabexp{\METAexp}{\METAlab}
%% %%         %% \mbox{ or }\LABlabexp{\METAtype}{\METAlab}
%% %%         %% \\
%% %%         \MEMconcat{\mytuple{\METApart}}{\MEMflatten{\METAtermseq}},
%% %%         &
%% %%         \mbox{ otherwise}
%% %%       \end{array}
%% %%       \right.$
%% %%     }
%% %%   \end{tabular}
%% %% \end{\sizeintables}
%% %% \end{center}
%% %
%% %
%% \newtext{
%% Let $\MEMflattenSYMB$ be defined as follows
%% (where $x$ can be any of $\CONS{e}$, $\CONS{p}$, $\CONS{s}$, $\CONS{d}$):}
%% % where
%% % $\LABdots{\METAepartseq}$ can be any of
%% % the ``dot'' terms defined in Fig.~\ref{fig:dotterms}:}
%% \begin{center}
%% \begin{\sizeintables}
%%   \begin{tabular}{ l l l }
%%     $\MEMflatten{\mytuple{}}$
%%     & $=$
%%     & $\mytuple{}$
%%     \\
%%   \end{tabular}
%%   \hspace{0.2in}
%%   \begin{tabular}{ l l l }
%%     $\MEMflatten{\MEMconcat{\mytuple{\METApart}}{\METAtermseq}}$
%%     & $=$
%%     & $\left\{
%%     \begin{array}{ l l }
%%       \MEMconcat{\METAepartseq}{\MEMflatten{\METAtermseq}},
%%       &
%%       \mbox{if }\METApart=\CONSdotsx{\METAepartseq}
%%       \\
%%       \MEMconcat{\mytuple{\METApart}}{\MEMflatten{\METAtermseq}},
%%       &
%%       \mbox{otherwise}
%%     \end{array}
%%     \right.$
%%   \end{tabular}
%% \end{\sizeintables}
%% \end{center}

%% \hidden{
%% \begin{center}
%% \begin{\sizeintables}
%% \begin{tabular}{ l l l }
%%   $\MEMpatflatten{\emptyset}$
%%   & $=$
%%   & $\emptyset$\\
%%   %\noindent
%%   $\MEMpatflatten{\MEMconcat{\mytuple{\METApat}}{\METApatseq}}$
%%   & $=$
%%   & $\left\{
%%   \begin{array}{ll}
%%     \MEMconcat{\METApatseq'}{\MEMpatflatten{\METApatseq}},
%%     &
%%     \mbox{if }\METApat = \LABdots{\METApatseq'}
%%     \\
%%     %% \MEMpatflatten{\MEMconcat{\mytuple{\METApat}}{\METApatseq}}
%%     %% &
%%     %% \mbox{ if }\METApat = \LABlabpat{\METApat}{\METAlab}
%%     %% \\
%%     \MEMconcat{\mytuple{\METApat}}{\MEMpatflatten{\METApatseq}},
%%     &
%%     \mbox{otherwise}
%%   \end{array}
%%   \right.$
%% \end{tabular}
%% \end{\sizeintables}
%% \end{center}
%% }

%% %% %Our second flattening function $\MEMseqflattenSYMB$ is for sequential terms:
%% %% \begin{center}
%% %% \begin{tabular}{ l l l }
%% %% $\MEMseqflatten{\emptyset}$
%% %% & $=$
%% %% & $\emptyset$
%% %% \\
%% %% %\noindent
%% %% $\MEMseqflatten{\MEMconcat{\mytuple{\METAstrdec}}{\METAstrdecseq}}$
%% %% & $=$
%% %% & $\left\{
%% %%   \begin{array}{ll}
%% %%     \MEMseqflatten{\MEMconcat{\LABdots{\MEMconcat{\METAepartseq}{\METAepartseq'}}}{\METAstrdecseq'}}
%% %%     &
%% %%     \mbox{ if }\METAstrdec = \LABdots{\METAepartseq}
%% %%     \\
%% %%     &
%% %%     \mbox{ and }\METAstrdecseq = \MEMconcat{\mytuple{\LABdots{\METAepartseq'}}}{\METAstrdecseq'}
%% %%     \\
%% %%     \MEMseqflatten{\METAstrdecseq}
%% %%     &
%% %%     \mbox{ if }\METAstrdec = \LABdots{\emptyset}
%% %%     \\
%% %%     \MEMconcat{\mytuple{\METAstrdec}}{\MEMseqflatten{\METAstrdecseq}}
%% %%     &
%% %%     \mbox{ otherwise}
%% %%   \end{array}
%% %% \right.$
%% %% %% \\
%% %% %% & & where $\METAstrdec = \LABdots{\METAslpartseq}$
%% %% %% \\
%% %% %% $\MEMseqflatten{\MEMconcat{\mytuple{\METAstrdec}}{\METAstrdecseq}}$
%% %% %% & $=$
%% %% %% & $\MEMconcat{\mytuple{\METAstrdec}}{\MEMseqflatten{\METAstrdecseq}}$
%% %% %% \\
%% %% %% & & where $\METAstrdec \not = \LABdots{\METAslpartseq}$
%% %% \end{tabular}
%% %% \end{center}

%% The function $\MEMseqflattenSYMB$ tidies sequences of
%% structure declarations ($\METAstrdec$) when slicing structure
%% expressions:

%% \begin{center}
%% \begin{\sizeintables}
%%   \begin{tabular}{ l l l }
%%     $\MEMseqflatten{\mytuple{}}=\mytuple{}$
%%     &&
%%     \\

%%     $\MEMseqflatten{\MEMconcat{\mytuple{\CONSdotsstrdec{\METAepartseq},\CONSdotsstrdec{\METAtermseq}}}{\METAstrdecseq}}$
%%     & $=$
%%     & $\MEMseqflatten{\MEMconcat{\mytuple{\CONSdotsstrdec{\MEMconcat{\METAepartseq}{\METAtermseq}}}}{\METAstrdecseq}}$
%%     \\
%%     %% \multicolumn{3}{l}{\hspace{0.1in}
%%     %%   if $\METAstrdec_1=\LABdots{\METAepartseq}$
%%     %%   and $\METAstrdec_2=\LABdots{\METAepartseq'}$
%%     %% }
%%     %% \\

%%     $\MEMseqflatten{\MEMconcat{\mytuple{\CONSdotsstrdec{\emptyset}}}{\METAstrdecseq}}$
%%     & $=$
%%     & $\MEMseqflatten{\METAstrdecseq}$,
%%     if $\METAstrdecseq$ not of the form $\MEMconcat{\CONSdotsstrdec{\METAepartseq}}{\METAstrdecseq'}$
%%     \\

%%     $\MEMseqflatten{\MEMconcat{\mytuple{\METAstrdec}}{\METAstrdecseq}}$
%%     & $=$
%%     & $\MEMconcat{\mytuple{\METAstrdec}}{\MEMseqflatten{\METAstrdecseq}}$,
%%     if none of the above applies
%%   \end{tabular}
%% \end{\sizeintables}
%% \end{center}

%% %% \begin{center}
%% %% \begin{\sizeintables}
%% %%   \begin{tabular}{ l l l }
%% %%     $\MEMseqflatten{\mytuple{}}$
%% %%     & $=$
%% %%     & $\mytuple{}$
%% %%     \\

%% %%     $\MEMseqflatten{\MEMconcat{\mytuple{\METAstrdec}}{\METAstrdecseq}}$
%% %%     & &
%% %%     \\
%% %%     \multicolumn{3}{l}{$=$
%% %%       $\left\{
%% %%       \begin{array}{l}
%% %%         \MEMseqflatten{\MEMconcat{\mytuple{\LABdots{\MEMconcat{\METAepartseq}{\METAepartseq'}}}}{\METAstrdecseq'}},
%% %%         \\
%% %%         \hspace*{0.1in}\mbox{if }\METAstrdec=\LABdots{\METAepartseq}
%% %%         \mbox{ and }\METAstrdecseq=\MEMconcat{\mytuple{\LABdots{\METAepartseq'}}}{\METAstrdecseq'}
%% %%         \\
%% %%         \MEMseqflatten{\METAstrdecseq},
%% %%         \mbox{if }\METAstrdec=\LABdots{\emptyset}
%% %%         \\
%% %%         \MEMconcat{\mytuple{\METAstrdec}}{\MEMseqflatten{\METAstrdecseq}},
%% %%         \mbox{otherwise}
%% %%       \end{array}
%% %%       \right.$
%% %%     }
%% %%   \end{tabular}
%% %% \end{\sizeintables}
%% %% \end{center}
%% \fi



%% \ifthesis
%% \intitle{Algorithm.}
%% %
%% %% Let the function $\MEMinseqtooutseqSYMB$ (used to slice structure
%% %% expressions) transform an internal sequence of structure declarations
%% %% into an external one.
%% %
%% \begin{\myfigure}[t]
%%   \input{included/slicerOpenFun}
%%   \caption{Slicing algorithm}
%%   \label{fig:slicingAlgo}
%% \end{\myfigure}
%% %
%% Our slicing algorithm can be presented in a simple fashion if our syntax
%% forms defined in Fig.~\ref{fig:syntaxOpen} and Fig.~\ref{fig:dotterms}
%% are regarded as abstract syntax trees.  In such a tree $\METAtree$, leaves are
%% identifiers $\METAgenid$ and otherwise a node is labelled by a node kind
%% $\METAnode$ and a label $\METAlab$ (denoted
%% $\MEMconstree{\METAnode}{\METAlab}{\mytuple{\METAtree_1,\dots,\METAtree_n}}$).
%% Using this notation, we define our slicing function $\MEMsliceSYMB$ in
%% Fig.~\ref{fig:slicingAlgo}.

%% %% \begin{\myfigure}[!th]
%% %%   \input{included/slicerOpen2}
%% %%   \caption{Slicing algorithm}
%% %%   \label{fig:slicingAlgo}
%% %% \end{\myfigure}

%% %\input{included/slicerOpen}
%% \fi


\subsubsection{Remark about the constraint generation rules for dot terms}
%
Fig.~\ref{fig:dotterms} presents constraint generation rules for the
different dot terms of our syntax.  Rules~$\MEMgencgrulear$,
$\MEMgencgruleat$, and $\MEMgencgruleau$ all wrap the environments
generated for the $\METAterm$s wrapped into the dot constructors,
into a local environment not visible from the outside of the form
$\csbind{\METAcsenv}$.  Rule~$\MEMgencgruleas$ for dot patterns stands
out by not generating an environment of the form
$\csbind{\METAcsenv}$.  As of matter of fact a dot pattern constructor
has a different meaning as the other dot constructors.  Such a dot
pattern term means that information has been sliced away but that the
remaining information might still be in a pattern at a binding
position.  Such a pattern dot term does not define a local scope as
the other dot terms do.



\subsubsection{Alternative definition of the labelled external syntax}
%



We now provide an alternative generic definition of the external
labelled syntax presented in Fig.~\ref{fig:syntaxOpen}.  This
definition helps defining our slicing algorithm in a compact way.
First, Fig.~\ref{fig:ast} defines our labelled abstract syntax trees.
%
A node in a tree $\METAtree$ can either be a labelled node of the form
$\CONStree{\METAnode}{\METAlab}{\METAtreeseq}$, an unlabelled ``dot''
node of the form $\CONStreedot{\METAdot}{\METAtreeseq}$, or a leaf of
the form $\METAgenid$.

\begin{figure}[t]
  \begin{\sizeintables}
    \begin{tabular}[t]{lllrl}
      $\METAsyntclass$
      & $\in$
      & $\SETsyntclass$
      & $::=$
      & $\CONSastLabtypename
      \mid\CONSastLabdcon
      \mid\CONSastTy
      \mid\CONSastConbind
      \mid\CONSastDatname
      \mid\CONSastDec
      \mid\CONSastAtexp
      \mid\CONSastExp
      \mid\CONSastAtpat
      \mid\CONSastPat
      \mid\CONSastStrdec
      \mid\CONSastStrexp$
      \\

      $\METAprod$
      & $\in$
      & $\SETprod$
      & $::=$
      & $\CONSastTyarr\mid\CONSastTycon
      \mid\CONSastConbindof\mid\CONSastDatnamecon
      \mid\CONSastDecrec\mid\CONSastDecdat\mid\CONSastDecopn$
      \\
      &&& $\mid$
      & $\CONSastAtexplet\mid\CONSastExpfn
      \mid\CONSastStrdecdec\mid\CONSastStrdecstr
      \mid\CONSastStrexpst
      \mid\CONSastId\mid\CONSastApp\mid\CONSastSeq$
      \\

      $\METAdot$
      & $\in$
      & $\SETdot$
      & $::=$
      & $\CONSdotE
      \mid\CONSdotP
      \mid\CONSdotD\mid\CONSdotS$
      \\

      $\METAnode$
      & $\in$
      & $\SETnode$
      & $::=$
      & $\CONSnode{\METAsyntclass}{\METAprod}$
      \\

      $\METAtree$
      & $\in$
      & $\SETtree$
      & $::=$
      & $\CONStree{\METAnode}{\METAlab}{\METAtreeseq}
      \mid\CONStreedot{\METAdot}{\METAtreeseq}
      \mid\METAgenid$
    \end{tabular}
  \end{\sizeintables}
\caption{Labelled abstract syntax trees}
\label{fig:ast}
\end{figure}



Fig.~\ref{fig:termstotrees} defines the function $\MEMtogenSYMB$ which
associates a $\METAtree$ with each $\METAterm$ (defined in
Fig.~\ref{fig:syntaxOpen}).  We also define $\MEMtogenSYMB$ on
sequences of $\METAterm$s.
%% Let $\MEMfromgenSYMB$
%% ($\MEMtogenSYMB^{-1}$) be the partial function that associate a
%% $\METAterm$ to a $\METAtree$.



%%% TODO: Fix this figure.


\begin{\myfigure}[!t]
  \begin{\sizeintables}
    \begin{tabular}{llll}
      %% \multicolumn{4}{l}{
      %%   \mytitle{Labelled type constructors}
      %% }
      %% \\
      & $\MEMtogen{\LABlabgen{\METAtypename}{\METAlab}}$
      & $=$
      & $\CONStree{\CONSnode{\CONSastLabtypename}{\CONSastId}}{\METAlab}{\mytuple{\METAtypename}}$
      \vspace*{0.05in}
      \\

      %% \multicolumn{4}{l}{
      %%   \mytitle{Labelled datatype constructors}
      %% }
      %% \\
      & $\MEMtogen{\LABlabgen{\METAdcon}{\METAlab}}$
      & $=$
      & $\CONStree{\CONSnode{\CONSastLabdcon}{\CONSastId}}{\METAlab}{\mytuple{\METAdcon}}$
      \vspace*{0.05in}
      \\

      %% \multicolumn{4}{l}{
      %%   \mytitle{Types}
      %% }
      %% \\
      & $\MEMtogen{\LABtypeTypevar{\METAtypevar}{\METAlab}}$
      & $=$
      & $\CONStree{\CONSnode{\CONSastTy}{\CONSastId}}{\METAlab}{\mytuple{\METAtypevar}}$
      \\

      & $\MEMtogen{\LABtypeArrow{\METAtype_1}{\METAtype_2}{\METAlab}}$
      & $=$
      & $\CONStree{\CONSnode{\CONSastTy}{\CONSastTyarr}}{\METAlab}{\mytuple{\MEMtogen{\METAtype_1},\MEMtogen{\METAtype_2}}}$
      \\

      & $\MEMtogen{\LABsptypeTypename{\METAtype}{\METAlabtypename}{\METAlab}}$
      & $=$
      & $\CONStree{\CONSnode{\CONSastTy}{\CONSastTycon}}{\METAlab}{\mytuple{\MEMtogen{\METAtype},\MEMtogen{\METAlabtypename}}}$
      \vspace*{0.05in}
      \\

      %% \multicolumn{4}{l}{
      %%   \mytitle{Constructor bindings}
      %% }
      %% \\
      & $\MEMtogen{\LABtypeconId{\METAdcon}{\METAlab}}$
      & $=$
      & $\CONStree{\CONSnode{\CONSastConbind}{\CONSastId}}{\METAlab}{\mytuple{\METAdcon}}$
      \\

      & $\MEMtogen{\LABtypeconCompp{\METAdcon}{\METAlab_1}{\METAtype}{\METAlab}}$
      & $=$
      & $\CONStree{\CONSnode{\CONSastConbind}{\CONSastConbindof}}{\METAlab}{\mytuple{\METAdcon,\MEMtogen{\METAtype}}}$
      \vspace*{0.05in}
      \\

      %% \multicolumn{4}{l}{
      %%   \mytitle{Datatype names}
      %% }
      %% \\
      & $\MEMtogen{\LABdatnamep{\METAtypevar}{\METAtypename}{\METAlab}}$
      & $=$
      & $\CONStree{\CONSnode{\CONSastDatname}{\CONSastDatnamecon}}{\METAlab}{\mytuple{\METAtypevar,\METAtypename}}$
      \vspace*{0.05in}
      \\

      %% \multicolumn{4}{l}{
      %%   \mytitle{Declarations}
      %% }
      %% \\
      & $\MEMtogen{\LABdecVal{\LABvalbind{\METApat}{\METAexp}{\METAlab}}}$
      & $=$
      & $\CONStree{\CONSnode{\CONSastDec}{\CONSastDecrec}}{\METAlab}{\mytuple{\MEMtogen{\METApat},\MEMtogen{\METAexp}}}$
      \\

      & $\MEMtogen{\LABdecDat{\LABspdatbind{\METAdatname}{\METAtypecon}{\METAlab}}}$
      & $=$
      & $\CONStree{\CONSnode{\CONSastDec}{\CONSastDecdat}}{\METAlab}{\mytuple{\MEMtogen{\METAdatname},\MEMtogen{\METAtypecon}}}$
      \\

      & $\MEMtogen{\LABdecOpen{\METAstrid}{\METAlab}}$
      & $=$
      & $\CONStree{\CONSnode{\CONSastDec}{\CONSastDecopn}}{\METAlab}{\mytuple{\METAstrid}}$
      \vspace*{0.05in}
      \\

      %% \multicolumn{4}{l}{
      %%   \mytitle{Expressions}
      %% }
      %% \\
      & $\MEMtogen{\LABexpId{\METAid}{\METAlab}}$
      & $=$
      & $\CONStree{\CONSnode{\CONSastAtexp}{\CONSastId}}{\METAlab}{\mytuple{\METAid}}$
      \\

      & $\MEMtogen{\LABexpLet{\METAdec}{\METAexp}{\METAlab}}$
      & $=$
      & $\CONStree{\CONSnode{\CONSastAtexp}{\CONSastAtexplet}}{\METAlab}{\mytuple{\MEMtogen{\METAdec},\MEMtogen{\METAexp}}}$
      \\

      & $\MEMtogen{\LABexpFnp{\LABmrule{\METApat}{\METAexp}{\METAlab}}{\METAlab}}$
      & $=$
      & $\CONStree{\CONSnode{\CONSastExp}{\CONSastExpfn}}{\METAlab}{\mytuple{\MEMtogen{\METApat},\MEMtogen{\METAexp}}}$
      \\

      & $\MEMtogen{\LABexpApp{\METAexp}{\METAatexp}{\METAlab}}$
      & $=$
      & $\CONStree{\CONSnode{\CONSastExp}{\CONSastApp}}{\METAlab}{\mytuple{\MEMtogen{\METAexp},\MEMtogen{\METAatexp}}}$
      \vspace*{0.05in}
      \\

      %% \multicolumn{4}{l}{
      %%   \mytitle{Patterns}
      %% }
      %% \\
      & $\MEMtogen{\LABpatId{\METAid}{\METAlab}}$
      & $=$
      & $\CONStree{\CONSnode{\CONSastAtpat}{\CONSastId}}{\METAlab}{\mytuple{\METAid}}$
      \\

      & $\MEMtogen{\LABpatAppSp{\METAlabdcon}{\METAatpat}{\METAlab}}$
      & $=$
      & $\CONStree{\CONSnode{\CONSastPat}{\CONSastApp}}{\METAlab}{\mytuple{\MEMtogen{\METAlabdcon},\MEMtogen{\METAatpat}}}$
      \vspace*{0.05in}
      \\

      %% \multicolumn{4}{l}{
      %%   \mytitle{Structure declarations}
      %% }
      %% \\
      & $\MEMtogen{\LABstrdecStr{\LABstrbindBas{\METAstrid}{\METAstrexp}{\METAlab}}}$
      & $=$
      & $\CONStree{\CONSnode{\CONSastStrdec}{\CONSastStrdecstr}}{\METAlab}{\mytuple{\METAstrid,\MEMtogen{\METAstrexp}}}$
      \vspace*{0.05in}
      \\

      %% \multicolumn{4}{l}{
      %%   \mytitle{Structure expressions}
      %% }
      %% \\
      & $\MEMtogen{\LABstrexpId{\METAstrid}{\METAlab}}$
      & $=$
      & $\CONStree{\CONSnode{\CONSastStrexp}{\CONSastId}}{\METAlab}{\mytuple{\METAstrid}}$
      \\

      & $\MEMtogen{\LABstrexpMul{\METAstrdec_1}{\METAstrdec_n}{\METAlab}}$
      & $=$
      & $\CONStree
      {\CONSnode{\CONSastStrexp}{\CONSastStrexpst}}
      {\METAlab}
      {\MEMtogen{\mytuple{\METAstrdec_1,\dots,\METAstrdec_n}}}$
      \vspace*{0.05in}
      \\

      %% \multicolumn{4}{l}{
      %%   \mytitle{Term sequences}
      %% }
      %% \\
      & $\MEMtogen{\mytuple{\METAterm_1,\dots,\METAterm_n}}$
      & $=$
      & $\mytuple{\MEMtogen{\METAterm_1},\dots,\MEMtogen{\METAterm_n}}$
      \vspace*{0.05in}
      \\

      %% \multicolumn{4}{l}{
      %%   \mytitle{Dot terms}
      %% }
      %% \\
      & $\MEMtogen{\LABtypeDots{\METAtermseq}}$
      & $=$
      & $\CONStreedot{\CONSdotE}{\MEMtogen{\METAtermseq}}$
      \\

      & $\MEMtogen{\LABdecDots{\METAtermseq}}$
      & $=$
      & $\CONStreedot{\CONSdotD}{\MEMtogen{\METAtermseq}}$
      \\

      & $\MEMtogen{\LABpatDots{\METApatseq}}$
      & $=$
      & $\CONStreedot{\CONSdotP}{\MEMtogen{\METApatseq}}$
      \\

      & $\MEMtogen{\LABstrexpDots{\METAtermseq}}$
      & $=$
      & $\CONStreedot{\CONSdotS}{\MEMtogen{\METAtermseq}}$

    \end{tabular}
  \end{\sizeintables}
  \caption{From terms to trees}
  \label{fig:termstotrees}
\end{\myfigure}


The function $\MEMgetdotSYMB$ generates dot markers (terms in
$\SETdot$) from nodes as follows:
\begin{center}
  \begin{\sizeintablesp}
    \begin{tabular}[t]{lll}
      $\MEMgetdot{\CONSnode{\CONSastLabtypename}{\METAprod}}$
      & $=$
      & $\CONSdotE$
      \\

      $\MEMgetdot{\CONSnode{\CONSastLabdcon}{\METAprod}}$
      & $=$
      & $\CONSdotE$
      \\

      $\MEMgetdot{\CONSnode{\CONSastTy}{\METAprod}}$
      & $=$
      & $\CONSdotE$
      \\

      $\MEMgetdot{\CONSnode{\CONSastConbind}{\METAprod}}$
      & $=$
      & $\CONSdotE$
      \\

      $\MEMgetdot{\CONSnode{\CONSastDatname}{\METAprod}}$
      & $=$
      & $\CONSdotE$
      \\

      $\MEMgetdot{\CONSnode{\CONSastDec}{\METAprod}}$
      & $=$
      & $\CONSdotD$
      \\
    \end{tabular}
    \hspace{0.3in}
    \begin{tabular}[t]{lll}
      $\MEMgetdot{\CONSnode{\CONSastAtexp}{\METAprod}}$
      & $=$
      & $\CONSdotE$
      \\

      $\MEMgetdot{\CONSnode{\CONSastExp}{\METAprod}}$
      & $=$
      & $\CONSdotE$
      \\

      $\MEMgetdot{\CONSnode{\CONSastAtpat}{\METAprod}}$
      & $=$
      & $\CONSdotP$
      \\

      $\MEMgetdot{\CONSnode{\CONSastPat}{\METAprod}}$
      & $=$
      & $\CONSdotP$
      \\

      $\MEMgetdot{\CONSnode{\CONSastStrdec}{\METAprod}}$
      & $=$
      & $\CONSdotD$
      \\

      $\MEMgetdot{\CONSnode{\CONSastStrexp}{\METAprod}}$
      & $=$
      & $\CONSdotS$
    \end{tabular}
  \end{\sizeintablesp}
\end{center}

This function is, among other things, used by rule~$\slicingrulea$ of
our slicing algorithm defined below in Fig.~\ref{fig:newslicingalgo}
to generate dot nodes from labelled nodes.



\subsubsection{Tidying}

In addition to turning nodes not participating in type errors into dot
nodes, our slicing algorithm uses two tidying functions
$\MEMflattenSYMB$ and $\MEMseqflattenSYMB$.
%
The flattening function $\MEMflattenSYMB$ flattens sequences of terms
($\METAterm$).  For example, flattening
\inexamplebody{\lslice..1..\lslice..()..\rslice..\rslice} results in
\inexamplebody{\lslice..1..()..\rslice}.
%
Not all nested dot terms are flattened.  In order not to mix up
bindings in a slice, we do not let declarations escape dot terms.
%
For example, we do not flatten
\inexamplebody{\lslice..val x = false..\lslice..val x = 1..\rslice..x + 1..\rslice}
to
\inexamplebody{\lslice..val x = false..val x = 1..x + 1..\rslice}
because they have different semantics.  The first slice is not
typable but the second is.
In the first slice \inexamplebody{x}'s last occurrence is bound to
\inexamplebody{x}'s first occurrence while in the second slice
\inexamplebody{x}'s last occurrence is bound to \inexamplebody{x}'s
second occurrence.

%% Before providing the definitions of our tidying functions let us
%% mention that in Fig.~\ref{fig:dotterms}, neither $\SETdatname$ nor
%% $\SETtypecon$ are defined as subsets of $\SETpart$.  As a matter of
%% fact, due to the way our constraints are initially generated, and
%% mainly the way our constraints are labelled at initial constraint
%% generation, non dot $\METAdatname$ and $\METAtypecon$ terms cannot be
%% ``parts'' (in $\SETpart$), they cannot occur as children of dot terms.
%% A $\METAdatname$ (and similarly for a $\METAtypecon$) is either part
%% of a datatype declaration or is completely sliced away in our system.
%% Note that logically speaking, we should allow $\METAdatname$'s and
%% $\METAtypecon$'s to be $\METApart$'s (but not $\METAepart$'s).
%% %
%% Then, we need a mechanism to distinguish between
%% declarations and non-declarations, similar to the distinction between
%% $\SETepart$ and $\SETpart\setminus\SETepart$.
Let us define the three following predicates used to check trees'
classes:
\begin{center}
  \begin{\sizeintablesp}
    \begin{tabular}{lll}
      $\MEMisclass{\METAtree}{\{\METAsyntclass\}\cup\METAsyntclassset}$
      & $\iff$
      & $\METAtree=\CONStree{\CONSnode{\METAsyntclass}{\METAprod}}{\METAlab}{\METAtreeseq}$
      \\

      $\MEMisdec{\METAtree}$
      & $\iff$
      & $\MEMisclass{\METAtree}{\{\CONSastDec,\CONSastStrdec,\CONSastDatname,\CONSastConbind\}}$
      \\

      $\MEMispat{\METAtree}$
      & $\iff$
      & $\MEMisclass{\METAtree}{\{\CONSastAtpat,\CONSastPat\}}$
    \end{tabular}
  \end{\sizeintablesp}
\end{center}
The classes $\CONSastDec$, $\CONSastStrdec$, $\CONSastDatname$, and
$\CONSastConbind$ are associated (using the $\MEMtogenSYMB$ function)
with terms for which our initial constraint generation algorithm
generates binders.

Let us define our flattening function $\MEMflattenSYMB$ as follows:
\begin{center}
\begin{\sizeintablesp}
  \begin{tabular}{ l l l }
    $\MEMflatten{\mytuple{}}$
    & $=$
    & $\mytuple{}$
    \\
    $\MEMflatten{\MEMconcat{\mytuple{\METAtree}}{\METAtreeseq}}$
    & $=$
    & $\left\{
    \begin{array}{l}
      \MEMconcat{\mytuple{\METAtree_1,\dots,\METAtree_n}}{\MEMflatten{\METAtreeseq}},
      \\
      \hspace{0.1in}\mbox{if }\METAtree=\CONStreedot{\METAdot}{\mytuple{\METAtree_1,\dots,\METAtree_n}}
      \\
      \hspace{0.1in}\mbox{and }(\forallexp{i\in\{1,\dots,n\}}{\neg\MEMisdec{\METAtree_i}}
      \mbox{ or }\METAtreeseq=\mytuple{})
      \\
      \MEMconcat{\mytuple{\METAtree}}{\MEMflatten{\METAtreeseq}},
      \mbox{otherwise}
    \end{array}
    \right.$
  \end{tabular}
\end{\sizeintablesp}
\end{center}

%% We slightly altered our flattening function from the one defined in
%% Sec.~\ref{sec:slicing}, by adding the condition ``or
%% $\METAtreeseq=\mytuple{}$''.

%% As a matter of fact,

The condition
``$\forallexp{i\in\{1,\dots,n\}}{\neg\MEMisdec{\METAtree_i}}$''
ensures that bindings are not mixed up as explained above.  However,
flattening the last dot term (if it actually is a dot term) cannot mix
up the bindings because there is no identifier left to bind.
%
Therefore, flattening
\inexamplebody{\lslice..val x = 1..\lslice..val x = true..\rslice..\rslice}
would lead to
\inexamplebody{\lslice..val x = 1..val x = true..\rslice}.
%% We do not believe that this is an improvement of the function because
We however have not yet found a concrete example where this situation
occurs.


We also define the function $\MEMseqflattenSYMB$ to tidy sequences of
declarations in structure expressions as follows:
\begin{center}
\begin{\sizeintablesp}
  \begin{tabular}{ l }
    $\MEMseqflatten{\mytuple{}}$
    $=$
    $\mytuple{}$
    \\

    $\MEMseqflatten{\MEMconcat{\mytuple{\CONStreedot{\CONSdotD}{\METAtreeseq_1},\CONStreedot{\CONSdotD}{\METAtreeseq_2}}}{\METAtreeseq}}$
    \\
    \hspace*{0.2in}$=$
    $\MEMseqflatten{\MEMconcat{\mytuple{\CONStreedot{\CONSdotD}{\MEMconcat{\METAtreeseq_1}{\METAtreeseq_2}}}}{\METAtreeseq}}$,
    if $\forallexp{\METAtree\in\MEMran{\METAtreeseq_1}}{\neg\MEMisdec{\METAtree}}$
    \\

    $\MEMseqflatten{\MEMconcat{\mytuple{\CONStreedot{\CONSdotD}{\emptyset}}}{\METAtreeseq}}$
    \\
    \hspace*{0.2in}$=$
    $\MEMseqflatten{\METAtreeseq}$,
    if none of the above applies
    \\

    $\MEMseqflatten{\MEMconcat{\mytuple{\METAtree}}{\METAtreeseq}}$
    \\
    \hspace*{0.2in}$=$
    $\MEMconcat{\mytuple{\METAtree}}{\MEMseqflatten{\METAtreeseq}}$,
    if none of the above applies
  \end{tabular}
\end{\sizeintablesp}
\end{center}




\subsubsection{Algorithm}


Fig.~\ref{fig:newslicingalgo} formally defines
%
\index{slicing algorithm}%
%
our slicing algorithm.
Note that rule~$\slicingrulej$ generates the dot marker~$\CONSdotE$,
but we could have used any of the terms in $\SETdot$ because the
flattening function $\MEMflattenSYMB$ discards such terms.  The
functions $\MEMslicingaSYMB$ and $\MEMslicingbSYMB$ are defined on
trees but also on sequences of trees in rules~$\slicingruleg$
and~$\slicingruleh$.  Finally, let
$\MEMslicing{\METAstrdec}{\METAlabset}$ be
$\MEMslicing{\MEMtogen{\METAstrdec}}{\METAlabset}$.

\begin{\myfigure}[!t]
  \begin{\sizeintables}
    \begin{tabular}{llll}
      $\slicingrulea$
      & $\MEMslicing{\CONStree{\METAnode}{\METAlab}{\METAtreeseq}}{\METAlabset}$
      & $=$
      & $\left\{
      \begin{array}{ll}
        \CONStree{\METAnode}{\METAlab}{\MEMslicinga{\METAtreeseq}{\METAlabset}},
        &
        \mbox{if }\METAlab\in\METAlabset
        \mbox{ and }\MEMgetdot{\METAnode}\not=\CONSdotS
        %\mbox{ or }\MEMispat{\MEMslicinga{\afunc{\METAtreeseq}{0}}{\METAlabset}}
        \\
        \CONStree{\METAnode}{\METAlab}{\MEMseqflatten{\MEMslicinga{\METAtreeseq}{\METAlabset}}},
        &
        \mbox{if }\METAlab\in\METAlabset
        \mbox{ and }\MEMgetdot{\METAnode}=\CONSdotS
        \\
        \CONStreedot{\MEMgetdot{\METAnode}}{\MEMflatten{\MEMslicingb{\METAtreeseq}{\METAlabset}}},
        &
        \mbox{otherwise}
      \end{array}
      \right.$
    \end{tabular}

    \begin{tabular}{llll}
      $\slicingruleb$
      & $\MEMslicinga{\CONStreedot{\METAdot}{\mytuple{\METAtree_1,\dots,\METAtree_n}}}{\METAlabset}$
      & $=$
      & $\CONStreedot{\METAdot}{\MEMflatten{\mytuple{\MEMslicingb{\METAtree_1}{\METAlabset},\dots,\MEMslicingb{\METAtree_n}{\METAlabset}}}}$
      \\

      $\slicingruled$
      & $\MEMslicingb{\CONStreedot{\METAdot}{\mytuple{\METAtree_1,\dots,\METAtree_n}}}{\METAlabset}$
      & $=$
      & $\CONStreedot{\METAdot}{\MEMflatten{\mytuple{\MEMslicingb{\METAtree_1}{\METAlabset},\dots,\MEMslicingb{\METAtree_n}{\METAlabset}}}}$
      \\

      $\slicingrulee$
      & $\MEMslicinga{\CONStree{\METAnode}{\METAlab}{\METAtreeseq}}{\METAlabset}$
      & $=$
      & $\MEMslicing{\CONStree{\METAnode}{\METAlab}{\METAtreeseq}}{\METAlabset}$
      \\

      $\slicingrulef$
      & $\MEMslicingb{\CONStree{\METAnode}{\METAlab}{\METAtreeseq}}{\METAlabset}$
      & $=$
      & $\MEMslicing{\CONStree{\METAnode}{\METAlab}{\METAtreeseq}}{\METAlabset}$
      \\

      $\slicingruleg$
      & $\MEMslicinga{\mytuple{\METAtree_1,\dots,\METAtree_n}}{\METAlabset}$
      & $=$
      & $\mytuple{\MEMslicinga{\METAtree_1}{\METAlabset},\dots,\MEMslicinga{\METAtree_n}{\METAlabset}}$
      \\

      $\slicingruleh$
      & $\MEMslicingb{\mytuple{\METAtree_1,\dots,\METAtree_n}}{\METAlabset}$
      & $=$
      & $\mytuple{\MEMslicingb{\METAtree_1}{\METAlabset},\dots,\MEMslicingb{\METAtree_n}{\METAlabset}}$
      \\
    %% \end{tabular}
    %% \hspace{0.0in}
    %% \begin{tabular}{llll}

      $\slicingrulei$
      & $\MEMslicinga{\METAgenid}{\METAlabset}$
      & $=$
      & $\METAgenid$
      \\

      $\slicingrulej$
      & $\MEMslicingb{\METAgenid}{\METAlabset}$
      & $=$
      & $\CONStreedot{\CONSdotE}{\mytuple{}}$
    \end{tabular}
  \end{\sizeintables}
  \caption{Slicing algorithm}
  \label{fig:newslicingalgo}
\end{\myfigure}

%% We can then redefine our function $\MEMsliceSYMB$ as follows:
%% $$
%% \begin{array}{ l }
%%   \MEMslice{\CONStree{\METAnode}{\METAlab}{\METAtreeseq}}{\METAlabset}
%%   =
%%   \CONStree{\METAnode}{\METAlab}{\mytuple{\METAtree'_1,\dots,\METAtree'_n}}
%%   \\
%%   \hspace*{0.1in}\mbox{ if }\METAlab\in\METAlabset
%%   \mbox{ and }\forallexp{i\in\{1,\dots,n\}}{\MEMslicinga{\METAtree_i}{\METAlabset}=\METAtree'_i}
%%   \\
%%   \MEMslice{\CONStree{\METAnode}{\METAlab}{\METAtreeseq}}{\METAlabset}
%%   =
%%   \CONStreedot{\MEMflatten{\mytuple{\METAtree'_1,\dots,\METAtree'_n}}}
%%   \\
%%   \hspace*{0.1in}\mbox{ if }\METAlab\not\in\METAlabset
%%   \mbox{ and }\forallexp{i\in\{1,\dots,n\}}{\MEMslicingb{\METAtree_i}{\METAlabset}=\METAtree'_i}
%% \end{array}
%% $$
%% where $\METAtreeseq=\mytuple{\METAtree_1,\dots,\METAtree_n}$,
%% $\MEMslicingaSYMB$ is $\MEMslicingSYMB$ augmented with the
%% following rule:
%% $\MEMslicinga{\METAgenid}{\METAlabset}=\METAgenid$
%% and $\MEMslicingbSYMB$ is $\MEMslicingSYMB$ augmented with the
%% following rule:
%% $\MEMslicingb{\METAgenid}{\METAlabset}=\CONStreedot{\mytuple{}}$.

%% We redefine our function $\MEMslicingSYMB$ as follows:




\subsubsection{Generating type error slices for example~$\examplerun$}


%% First, let us repeat example~$\examplerun$ which is defined in
%% Sec.~\ref{sec:syntax} as the declaration $\METAstrdec_{\mathrm{EX}}$:
%% \begin{center}
%%   \begin{\sizeintablesp}
%%     $\LABstrdecStr
%%     {\LABstrbindBas
%%       {\mbox{\inexamplebody{X}}}
%%       {\LABstrexpFourp
%%         {\LABstrdecStr
%%           {\LABstrbindBas
%%             {\mbox{\inexamplebody{S}}}
%%             {\LABstrexpOne
%%               {\LABstrdecDec
%%                 {\LABdecDat
%%                   {\LABspdatbind
%%                     {\LABdatnamep{\mbox{\inexamplebody{'a}}}{\mbox{\inexamplebody{u}}}{\METAlab_6}}
%%                     {\LABtypeconId{\mbox{\inexamplebody{U}}}{\METAlab_7}}
%%                     {\METAlab_5}
%%                   }
%%                 }
%%               }
%%               {}
%%               {\METAlab_4}
%%             }
%%             {\METAlab_3}
%%           }
%%         }
%%         {\LABstrdecDec
%%           {\LABdecDat
%%             {\LABspdatbind
%%               {\LABdatnamep{\mbox{\inexamplebody{'a}}}{\mbox{\inexamplebody{t}}}{\METAlab_9}}
%%               {\LABtypeconId{\mbox{\inexamplebody{T}}}{\METAlab_{10}}}
%%               {\METAlab_8}
%%             }
%%           }
%%         }
%%         {\LABstrdecDec
%%           {\LABdecVal
%%             {\LABvalbind
%%               {\LABpatAtpat{\LABpatId{\mbox{\inexamplebody{f}}}{\METAlab_{12}}}}
%%               {\LABexpFnp
%%                 {\LABmrule
%%                   {\LABpatAtpat{\LABpatId{\mbox{\inexamplebody{T}}}{\METAlab_{14}}}}
%%                   {\LABexpAtexp{\LABexpId{\mbox{\inexamplebody{T}}}{\METAlab_{15}}}}
%%                   {\METAlab_{13}}
%%                 }
%%                 {}
%%               }
%%               {\METAlab_{11}}
%%             }
%%           }
%%         }
%%         {\LABstrdecDec
%%           {\LABdecVal
%%             {\LABvalbind
%%               {\LABpatAtpat{\LABpatId{\mbox{\inexamplebody{g}}}{\METAlab_{17}}}}
%%               {\LABexpAtexp
%%                 {\LABexpLet
%%                   {\LABdecOpen{\mbox{\inexamplebody{S}}}{\METAlab_{19}}}
%%                   {\LABexpApp
%%                     {\LABexpAtexp{\LABexpId{\mbox{\inexamplebody{f}}}{\METAlab_{21}}}}
%%                     {\LABexpId{\mbox{\inexamplebody{U}}}{\METAlab_{22}}}
%%                     {\METAlab_{20}}
%%                   }
%%                   {\METAlab_{18}}
%%                 }
%%               }
%%               {\METAlab_{16}}
%%             }
%%           }
%%         }
%%         {\METAlab_2}
%%       }
%%       {\METAlab_1}
%%     }$
%%   \end{\sizeintablesp}
%% \end{center}

We saw in Sec.~\ref{sec:genexamplerun}, that, given
example~$\examplerun$ (i.e., given $\METAstrdec_{\mathrm{EX}}$), our
initial constraint generation algorithm generates the environments
$\METAcsenv_{\mathrm{EX}}$.
%
We saw in Sec.~\ref{sec:examplerun}, that, given
$\METAcsenv_{\mathrm{EX}}$, our enumeration algorithm enumerates only
one error, namely $\METAerror_{\mathrm{EX}}$.
%
Sec.~\ref{sec:solvexamplerun} defines
$\METAerror_{\mathrm{EX}}
=\CONSerror{\METAuniferrorkind_{\mathrm{EX}}}{\METAcdepset_{\mathrm{EX}}}$
where
$\METAcdepset_{\mathrm{EX}}
=\{
\METAlab_{3},
\METAlab_{4},
\METAlab_{5},
\METAlab_{6},
\METAlab_{7},
\METAlab_{8},
\METAlab_{9},
\METAlab_{10},
\METAlab_{11},
\METAlab_{12},
\METAlab_{13},
\METAlab_{14},
\METAlab_{19},
\METAlab_{20},
\METAlab_{21},
\METAlab_{22}
\}$.
Let us present the slice that our slicing algorithm computes when
given $\METAerror_{\mathrm{EX}}$, i.e.,
we compute
$\MEMslicing{\METAstrdec_{\mathrm{EX}}}{\METAcdepset_{\mathrm{EX}}}$.

\begin{\myfigure}[!t]
\begin{\sizeintables}
  \begin{tabular}{l}
    $\CONStree
    {\CONSnode{\CONSastStrdec}{\CONSastStrdecstr}}
    {\METAlab_1}
    {\CONStreechildTwo
      {\mbox{\inexamplebody{X}}}
      {\CONStree
        {\CONSnode{\CONSastStrexp}{\CONSastStrexpst}}
        {\METAlab_2}
        {\CONStreechildFour
          {\METAtree_1}
          {\METAtree_2}
          {\METAtree_3}
          {\METAtree_4}
        }
      }
    }$
    \vspace{0.04in}
    \\

    where
    \begin{tabular}[t]{l}
      $\METAtree_1
      =\CONStreepp
      {\CONStreeB\CONSnode{\CONSastStrdec}{\CONSastStrdecstr}}
      {\METAlab_3}
      {\CONStreechildTwopp
        {\CONStreeB\mbox{\inexamplebody{S}}}
        {\CONStreepp
          {\CONStreeB\CONSnode{\CONSastStrexp}{\CONSastStrexpst}}
          {\METAlab_4}
          {\CONStreeB\CONStreechildOnepp
            {\CONStreeB\CONStreepp
              {\CONSnode{\CONSastDec}{\CONSastDecdat}}
              {\METAlab_5}
              {\CONStreechildTwo
                {\CONStree
                  {\CONSnode{\CONSastDatname}{\CONSastDatnamecon}}
                  {\METAlab_6}
                  {\mytuple{\mbox{\inexamplebody{'a}},\mbox{\inexamplebody{u}}}}}
                {\CONStree
                  {\CONSnode{\CONSastConbind}{\CONSastId}}
                  {\METAlab_7}
                  {\mytuple{\mbox{\inexamplebody{U}}}}\CONStreeE\CONStreeE\CONStreeE\CONStreeE\CONStreeE
                }
              }
            }
          }
        }
      }$
      \vspace{0.02in}
      \\

      $\METAtree_2
      =\CONStree
      {\CONSnode{\CONSastDec}{\CONSastDecdat}}
      {\METAlab_8}
      {\CONStreechildTwo
        {\CONStree
          {\CONSnode{\CONSastDatname}{\CONSastDatnamecon}}
          {\METAlab_9}
          {\mytuple{\mbox{\inexamplebody{'a}},\mbox{\inexamplebody{t}}}}
        }
        {\CONStree
          {\CONSnode{\CONSastConbind}{\CONSastId}}
          {\METAlab_{10}}
          {\mytuple{\mbox{\inexamplebody{T}}}}
        }
      }$
      \vspace{0.02in}
      \\

      $\METAtree_3
      =\CONStreepp
      {\CONStreeB\CONSnode{\CONSastDec}{\CONSastDecrec}}
      {\METAlab_{11}}
      {\CONStreechildTwopp
        {\CONStreeB\CONStree
          {\CONSnode{\CONSastAtpat}{\CONSastId}}
          {\METAlab_{12}}
          {\mytuple{\mbox{\inexamplebody{f}}}}
        }
        {\CONStree
          {\CONSnode{\CONSastExp}{\CONSastExpfn}}
          {\METAlab_{13}}
          {\CONStreechildTwo
            {\CONStree
              {\CONSnode{\CONSastAtpat}{\CONSastId}}
              {\METAlab_{14}}
              {\mytuple{\mbox{\inexamplebody{T}}}}
            }
            {\CONStree
              {\CONSnode{\CONSastAtexp}{\CONSastId}}
              {\METAlab_{15}}
              {\mytuple{\mbox{\inexamplebody{T}}}}\CONStreeE\CONStreeE
            }
          }
        }
      }$
      \vspace{0.02in}
      \\

      $\METAtree_4
      =\CONStreepp
      {\CONStreeB\CONSnode{\CONSastDec}{\CONSastDecrec}}
      {\METAlab_{16}}
      {\CONStreechildTwopp
        {\CONStreeB\CONStree
          {\CONSnode{\CONSastAtpat}{\CONSastId}}
          {\METAlab_{17}}
          {\mytuple{\mbox{\inexamplebody{g}}}}
        }
        {\CONStreepp
          {\CONStreeB\CONSnode{\CONSastAtexp}{\CONSastAtexplet}}
          {\METAlab_{18}}
          {\CONStreechildTwopp
            {\CONStreeB\CONStree
              {\CONSnode{\CONSastDec}{\CONSastDecopn}}
              {\METAlab_{19}}
              {\mytuple{\mbox{\inexamplebody{S}}}}}
            {\CONStree
              {\CONSnode{\CONSastExp}{\CONSastApp}}
              {\METAlab_{20}}
              {\CONStreechildTwo
                {\CONStree
                  {\CONSnode{\CONSastAtexp}{\CONSastId}}
                  {\METAlab_{21}}
                  {\mytuple{\mbox{\inexamplebody{f}}}}
                }
                {\CONStree
                  {\CONSnode{\CONSastAtexp}{\CONSastId}}
                  {\METAlab_{22}}
                  {\mytuple{\mbox{\inexamplebody{U}}}}\CONStreeE\CONStreeE\CONStreeE\CONStreeE
                }
              }
            }
          }
        }
      }$
    \end{tabular}
  \end{tabular}
  \end{\sizeintables}
  \caption{Result of applying $\MEMtogenSYMB$ to $\METAstrdec_{\mathrm{EX}}$}
  \label{fig:slicingex1}
\end{\myfigure}

Fig.~\ref{fig:slicingex1} shows the tree (which we call
$\METAtree_{\mathrm{EX}}$) obtained when applying $\MEMtogenSYMB$ to
$\METAstrdec_{\mathrm{EX}}$.
%
Finally,
$\MEMslicing{\MEMtogen{\METAstrdec_{\mathrm{EX}}}}{\METAcdepset_{\mathrm{EX}}}$
returns the following tree where $\METAtree_1$ and $\METAtree_2$ are
the ones defined above, and $\METAtree'_3$ and $\METAtree'_4$,
are obtained from $\METAtree_3$ and $\METAtree_4$ respectively:
\begin{center}
\begin{\sizeintables}
  \begin{tabular}{l}
    $\CONStreedot
    {\CONSdotD}
    {\CONStreechildFour
      {\METAtree_1}
      {\METAtree_2}
      {\METAtree'_3}
      {\METAtree'_4}
    }$
    \vspace{0.04in}
    \\

    where
    \begin{tabular}[t]{l}
      $\METAtree'_3
      =\CONStreepp
      {\CONStreeB\CONSnode{\CONSastDec}{\CONSastDecrec}}
      {\METAlab_{11}}
      {\CONStreechildTwopp
        {\CONStreeB\CONStree
          {\CONSnode{\CONSastAtpat}{\CONSastId}}
          {\METAlab_{12}}
          {\mytuple{\mbox{\inexamplebody{f}}}}
        }
        {\CONStree
          {\CONSnode{\CONSastExp}{\CONSastExpfn}}
          {\METAlab_{13}}
          {\CONStreechildTwo
            {\CONStree
              {\CONSnode{\CONSastAtpat}{\CONSastId}}
              {\METAlab_{14}}
              {\mytuple{\mbox{\inexamplebody{T}}}}
            }
            {\CONStreedot{\CONSdotE}{\mytuple{}}}\CONStreeE\CONStreeE
          }
        }
      }$
      \vspace{0.02in}
      \\

      $\METAtree'_4
      =\CONStreedotpp
      {\CONStreeB\CONSdotE}
      {\CONStreechildTwopp
        {\CONStreeB\CONStree
          {\CONSnode{\CONSastDec}{\CONSastDecopn}}
          {\METAlab_{19}}
          {\mytuple{\mbox{\inexamplebody{S}}}}}
        {\CONStree
          {\CONSnode{\CONSastExp}{\CONSastApp}}
          {\METAlab_{20}}
          {\CONStreechildTwo
            {\CONStree
              {\CONSnode{\CONSastAtexp}{\CONSastId}}
              {\METAlab_{21}}
              {\mytuple{\mbox{\inexamplebody{f}}}}
            }
            {\CONStree
              {\CONSnode{\CONSastAtexp}{\CONSastId}}
              {\METAlab_{22}}
              {\mytuple{\mbox{\inexamplebody{U}}}}\CONStreeE\CONStreeE
            }
          }
        }
      }$
    \end{tabular}
  \end{tabular}
\end{\sizeintables}
\end{center}

This slice is displayed as follows:

\examplebody{
\Bl
\lslice\Bl..structure S = struct datatype 'a u = U end
       \\
       ..datatype 'a t = T
       \\
       ..val rec f = fn T => \lslice..\rslice
       \\
       ..\lslice..open S..f U..\rslice..\rslice
       \El
\El
}



\subsection{\SECminimality}
\label{sec:minimality}



\hidden{Let us informally define the function $\MEMbindingsSYMB$ on
environments.  This function uses a modified version of our constraint
solver that keeps track of the bindings generated by the accessor
rules~$\unifruleacca$ and~$\unifruleaccc$.  Given a piece of code and
using the constraint generation algorithm, $\MEMbindingsSYMB$
generates an environment, filters out all the labelled equality
constraints in the generated environment,
runs the modified constraint solver on the filtered
environment, and finally returns the recorded bindings.}

Informally, $\MEMbindingsSYMB$ is a function on environments that
extracts the bindings between accessors and binders (by keeping track
of the bindings generated at constraint solving by
rules~$\unifruleacca$ and~$\unifruleaccc$).  We extend this function
to a function on our external labelled syntax (this extension uses our
constraint generator).
%
For example, if $\METAexp$ is
\inexamplebody{let val x = true in let val x = 1 in x end end}, and the
label $\METAlab_i$ is associated with the $i$th occurrence of
\inexamplebody{x} then
$\MEMbindings{\METAexp}=\{\mytuple{\METAlab_2,\METAlab_3}\}$.
%$\MEMbindingsSYMB$ is then also defined on constraint sets.

\mynote{(2010-04-21)}{This is also how we can identify the free
  identifiers.}

\mynote{(2010-04-01)}{We don't to create bindings when variables such
  as $\METAtyvar_0$ are involved.}

\mynote{(2010-04-21)}{$\MEMeqconsSYMB$ is only used in proof sketches,
  so we can get rid of it for the paper.}

\mynote{(2010-05-06)}{Let us define the following equivalence relation
  on constraint sets: we write
  $\MEMeqcons{\METAcsset_1}{\METAcsset_2}$ iff
  ($\MEMgetuniferror{\METAcsset_1}{\METAerror}$ iff
  $\MEMgetuniferror{\METAcsset_2}{\METAerror}$).}

%% \mynote{(2010-03-28)}{$\MEMbindingsSYMB$ can also be defined on
%%   $\METAcsorenv$.}

\hidden{  We
write $\MEMsubslicel{\METAstrdec_1}{\METAstrdec_2}{\METAlabset}$ iff
$\MEMsubsliceeql{\METAstrdec_1}{\METAstrdec_2}{\METAlabset}$ and
$\METAstrdec_1\not=\METAstrdec_2$.}

\hidden{We write $\MEMsubsliceeq{\METAstrdec_1}{\METAstrdec_2}$ iff there
exists $\METAlabset$ such that
$\MEMsubsliceeql{\METAstrdec_1}{\METAstrdec_2}{\METAlabset}$ and
similarly for $\MEMsubslice{\METAstrdec_1}{\METAstrdec_2}$.}

\mynote{(2010-03-25)}{It seems that we have to use
  $\METAstrdec_1\not=\METAstrdec_2$ and not
  $\neg\MEMdisj{\METAlabset,\MEMlabelset{\METAstrdec_2}}$, because
  some rules of the slicer don't actually get rid of labels (see the
  rule for value declarations for example).}


We define the sub-slice relation as follows: $\MEMsubsliceeql{\METAstrdec_1}{\METAstrdec_2}{\METAlabset}$
iff $\MEMslicing{\METAstrdec_2}{\METAlabset}=\METAstrdec_1$ and
$\MEMbindings{\METAstrdec_1}\subseteq\MEMbindings{\METAstrdec_2}$.

Let $\METAstrdec_2$ be a
%
\index{slice!minimal type error slice}%
%
\emph{minimal type error slice} of $\METAstrdec_1$
iff
$\neg\MEMissuccess{\METAstrdec_2}$,
$\MEMsubsliceeql{\METAstrdec_2}{\METAstrdec_1}{\METAlabset}$,
and for all $\METAstrdec'$
if
$\MEMsubsliceeql{\METAstrdec'}{\METAstrdec_2}{\METAlabset'}$
for some $\METAlabset'$
and $\METAstrdec'\not=\METAstrdec_2$
then $\MEMissuccess{\METAstrdec'}$.


\hidden{We say $\METAstrdec_2$ is a minimal type error slice of $\METAstrdec_1$,
denoted $\MEMminslicel{\METAstrdec_2}{\METAstrdec_1}{\METAlabset}$,
iff $\MEMsubsliceeql{\METAstrdec_2}{\METAstrdec_1}{\METAlabset}$,
$\neg\MEMissuccess{\METAstrdec_2}$
and for all $\METAstrdec'$
%$\METAlab\in\MEMlabelset{\METAstrdec_2}$
%and $\MEMsubslicel{\METAstrdec'}{\METAstrdec_2}{\{\METAlab\}}$
if $\MEMsubslice{\METAstrdec'}{\METAstrdec_2}$
then $\MEMissuccess{\METAstrdec'}$.
We write $\MEMminslice{\METAstrdec_2}{\METAstrdec_1}$ iff there exists
$\METAlabset$ such that
$\MEMminslicel{\METAstrdec_2}{\METAstrdec_1}{\METAlabset}$.}


%% \mynote{2010-03-16}{$\MEMbindings{\METAstrdec}$ is informally defined
%%   above.}

We consider minimality as a design principle for our \TES\ even though
minimal slices do not always seem to be the correct answer to type
error reporting (e.g., as explained in Sec.~\ref{sec:mergederrors},
for record field name clashes we report merged minimal type error
slices).
%
\hidden{For example for record field name clashes, we do not want to provide
minimal slices, as presented in Sec.~\ref{sec:mergerrors}.}
%
%% \mynote{2010-03-23}{We should present an example here or reference an
%%   example.}

For \CORETES\ (the subset of our \TES\ presented in this section), we
believe the following holds:
%
a slice $\METAstrdec'$ is a minimal slice of $\METAstrdec$ iff
$\mytuple{\METAstrdec',\METAuniferrorkind,\METAidset}\in\MEMtes{\METAstrdec}$.
%
%% if $\typingSCS{\METAstrdec}{\METAcsenv}$ and
%% $\MEMenum{\METAunifstate}{\METAcsenv}\ffra\MEMerrorset{\METAerrorset}$
%% then $\METAerrorset$ is exactly the set of minimal type error slices
%% of $\METAstrdec$.
%
We have not formally proved this statement for diverse reasons.
First, our \TES\ (\FORMTES\ as well as \IMPLTES) is in constant change
and proving the minimality of one of its versions would not guarantee
the minimality of the others.  Moreover proving the minimality of
\CORETES\ would not guarantee the minimality of \TES\ (of \FORMTES\ or
of \IMPLTES) and proving the minimality of \TES\ is beyond the scope
of this thesis.
%
Then, as mentioned above, minimality is only a design principle.  Let
us finally stress that we feel improving the range and quality of our
slices is more important than ensuring their minimality in particular.

Note that, given an untypable piece of code, a type error slice will
always contain exactly the portion of the piece of code required to
explain the error reported by the type error slice.  Moreover, if a
part of a slice is not necessary to explain the error, minimisation
will remove it.  Therefore the minimality of a type error slice is not
related to its size.  The size of a minimal type error slice depends
on the error itself.

%% \ifcomm
%% \begin{spnote}{(2010-04-23)}
%% Let us now present the intuition on why the above statement should
%% hold (our \TES' minimality):
%% \begin{enumerate}
%% \item\label{lem:isominerr} A set of minimal type error slices is
%%   isomorphic to a set of type errors (minimal type errors): if
%%   $\MEMminslice{\METAstrdec'}{\METAstrdec}$ then there exists a unique
%%   $\METAerror$ such that for all $\METAcsenv'$ such that
%%   $\typingSCS{\METAstrdec'}{\METAcsenv'}$ then
%%   $\MEMgetuniferror{\METAcsenv'}{\METAerror}$.
%%   \mynote{(2010-03-28)}{Hard.}

%% %% \item[(C)] If $\MEMminslice{\METAstrdec'}{\METAstrdec}$ then the minimal
%% %%   error $\METAerror$ corresponding to $\METAstrdec'$ is in
%% %%   $\METAerrorset$ such that $\typingSCS{\METAstrdec}{\METAcsenv}$ and
%% %%   $\MEMenum{\METAunifstate}{\METAcsenv}\ffra\MEMerrorset{\METAerrorset}$.

%% \item\label{lem:bindingsprojsub}
%%   Bindings are preserved by filtering:
%%   $\MEMbindings{\MEMcsprojp{\METAcsenv}{\MEMlabelset{\METAcsenv}}{\METAlabset}}
%%   \subseteq
%%   \MEMbindings{\METAcsenv}$.
%%   \mynote{(2010-03-28)}{Shouldn't be too hard.}

%% \item\label{lem:bindingserrsub}
%%   Bindings are preserved by constraint solving:
%%   if $\MEMgetuniferror{\METAcsenv}{\METAerror}$ then
%%   $\MEMbindings{\MEMcsprojp{\METAcsenv}{\afunc{\METAerror}{1}}{\emptyset}}
%%   \subseteq
%%   \MEMbindings{\METAcsenv}$.
%%   \mynote{(2010-03-28)}{Shouldn't be too hard.}

%% \item\label{lem:mintobindings}
%%   Bindings are preserved by minimisation:
%%   if
%%   $\MEMnewminimise{\METAerror}{\METAcsenv}\fra\MEMnewminimiseend{\METAerror'}$
%%   then
%%   $\MEMbindings{\MEMcsprojp{\METAcsenv}{\afunc{\METAerror'}{1}}{\emptyset}}
%%   \subseteq
%%   \MEMbindings{\MEMcsprojp{\METAcsenv}{\afunc{\METAerror}{1}}{\emptyset}}$.
%%   \mynote{(2010-03-28)}{Hard.}

%% \item\label{lem:subsliceeqbindings}
%%   Slicing behaves as total filtering (when the second label set is
%%   empty, as opposed to partial when a second label set is provided to
%%   generate ``dummy'' environments) w.r.t.\ bindings:
%%   if $\typingSCS{\METAstrdec}{\METAcsenv}$ then
%%   $\MEMbindings{\MEMcsprojp{\METAcsenv}{\METAlabset}{\emptyset}}
%%   =
%%   \MEMbindings{\MEMslicing{\METAstrdec}{\METAlabset}}$.
%%   \mynote{(2010-03-28)}{Hard.}

%% \item\label{lem:bindingssublab}
%%   If $\METAlabset\subseteq\METAlabset_1\setminus\METAlabset_2$
%%   then
%%   $\MEMcsprojp{\MEMcsprojp{\METAcsenv}{\METAlabset_1}{\METAlabset_2}}{\METAlabset}{\emptyset}
%%   =
%%   \MEMcsprojp{\METAcsenv}{\METAlabset}{\emptyset}$.
%%   \mynote{(2010-03-28)}{Shouldn't be too hard.}

%% \item\label{lem:minismin} Our minimisation algorithm returns minimal
%%   errors:
%%   if $\typingSCS{\METAstrdec}{\METAcsenv}$,
%%   $\MEMgetuniferror{\MEMcsprojp{\METAcsenv}{\MEMlabelset{\METAcsenv}}{\METAlabset}}{\METAerror}$
%%   and
%%   $\MEMnewminimise{\METAerror}{\METAcsenv}\fra\MEMnewminimiseend{\METAerror'}$
%%   then there exists $\METAstrdec'$ such that
%%   $\MEMminslicel{\METAstrdec'}{\METAstrdec}{\afunc{\METAerror'}{1}}$.
%%   \mynote{(2010-03-28)}{Hard.}

%%   Let us first prove that there exists $\METAstrdec'$ such that
%%   $\MEMsubsliceeql{\METAstrdec'}{\METAstrdec}{\afunc{\METAerror'}{1}}$.
%%   Let $\METAlabset'=\afunc{\METAerror'}{1}$ and
%%   $\MEMslicing{\METAstrdec}{\METAlabset'}=\METAstrdec'$.
%%   We need
%%   $\MEMbindings{\METAstrdec'}\subseteq\MEMbindings{\METAstrdec}$ to
%%   prove $\MEMsubsliceeql{\METAstrdec'}{\METAstrdec}{\METAlabset'}$.
%%   By~\ref{lem:bindingsprojsub},~\ref{lem:bindingserrsub}
%%   and~\ref{lem:bindingssublab}, we have
%%   that $\MEMbindings{\MEMcsprojp{\METAcsenv}{\afunc{\METAerror}{1}}{\emptyset}}
%%   =
%%   \MEMbindings{\MEMcsprojp{\MEMcsprojp{\METAcsenv}{\MEMlabelset{\METAcsenv}}{\METAlabset}}{\afunc{\METAerror}{1}}{\emptyset}}
%%   \subseteq
%%   \MEMbindings{\MEMcsprojp{\METAcsenv}{\MEMlabelset{\METAcsenv}}{\METAlabset}}
%%   \subseteq
%%   \MEMbindings{\METAcsenv}
%%   =
%%   \MEMbindings{\METAstrdec}$.
%%   By~\ref{lem:mintobindings}, we get that
%%   $\MEMbindings{\MEMcsprojp{\METAcsenv}{\afunc{\METAerror'}{1}}{\emptyset}}
%%   \subseteq
%%   \MEMbindings{\MEMcsprojp{\METAcsenv}{\afunc{\METAerror}{1}}{\emptyset}}$
%%   and by~\ref{lem:subsliceeqbindings},
%%   $\MEMbindings{\METAstrdec'}
%%   \subseteq
%%   \MEMbindings{\MEMcsprojp{\METAcsenv}{\afunc{\METAerror'}{1}}{\emptyset}}$.
%%   Hence, we obtained
%%   $\MEMbindings{\METAstrdec'}\subseteq\MEMbindings{\METAstrdec}$.

%%   Let $\typingSCS{\METAstrdec'}{\METAcsenv'}$.  We then have to prove
%%   that $\neg\MEMissuccess{\METAcsenv'}$ and
%%   for all $\METAstrdec_0$ such that
%%   $\MEMsubslicel{\METAstrdec_0}{\METAstrdec'}{\{\METAlab\}}$
%%   where $\METAlab\in\MEMlabelset{\METAstrdec'}$
%%   then $\MEMissuccess{\METAstrdec_0}$.
%%   \mynote{(2010-03-28)}{Unfinished.}

%% \item\label{lem:sublabmin} If
%%   $\MEMnewminimise{\METAerror'}{\METAcsenv}\fra\MEMnewminimiseend{\METAerror}$
%%   then $\afunc{\METAerror}{1}\subseteq\MEMlabelset{\METAcsenv}$ and
%%   $\afunc{\METAerror}{1}\subseteq\afunc{\METAerror'}{1}$ and
%%   $\MEMgetuniferror{\MEMcsprojp{\METAcsenv}{\afunc{\METAerror}{1}}{\emptyset}}{\METAerror}$.
%%   \mynote{(2010-03-28)}{Shouldn't be too hard.}

%% \item\label{lem:subeqcs} Subterms generate constraint subsets: if
%%   $\MEMsubsliceeql{\METAstrdec_1}{\METAstrdec_2}{\METAlabset}$ and
%%   $\typingSCS{\METAstrdec_1}{\METAcsenv_1}$ and
%%   $\typingSCS{\METAstrdec_2}{\METAcsenv_2}$ then
%%   $\MEMeqcons{\METAcsenv_1}{\MEMcsprojp{\METAcsenv_2}{\MEMlabelset{\METAcsenv_1}}{\emptyset}}$.
%%   Moreover, if $\METAlabset\subseteq\MEMlabelset{\METAstrdec_2}$ then
%%   $\MEMeqcons{\METAcsenv_1}{\MEMcsprojp{\METAcsenv_2}{\METAlabset}{\emptyset}}$.
%%   \mynote{(2010-03-28)}{Hard.}

%% \item\label{lem:csgeneqlab}
%%   Our constraint generation algorithm generates constraints for every
%%   program points:
%%   if $\typingSCS{\METAstrdec}{\METAcsenv}$
%%   then $\MEMlabelset{\METAcsenv}=\MEMlabelset{\METAstrdec}$.
%%   \mynote{(2010-03-28)}{Shouldn't be too hard.}

%% %% \item[(H)] If
%% %%   $\MEMslicing{\METAstrdec_1}{\METAlabset}=\METAstrdec_2$ and
%% %%   $\METAlabset\subseteq\MEMlabelset{\METAstrdec_1}$ then for all
%% %%   $\METAcsenv$,
%% %%   $\MEMeqcons{\MEMcsprojp{\METAcsenv}{\MEMlabelset{\METAstrdec_2}}{\emptyset}}{\MEMcsprojp{\METAcsenv}{\METAlabset}{\emptyset}}$.

%% \item We now sketch the proof that our enumeration algorithm
%%   enumerates minimal errors: if $\METAerror\in\METAerrorset$
%%   where $\METAerrorset$ is such that
%%   $\typingSCS{\METAstrdec}{\METAcsenv}$ and
%%   $\MEMenum{\METAunifstate}{\METAcsenv}\ffra\MEMerrorset{\METAerrorset}$
%%   then $\METAerror$ is a minimal type error of $\METAstrdec$.

%%   Because
%%   $\MEMenum{\METAunifstate}{\METAcsenv}\ffra\MEMerrorset{\METAerrorset}$
%%   and $\METAerror\in\METAerrorset$ then there exists $\METAerror'$,
%%   $\METAerrorset_0\subset\METAerrorset$ and
%%   $\METAlabset\subseteq\MEMlabelset{\METAcsenv}$ (a filter) such that
%%   $\MEMgetuniferror{\MEMcsprojp{\METAcsenv}{\MEMlabelset{\METAcsenv}}{\METAlabset}}{\METAerror'}$
%%   and
%%   $\MEMnewminimise{\METAerror'}{\METAcsenv}\fra\MEMnewminimiseend{\METAerror}$

%%   %% $\MEMenumdone{\METAerror'}{\METAerrorset_0}{\METAcsenv}{\METAerrorset_0\dunion\{\METAerror\}}{\METAlabset'}$
%%   %% and by definition of $\MEMenumdoneSYMB$, for all
%%   %% $\METAerror''\in\METAerrorset_0$,
%%   %% ($\afunc{\METAerror''}{1}\not\subseteq\afunc{\METAerror'}{1}$ or
%%   %% $\afunc{\METAerror''}{2}\not\subseteq\afunc{\METAerror'}{2}$) and
%%   %% $\MEMnewminimise{\METAerror'}{\METAcsenv}\fra\MEMnewminimiseend{\METAerror}$
%%   %% and $\METAlabset'=\afunc{\METAerror}{1}$.

%%   Hence by~\ref{lem:minismin},
%%   there exists $\METAstrdec'$ such that
%%   $\MEMminslicel{\METAstrdec'}{\METAstrdec}{\afunc{\METAerror}{1}}$.

%%   By definition of a minimal slice let $\typingSCS{\METAstrdec'}{\METAcsenv'}$
%%   and $\MEMgetuniferror{\METAcsenv'}{\METAerror''}$.  We then have to
%%   prove that $\METAerror''=\METAerror$ and use~\ref{lem:isominerr}.

%%   By~\ref{lem:sublabmin},
%%   $\MEMgetuniferror{\MEMcsprojp{\METAcsenv}{\afunc{\METAerror}{1}}{\emptyset}}{\METAerror}$.

%%   By~\ref{lem:sublabmin} and~\ref{lem:csgeneqlab},
%%   $\afunc{\METAerror}{1}\subseteq\MEMlabelset{\METAcsenv}=\MEMlabelset{\METAstrdec}$.

%%   So by~\ref{lem:subeqcs},
%%   $\MEMeqcons{\METAcsenv'}{\MEMcsprojp{\METAcsenv}{\afunc{\METAerror}{1}}{\emptyset}}$.

%%   So $\MEMgetuniferror{\METAcsenv'}{\METAerror}$ and by \ref{lem:isominerr},
%%   $\METAerror=\METAerror''$.

%%   We know that if our enumeration algorithm enumerates an error then
%%   this error is minimal.  We then have to prove that all such minimal
%%   errors are enumerated by our algorithm.  This is due to our filter
%%   generation during enumeration.  \mynote{(2010-03-28)}{Unfinished.}
%% \end{enumerate}


%% \mynote{(2010-03-26)}{I believe these hold:
%% \begin{itemize}
%% \item Our constraint solver returns untypable slices:
%%   if $\typingSCS{\METAstrdec}{\METAcsenv}$,
%%   $\MEMgetuniferror{\METAcsenv}{\METAerror}$
%%   and $\MEMslicing{\METAstrdec}{\MEMlabelset{\METAerror}}=\METAstrdec'$
%%   then $\neg\MEMissuccess{\MEMcsprojp{\METAcsenv}{\MEMlabelset{\METAerror}}{\emptyset}}$
%%   and $\MEMbindings{\METAstrdec'}\subseteq\MEMbindings{\METAstrdec}$.
%% %% \item A slice of a structure declaration is untypable iff the
%% %%   restriction of the structure declaration's constraint set to the slice
%% %%   is unsolvable:
%% %%   if $\typingSCS{\METAstrdec}{\METAcsenv}$,
%% %%   $\typingSCS{\METAstrdec'}{\METAcsenv'}$
%% %%   and $\MEMsubsliceeql{\METAstrdec'}{\METAstrdec}{\METAlabset}$
%% %%   then
%% %%   $\MEMissuccess{\MEMcsprojp{\METAcsenv}{\METAlabset}{\emptyset}}
%% %%   \iff
%% %%   \MEMissuccess{\METAcsenv'}$.
%% %% \item For all $\METAlabset$ and $\METAcsenv$,
%% %%   $\MEMissuccess{\METAcsenv}
%% %%   \iff
%% %%   \MEMissuccess{\MEMcsprojp{\METAcsenv}{\MEMlabelset{\METAcsenv}}{\METAlabset}}$.
%% \item Our minimisation algorithm returns minimal slices:
%%   if $\typingSCS{\METAstrdec}{\METAcsenv}$,
%%   $\MEMgetuniferror{\METAcsenv}{\METAerror}$
%%   and $\MEMnewminimise{\METAerror}{\METAcsenv}\fra\MEMnewminimiseend{\METAerror'}$
%%   then $\METAstrdec'$ such that
%%   $\MEMslicing{\METAstrdec}{\MEMlabelset{\METAerror'}}=\METAstrdec'$
%%   is a minimal error slice of $\METAstrdec$
%%   and $\MEMbindings{\METAstrdec'}\subseteq\MEMbindings{\METAstrdec}$.
%% \item For all $\METAstrdec$, there exists $\METAcsenv$ such that
%%   $\typingSCS{\METAstrdec}{\METAcsenv}$ and for all $\METAcsenv'$ such
%%   that $\typingSCS{\METAstrdec}{\METAcsenv'}$, there exists $\METAren$
%%   such that $\METAcsenv=\MEMrenaming{\METAren}{\METAcsenv'}$.
%% \end{itemize}}
%% \end{spnote}
%% \fi





\subsection{\SECprinciples}
\label{sec:principles}


While developing our \TES\ we discovered, developed, and followed the
following principles.

%% \textbf{Variables.}
\principleA.\ Each syntactic sort of constraint terms should have a
case ranging over an infinite variable set.
This allows incomplete information everywhere, which allows one to
consider every possible way of slicing out parts of the program.
This is essential to get precise slices that include all relevant
details and exclude the irrelevant.
Thus, the sorts
%
$\METAnamety$,
%
$\METAlabty$, and
%
$\METAcsenv$
%
have the variable cases
%
$\METAtynamevar$,
%
$\METAtyvar$, and
%
$\METAenvvar$.
%
%% Our implementation has a variable case of raw identifier statuses
%% ($\METArawstatus$) which is omitted from this paper to save space.
\mynote{2010-07-15}{Why do we not have a variable for sort
  $\METAscheme$?}

%% \textbf{Dependencies.}
\principleB.\ Each syntactic sort of constraint terms should support
dependencies.
This allows precise blame, which enables precise
slicing.
Thus, sorts
%
%$\METAstatus$,
%
$\METAnamety$,
%
$\METAlabty$,
%
$\METAscheme$, and
%
$\METAcsenv$
%
have dependency cases
%
%$\CONSdeps{\METAstatus}{\METAcdepset}$,
%
$\CONSdeps{\METAnamety}{\METAcdepset}$,
%
$\CONSdeps{\METAlabty}{\METAcdepset}$,
%
$\CONSdeps{\METAscheme}{\METAcdepset}$, and
%
$\CONSdeps{\METAcsenv}{\METAcdepset}$.
%% We omit type scheme dependencies ($\METAscheme$) because handling
%% schemes is already complex and only dependencies on plain types
%% ($\METAlabty$) are needed in this paper.

%% \textbf{Connections.}
\principleC.\ Our initial constraint generation rules return a main
result (a type or an environment) and sometimes also an environment
result (used for constraints and bindings), i.e., our initial
constraint generation rules return $\METAcgterm$s as defined in
Fig.~\ref{sec:genalgo}.
% when the main result is not an environment).
The generated constraints may connect information from the results for
a program node's subtrees to the other subtrees or to the node's
results.

The principle is that these connections should generally be via
constraints that carry the syntax tree node's label and that are
``shallow'', i.e., contain only connection details and not constraints
from program subtrees (see $\SETcsg$'s definition in
Sec.~\ref{sec:shapegenenvs}).
%
Fresh variables should be used as needed.  This allows a program
syntax node to be ``disconnected'' for type errors that depend on the
node's details, while still keeping type errors that arise solely due
to connections between environment accessors and bindings that pass
through the node.

For example, rule~$\MEMgencgruler$ of our initial constraint
generation algorithm defined in Fig.~\ref{fig:consGenAlgo} in
Sec.~\ref{sec:genalgo} builds the unlabelled constraint
\(
  \csou{\METAenvvar'}
       {(\CONSenvenvn{\METAcsenv_n}{\METAcsenv_{n-1}}{\METAcsenv_1})}
\).
This ``deep'' unlabelled constraint packs together a sequence of environments
%% TODO: here again we use sequence instead of composition and it
%% seems to fit more?!
from the declarations that are the structure's body.
The resulting environment is connected to the main result by the
labelled shallow constraint
$\cso{\METAenvvar}{\METAenvvar'}{\METAlab}$.

\mynote{2010-07-16}{The semantics for dependencies is given by
  constraint filtering which discards equality constraints with
  unsatisfied dependencies.
  So a constraint need only hold when its dependencies also hold.}

%%% Labelling non shallow constraints could lead to the non minimisation
%%% of errors as filtering could then discard environments
%%% necessary for an error to occur.  For example, labels associated to
%%% structure expressions often do not participate in type errors occurring
%%% between the nested declarations.
%%% %
%%% Let us assume that a not yet minimal type error is found inside a structure
%%% expression, but does not involve the structure expression.
%%% %% HERE WE SHOULD GIVE THE EXAMPLE PRESENTED BELOW.
%%% %
%%% If we were to label the non shallow constraints generated
%%% by rule $\MEMgencgruler$ of our constraint generation algorithm
%%% presented in Fig.~\ref{fig:consGenAlgo}, the minimisation algorithm
%%% would fail to minimise the error.
%%% %
%%% The minimisation algorithm would always filter the equality constraint
%%% generated for the structure expression, constraint solving on the
%%% filtered environment would always succeed, and then rule
%%% $\reduceruleone$ would never be used.  The found error would not be
%%% minimised further.  In consequence, rule $\enumrulefour$ of our
%%% enumeration algorithm would fail to enumerate a minimal error (it would
%%% enumerate the non minimised error as it was found).

\hidden{
%% THIS IS ACTUALLY WRONG IN THE PAPER IMPLEMENTATION, FOR THIS
%% EXAMPLE, THE FOUND ERROR IS MINIMAL FROM THE BEGINNING.
%%
%% THE EXAMPLE BELOW IS A CORRECT EXAMPLE.
%%
Labelling non shallow constraints could lead to the non minimisation
of errors as filtering could then discard environments necessary for
an error to occur.  For example, in \inexamplebody{structure S =
  struct fun f x y = x y val x = f 1 end}, the labels associated with
the structure declaration expression are not involved in the type
error which is that \inexamplebody{f} is applied to \inexamplebody{1}
but \inexamplebody{f}'s first parameter is used as a function
(\inexamplebody{x} begin applied in \inexamplebody{f}'s declaration).
For this example, when found by the enumeration algorithm, the type
error is not yet minimal (the error involves \inexamplebody{foo}'s
second parameter: \inexamplebody{y}), but it does not involve the
structure expression.  Therefore, if we were to label the non shallow
constraints generated by rule~$\MEMgencgruler$ of our constraint
generation algorithm presented in Fig.~\ref{fig:consGenAlgo}, the
minimisation algorithm would fail to minimise the error.  The
minimisation algorithm would always filter the equality constraint
generated for the structure expression, constraint solving on the
filtered environment would always succeed, and then
rule~$\reduceruleone$ would never be used.  The found error would not
be minimised further.  In consequence, rule~$\enumrulefour$ of our
enumeration algorithm would fail to enumerate a minimal error (would
enumerate the non minimised error as it was found).}

\hidden{
structure S = struct
datatype 'a t = T
datatype 'a t = U
val rec m = fn z => let val rec foo = fn x => z
		    in let val rec bar = fn x => z T
		       in z U
		       end
		    end
end}

%% \textbf{Constraint uniqueness.}
\principleD.\ Duplicating constraints should be unnecessary.  This
seems obvious, but some previous formalisms seem too weak for the
needed sharing.  For example, rule~$\MEMgencgruler$ of our initial
constraint generation algorithm defined in Fig.~\ref{fig:consGenAlgo}
in Sec.~\ref{sec:genalgo} builds a structure's environment as the
sequential composition of its component declarations' environments:
$\CONSenvenvn{\METAcsenv_n}{\METAcsenv_{n-1}}{\METAcsenv_1}$.  Here,
the first declaration's environment ${\METAcsenv_1}$ is available for
subsequent declarations and also in the result (if its bindings are
not shadowed) which avoids duplicating it.  A previous version of our
system had a weaker constraint system with let-constraints similar to
those of Pottier and R\'emy~\cite{Pottier+Remy:2005}, and the best
solution we could find duplicated the constraints for each
declaration's bindings, causing severe performance problems.
Sec.~\ref{sec:comparisonpottierremy} discusses further this issue.

%% \textbf{Propagation of dependencies.}
\principleE.\ Dependencies must be propagated during solving exactly
where needed.  If dependencies are not propagated where they should
go, minimisation could over-minimise yielding non-errors.  This can be
detected.  More insidiously, propagating dependencies where they are
unneeded can keep alive unneeded parts of error slices much longer
during minimisation, resulting in severe slowdowns.  Because correct
results happen eventually, detecting such bugs is harder so this
requires great care.
%
%%% %dependencies of a node can be used to
%%% %annotate its parent node except when the parent node is a constraint
%%% %typically a binder).
%%% the dependencies of a node in a environment should not be
%%% used to annotate its parent nodes.  Failing to do so could result in
%%% the enumeration of errors far from being minimal.
%
For example, an earlier version of our solver copied dependencies from
declarations in a structure to the structure's main result.  The
minimiser had to remove declarations one at a time.  Debugging this
was hard because only speed suffered.
%
%%% It might appears legitimate to do so as a structure
%%% depends on its declarations (it can ultimately be seen as a
%%% declaration set).
%
% *** The following material should really be in a different principle!
%
Furthermore, the system should
% be designed to
yield error slices (before minimisation) that are as close to minimal as can
be reasonably achieved.
If constraint solving yields a non-minimal error slice, then solving
steps must have annotated a constraint with a location on which it
does not uniquely depend.


%% \textbf{Identifiers at bound positions.}
\tocheck{
\principleF\ Sec.~\ref{sec:minbinddiscard} already mentioned this
principle.  In the labelled external syntax,
identifiers which can occur at bound positions must be labelled by a
unique label that does not label a piece of code larger than the
identifier itself.  Moreover, for those labelled identifiers, the
constraint generator should in general generate no more than a
labelled accessor.
%
(Note that to simplify the presentation of \CORETES\ we do otherwise
for structure openings (see constraint generation
rule~$\MEMgencgrulem$ in Fig.~\ref{fig:consGenAlgo}) but this is in
general unsafe.)
%
The risk of not following this principle is that during minimisation,
a bound occurrence of an identifier can be kept in a slice while its
binding occurrence is discarded.  This can then result in the
identifier at a bound position being bound to a different binding
occurrence than the one to which it is originally bound in the
original piece of code.  This can then lead to generating wrong
identifier bindings and finding false errors.}

%% \textbf{Environment variables.}
\principleG\ Environment variables, when not generated as part of a
shallow environment in an equality constraint (e.g., as the direct
left or right-hand-side of an equality constraint), should always be
labelled.
%
As explained in Sec.~\ref{sec:constraintsystem}, an unlabelled
environment variable is a constraint that can never be filtered out
and has to always be satisfied (independently from any program
location).  Because an environment variable shadows its context (i.e.,
in $(\CONSenvenv{\METAcsenv}{\METAenvvar})$, the environment variable
$\METAenvvar$ shadows $\METAcsenv$), if such an environment variable
is unlabelled and is not constrained to be equal to anything, it can
only shadow its context whatever filtering is applied on it.  This
behaviour is undesirable because the shadowing of an environment
should in general be dependent on a program location (see, e.g.,
constraint generation rule~$\MEMgencgrulem$ in
Fig.~\ref{fig:consGenAlgo} for \inexamplebody{open} declarations).
%

However, in our \TES, at constraint generation, it happens that most of
the environment variables not generated as part of a shallow
environment in an equality constraint cannot shadow their
environments.  It is the case for rules~$\MEMgencgruled$,
$\MEMgencgrulel$ and~$\MEMgencgrulen$.
%
(Note that in these rules, each generated environment variable has to
be labelled to carry the dependency on the program point responsible
for its generation.)
%
Each of these rules generates an environment variable that is
constrained by an unlabelled equality constraint on the environment
variable itself (these unlabelled equality constraints cannot be
filtered out).  If these equality constraints were labelled, but the
environment variables were not, the equality constraints could be
filtered out and the environment variables could then be unconstrained
and therefore shadow their contexts.
%
Given a piece of code, for rule~$\MEMgencgrulel$, e.g., this would
mean that filtering out the constraints associated with a recursive
value declaration in the piece of code would allow this declaration to
shadow its entire context in the analysed piece of code which is
undesirable.  For example, when slicing out the recursive value
declaration in
%
\inexamplebody{val x = 1 val rec f = fn x => x val y = x x},
%
we do not want it do shadow \inexamplebody{val x = 1} (i.e., we do not
want
the environment generated for \inexamplebody{val rec f = fn x => x} to
shadow the environment generated for \inexamplebody{val x = 1} when
the label associated with \inexamplebody{val rec f = fn x => x} is
sliced out in the environment generated for the entire piece of code).
%
%% In these rules environment variables are always constrained to be
%% equal to other environments via unlabelled equality constraints.
%
Rule~$\MEMgencgrulem$ stands out by generating environment variables
that are constrained by labelled accessors.  Hence, if this rule was
generating
$(\CONSenvenv{\METAenvvar}{(\CONSaccl{\METAstrid}{\METAenvvar}{\METAlab})})$
instead
$(\CONSenvenv{\CONSdepss{\METAenvvar}{\METAlab}}{(\CONSaccl{\METAstrid}{\METAenvvar}{\METAlab})})$
(where the environment variable is unlabelled), $\METAenvvar$ would
then be totally unconstrained when filtering out the accessor.  This
would disallow one to slice out \inexamplebody{open} declarations.
Worse, this could lead to finding typable type error slices.  Let us
illustrate this last point with the following example:


\examplebody{
\Bl
structure S = struct end
\\
val x = 1
\\
open S
\\
val y = x 1
\El
}

Note that the structure \inexamplebody{S} is empty, so
\inexamplebody{open S} does not do anything and especially
\inexamplebody{x} is not rebound.
%
Let us assume that our constraint generation algorithm generates the
environment $\METAcsenv$ for this sequence of declarations.
%
Our enumeration algorithm would find a slice as follows:

\examplebody{
\Bl
\lslice\Bl..val x = 1
       \\
       ..x \lslice..\rslice..\rslice
       \El
\El
}

Now, filtering out the constraints in $\METAcsenv$ w.r.t.\ this slice
would lead to an environment $\METAcsenv'$ where the unlabelled
environment variable generated for \inexamplebody{open S} (assuming
that unlabelled environment variables are generated for \inexamplebody{open}
declarations instead of labelled environment variables as we do in our
\TES) shadows the environment generated for \inexamplebody{x}'s
declarations.  The environment $\METAcsenv'$ would then be solvable.


%% \subsection{Features defined on top of the core}
%% \label{sec:short-extensions}

%% We now describe the key ideas for supporting \SML\ features beyond what
%% \CORETES\ supports (they are formally presented in
%% \ifappendix
%%   \ifconf
%%     Appendix~\ref{sec:extensions}).
%%   \else
%%     Sec.~\ref{sec:extensions}).
%%   \fi
%% \else
%%   the extended version of this paper).
%% \fi
%% Although some additional \TES\ features we add partially mimic \SML\
%% external syntax forms, many new primitive \TES\ constructs allow
%% handling several new external forms.

%% \intitle{Identifier statuses.}
%% We associate internal statuses to value identifiers ($\METAid$) via binders and accessors.
%% %
%% %% Statuses are defined as follows:
%% %% \begin{center}
%% %%   \begin{\sizeintables}
%% %%     \begin{tabular}{rclrll}
%% %%       $\METAstatusvar$  & $\in$ & $\SETstatusvar$  &        & (status variables)\\
%% %%       $\METArawstatus$  & $\in$ & $\SETrawstatus$  & $::=$  & $\CONSstatusv\mid\CONSstatusc\mid\CONSstatusd\mid\CONSstatusu\mid\CONSstatusp$\\
%% %%       $\METAstatus$     & $\in$ & $\SETstatus$     & $::=$  & $\METAstatusvar\mid\METArawstatus\mid\CONSdeps{\METAstatus}{\METAcdepset}$\\
%% %%     \end{tabular}
%% %%   \end{\sizeintables}
%% %% \end{center}
%% %
%% During constraint solving, unconfirmed binders of the form
%% $\CONSbindu{\METAid}{\METAtyvar}$ can turn into either binders or
%% accessors, depending on whether context information forces $\METAid$
%% to be a value variable or a datatype constructor.

%% \intitle{Local declarations.}
%% We add local environments of the form
%% $\CONSlocalenv{\METAcsenv_1}{\METAcsenv_2}$, with semantics between
%% the semantics of $\CONSenvenv{\METAcsenv_2}{\METAcsenv_1}$ and
%% $\csbind{\CONSenvenv{\METAcsenv_2}{\METAcsenv_1}}$.
%% Unlike these forms, local environments allow partial visibility of
%% binders: only $\METAcsenv_2$'s binders are visible outside.
%% (Local environments also allow correctly handling the local scope of
%% explicit type variables in datatype (and type) declarations, because
%% rules $\MEMgencgrulen$ and $\MEMgencgruleo$ must be fixed to extend to
%% full \SML.)

%% \intitle{Type functions.}
%% We use pseudo-type functions which are internal type
%% constructors of the form $\CONStypfun{\METAtyvar}{\METAlabty}$, which
%% bind $\METAtyvar$ in $\METAlabty$.
%% These are ``pseudo''-type functions because constraint solving can
%% instantiate $\METAtyvar$ and $\METAlabty$ to yield an actual type
%% function.

%% \intitle{Signatures.}
%% %
%% We add signature constraints of the form
%% $\CONStrenv{\METAcsenv_1}{\METAcsenv_2}$ where $\METAcsenv_2$
%% generated for a signature constrains $\METAcsenv_1$ generated for a
%% structure.
%% We also add subtyping constraints.
%% For type schemes these are of the form  $\CONSsubty{\METAscheme_1}{\METAscheme_2}{\METAid}$, where the
%% constraint is satisfied if $\METAscheme_1$ is ``more polymorphic''
%% than $\METAscheme_2$, and if so turns into a $\METAid$ binder
%% at constraint solving.
%% %
%% We also distinguish flexible and rigid type variables
%% to handle explicit type variables.
%% %
%% Our core external language in Fig.~\ref{fig:syntaxOpen} does not
%% need this distinction.
%% %
%% The current type variables $\METAtyvar$ are renamed flexible,
%% and we add rigid type variables $\METArigtyvar$ which are associated to explicit type
%% variables in initial constraint generation.
%% %
%% We also add polymorphic environment schemes that quantify
%% environments over type constructor variables.

%% \intitle{Functors.}
%% We add internal functors and intersection type
%% schemes of the form
%% $\CONSinter{\METAscheme_0}{\CONSinter{\cdots}{\METAscheme_n}}$ which
%% occur in $\METAid$ binders where
%% $\METAscheme_0$ is the type scheme for $\METAid$'s binding
%% occurrence and $\METAscheme_1,\dots,\METAscheme_n$ represent
%% $\METAid$'s accessors' types.
%% %
%% Intersection types allow giving more type error explanations.
%% %
%% %% They allow constraining a binder with its accessors' types.

%% \intitle{Non-recursive value declarations.}
%% Ordinary \inexamplebody{val} declarations raise the polymorphic value
%% restriction issue.  We use environments which can turn into
%% $\CONStopolySYMB$ environments dependent on
%% ``expansiveness''~\cite{Milner+Tofte+Harper+Macqueen:1997} conditions
%% represented as dependency sets computed in initial
%% constraint generation.

%% \intitle{Type annotations.}
%% We introduce unconfirmed type variable binders of
%% the form $\CONSbindu{\METAtypevar}{\METArigtyvar}$ because in, e.g.,
%% \inexamplebody{val rec f = fn x : 'a => x} the explicit type variable
%% \inexamplebody{'a} is implicitly bound at the \inexamplebody{val} if the
%% declaration is not in a larger expression where
%% \inexamplebody{'a} occurs unbound.
%% Unconfirmed type variable bindings can
%% be confirmed as binders or discarded (but cannot become accessors).
%% %% That's why we should maybe use other syntactic forms...
%% We also add disjunctive dependencies, because
%% in the core in an environment
%% $\CONSdepss{\METAcsenv}{\METAcdepset}$, the set $\METAcdepset$ is a
%% conjunction of dependencies.
%% Disjunctive dependencies handle implicit bindings of explicit type variables.  For
%% example in \inexamplebody{val rec f = fn x : 'a => fn y : 'a => x}, if
%% this does not occur in a larger expression where
%% \inexamplebody{'a} occurs free then \inexamplebody{'a} is implicitly
%% bound at the \inexamplebody{val}.  There are two reasons for
%% \inexamplebody{'a} to be implicitly bound: \inexamplebody{'a}'s two
%% occurrences.
%% Only one is needed for the binding to exist: thus disjunction
%% dependencies.

%% \intitle{Non-unary type constructors.}
%% We add internal type and type variable sequences which can be,
%% following our principles, variable and dependent forms.







\section{Related work}
\label{sec:allrelatedwork}


\subsection{Related work on constraint systems}
\label{sec:relatedworkconstraintsystems}
\label{sec:comparisonsConSys}
\label{sec:relatedworkconstraintsystem}



%% \subsubsection{Constraint based type inference algorithm}


%% Milner~\cite{Milner:1978} proved the soundness of the semantics of a
%% small language (application, abstraction, conditional, recursion,
%% local declaration) w.r.t.\ a typing relation.  We refer to this
%% language in this document as \COREML.  This result allows Milner to
%% state that the well typed property is enough to prove the well-defined
%% behaviour of pieces of code, for a certain notion of behaviour.
%% %
%% Milner's method is based on three steps.  First he provides a
%% denotational semantics of his language.
%% Milner defines \emph{wrong} as a value in his denotational semantics.
%% Milner points out that \emph{wrong} ``corresponds to the detection of
%% a failure at run-time'' where in his language ``the only failures are
%% the occurrences of a non-Boolean value as a condition of a
%% conditional, and the occurrence of a nonfunctional value as the
%% operator of an application''\footnote{Milner's theorem is well known under
%%   the slogan ``well-typed expressions do not go wrong'' where wrong is
%%   a value of his semantics with which no type can be associated.}.
%% %
%% This semantics allows one to check some type constraints such as: the
%% first parameter of a conditional expression has to be a Boolean.
%% However, this semantics does not allow one to check some other
%% constraints such as: the two branches of a conditional must have the
%% same type.
%% %
%% The second step of Milner's method consists in defining types and a
%% typing relation between the values of his semantics and types to
%% ensure the consistency of the typing of an expression, meaning that,
%% e.g., a function cannot sometimes return a Boolean and sometimes
%% return an integer when applied to, say, an integer.  Milner provides
%% an example of values that do not have types (such as the value wrong).
%% One of them can be explained as follows: the value (semantics) of the
%% function ``$\CONSlambda{x}{\mbox{if }x\mbox{ then 1 else true}}$''
%% does not have any type.
%% %
%% The third step of Milner's method is to define a type assignment
%% system that assigns types to expressions.
%% %
%% Finally, Milner's soundness results expresses that if a type can be
%% assigned to an expression (if the expression is well-typed) then this
%% type can also be assigned to the semantics of the expression (so the
%% semantics of the expression cannot be the \emph{wrong} value).
%% %
%% An interesting aspect in Milner's paper is that when giving an
%% informal presentation of his type inference algorithm (\walgo) he
%% separates constraint generation and constraint solving (these
%% % two processes
%% are interleaved in the \walgo\ algorithm which leads to
%% the well-known left-to-right bias).

%% \mynote{2009-01-27}{Completeness does not hold.  For example,
%%   $(\lambda x. \lambda y. \mbox{if }x\mbox{ then not }y\mbox{ else
%%     succ }y)\mbox{ true true}$ possesses a type but is not well typed
%%   (or $(\lambda x. \mbox{if }x\mbox{ then true else }1)\mbox{ true}$).
%%   But these example cannot behave badly when $\lambda y. \mbox{if
%%   }(\mbox{if }y\mbox{ then true else }1)\mbox{ then }e_1\mbox{ else
%%   }e_2$ can.}


%% Aiken~\cite{Aiken:1999} provides three reasons in favour of
%% constraint-based program analyses (even though Aiken does not restrict
%% himself to type constraints and to the type inference problem we
%% provide our understanding of the advantages Aiken describes in the
%% context of type inference).
%% %
%% (1)~``Constraints separate specification from implementation''.  This
%% says that one obtains a clear separation between constraint generation
%% and constraint solving where the constraint generation phase is
%% regarded as producing a specification of the information that one
%% wishes to analyse, and where the constraint solving phase is regarded
%% as the implementation to compute this information.
%% %
%% (2)~``Constraints yield natural specifications''.  This says that each
%% analysed piece of syntax is usually translated into (local) primitive
%% constraints, each expressing a particular feature of the analysed
%% piece of syntax.  Moreover, let us add that in many constraint systems
%% (see below for examples of such systems), new forms of constraints are
%% sometimes introduced to deal with particular features of the analysed
%% language and to deal with them in a particular way, and these
%% constraints are usually used to translate more than one feature of the
%% analysed language.  Given a piece of code, the generated constraints
%% are packed in a way that gives a constraint representation of the
%% piece of code.
%% %
%% (3)~``Constraints enable sophisticated implementations''.  For
%% example, various constraint solvers extending the Martelli-Montanari
%% algorithm~\cite{Martelli+Montanari:1982} have been designed to define
%% different implementations.

%% As early as 1987, Wand~\cite{Wand:1987} introduced a constraint based
%% type inference algorithm for the simply typed $\lambda$-calculus to
%% provide an alternative proof of the decidability of the type inference
%% problem for the simply typed $\lambda$-calculus.  Wand reduced the
%% type inference problem to a unification problem by first converting
%% $\lambda$-terms into constraint sets and by then solving the
%% constraints.  Wand's system is simple, he does not consider
%% polymorphism and his constraints are only equality constraints (the
%% only constraints required in his setting).  His constraint generation
%% algorithm is based on a type environment that associates types (type
%% variables) with identifiers.

%% Henglein~\cite{Henglein:1988} considers the type inference problem for
%% two calculi: the Milner calculus~\cite{Milner:1978,Damas+Milner:1982}
%% and the Milner-Mycroft calculus~\cite{Mycroft:1984}.  As in the
%% original systems, the considered languages contain a fixpoint operator
%% and a non-recursive ``let'' construct (the two calculi differ on the
%% semantics of the fixpoint operator which only allows monomorphic
%% recursion in the Milner calculus and polymorphic recursion in the
%% Milner-Mycroft calculus).  Henglein formulates the type inference
%% problem in these calculi using a constraint based approach.  First
%% equality and inequality constraints are generated.  Inequalities are
%% used to deal with polymorphism (to encode type schemes) and therefore
%% to enforce the monomorphism of $\lambda$-bindings
%% (\inexamplebody{fn}-bindings in \SML).  For example, using \SML's
%% syntax, in
%% \inexamplebody{fn z => let val rec f = fn x => z x in (f (), f true) end},
%% \inexamplebody{f}'s first occurrence binds both \inexamplebody{f}'s
%% second and third occurrences.  For each of the bindings, Henglein
%% generates inequalities on \inexamplebody{z}'s (monomorphic) type which
%% eventually lead to an error because through the generated equality and
%% inequality constraints, \inexamplebody{z}'s type is constrained to be
%% both a function that takes a \inexamplebody{unit} (thanks to a first
%% inequality set generated for the binding of \inexamplebody{f}'s
%% second occurrence to \inexamplebody{f}'s first occurrence) and a
%% \inexamplebody{bool} (thanks to a second inequality set generated
%% for the binding of \inexamplebody{f}'s third occurrence to
%% \inexamplebody{f}'s first occurrence).
%% %
%% Then, Henglein presents how to compute most general semi-unifiers from
%% equality and inequality constraints.  Unfortunately, Henglein's
%% algorithm, based on semi-unification, is undecidable in the general
%% case~\cite{Kfoury+Tiuryn+Urzyczyn:1990,Henglein:1993}.


%% Kanellakis, Mairson and
%% Mitchell~\cite{Kanellakis+Mairson+Mitchell:1990} consider the same
%% algorithm as Wand~\cite{Wand:1987}.  They propose a type inference
%% (they instead use the terminology
%% %% ``because type inference is also used ambiguously to denote the
%% %% process of ``type derivation'' via inference rules''
%% ``type reconstruction'') algorithm for the $\lambda$-calculus
%% extended with polymorphic (non-recursive) let-expressions (\COREML)
%% which consists of reducing an expression to a let-free expression (by
%% reducing all the let-expressions) and then use Wand's algorithm on the
%% obtained $\lambda$-expression.
%% %
%% This algorithm, obviously inefficient in practice, intuitively gives
%% the DEXPTIME-completeness of the type inference problem for \COREML.
%% % But apparently McAllester proved it to be linear in
%% % practice~\cite{McAllester:2002} give type schemes and the
%% % left-nesting of let constructs are bound.


%% Pottier~\cite{Pottier:1996} defines a type system which is based on,
%% among other things, constrained types, which are types depending on
%% subtyping constraints.  These forms are not allowed in types but only
%% in type schemes and in type judgements (a constrained type is a
%% component of a type judgement).  The language considered by Pottier is
%% a \COREML-like language with (non-recursive) let-polymorphic
%% expressions and subtyping.
%% %
%% Pottier's system is based on a similar system by Eifrig, Smith and
%% Trifnov~\cite{Eifrig+Smith+Trifonov:1994} (they use a notion of
%% \emph{recursively constrained type} which is a type constrained by a
%% set of inequality constraints which can themselves be recursive).
%% %
%% Pottier mentions that Eifrig, Smith and Trifnov's system, ``although
%% theoretically correct, depends on type simplification in order to be
%% usable in practice'' (this is due to the fact that their polymorphic
%% variable rule duplicates the constraints generated for polymorphic
%% values without simplifying them first).
%% %
%% Pottier's solution to avoid a combinatorial explosion in the number of
%% constraints is to allow the simplification of constraints during
%% constraint generation.  Moreover, Pottier does not use a notion
%% of solvability of generated constraints but instead uses a notion of
%% consistency.  With the notion of consistency, no ``solution'' of a
%% constraint set is computed\footnote{Eifrig, Smith and
%% Trifnov~\cite{Eifrig+Smith+Trifonov:1994} write: ``we expect general
%% union and intersection types would be required to express the solution
%% of constraints as types, but we do not wish to pay the penalty of
%% having these types in our languages''.  The notion of consistency is
%% then expected to be simpler to deal with than the notion of
%% solvability.}.
%% % Is consistency similar to Palsberg's safety analysis?
%% Pottier proves that the notion of consistency is
%% equivalent to the notion of solvability.  He defines a notion of
%% entailment which is used by his substitution and subtyping rules.
%% %
%% An issue with Pottier's approach is that, as in many other approaches,
%% to avoid constraint duplication, constraint generation and constraint
%% solving are mixed.
%% %% Pottier deals with polymorphism but an issue in his system is that it
%% %% involves constraint duplication and instantiation when analysing bound
%% %% occurrences of identifiers and when analysing polymorphic
%% %% let-bindings.
%% % The algorithm that checks the entailment relation is incomplete.
%% %% Is there really a clear distinction between constraint generation
%% %% and constraint solving?!



%% Sulzmann, Odersky and Wehr~\cite{Odersky+Sulzmann+Wehr:1999} define a
%% generic type inference algorithm for the HM(X) system.
%% This system is a ``general framework for Hindley/Milner style type
%% systems with constraints''.  Sulzmann, Odersky and Wehr say about
%% their system that ``particular type systems can be obtained by
%% instantiating the parameter X to a specific constraint system'' and
%% that ``the Hindley/Milner system itself is obtained by instantiating X
%% to the trivial constraint system'' (the standard Herbrand constraint
%% system).
%% %
%% % Constraint solving is dependent on X.
%% %
%% They also extend their framework with subtyping.
%% % They consider the Milner calculus with no fixpoint operator.
%% Their type inference algorithm mixes constraint generation and
%% constraint solving.  Constraint solving is performed via a
%% ``normalization'' function.
%% Each time an already generated constraint is extended with a new
%% constraint (constraints are packed together via a conjunction operator
%% which can be seen as the union operator in their context), the
%% extended constraint is normalised.
%% %
%% % Normalisation extends the concept of unification.
%% %
%% Type schemes in their system can either be monomorphic types or
%% constrained type schemes of the form
%% $\CONSOSWscheme{\METAOSWtyvarset}{\METAOSWcs}{\METAOSWscheme}$ where
%% $\METAOSWtyvarset$ is a type variable set, $\METAOSWcs$ is a
%% constraint and $\METAOSWscheme$ is a type scheme (similar forms are
%% used by, e.g., Eifrig, Smith, and
%% Trifonov~\cite{Eifrig+Smith+Trifonov:1994},
%% Pottier~\cite{Pottier:1996},
%% or Duggan~\cite{Duggan:1998}).
%% Because of the way normalisation is used, during type
%% inference, the constraints of the generated type schemes are already
%% simplified.
%% %
%% Sulzmann~\cite{Sulzmann:2000} calls such a use of normalisation, an
%% \emph{eager} use.  Sulzmann~\cite{Sulzmann:2000} defines variants of
%% the generic type inference mentioned above where normalisation is only
%% used before inferring the type of let-expression's bodies and at the
%% end of the type inference process only.  This is achieved by defining
%% an extra rule (and relation) that normalises constraints and which is
%% to be used when needed (such a use of normalisation is called \emph{by
%%   need}).  In their system, normalisation is required before inferring
%% the type of let-expression's bodies because using normalisation only
%% at the end of the type inference process leads to the separation of
%% the constraint generation and the constraint solving phases but also
%% to an inefficient type inference algorithm.
%% %
%% Sulzmann, Muller and
%% Zenger~\cite{Sulzmann+Muller+Zenger:1999,Sulzmann:2000}
%% present a variant of the inference algorithm mentioned above where
%% constraints are preferred over terms.
%% % Sulzmann, Muller and Zenger~\cite{Sulzmann+Muller+Zenger:1999}
%% % claim that using constraints affect the expressiveness of type
%% % systems because ill-typed program can then be represented by
%% % unsolvable constraints.
%% % So, if I understand correctly:
%% For example, informally, constraint-based
%% systems are more expressive because one can devise a simple constraint
%% language and a simple constraint generation algorithm that associates
%% the constrained type
%% $\mytuple{
%%   \{
%%   \csou{\METAtyvar_1}{\METAlabtyarrowp{\METAtyvar_2}{\METAtyvar}{}},
%%   \csou{\METAtyvar_1}{\mbox{\inexamplebody{int}}},
%%   \csou{\METAtyvar_2}{\mbox{\inexamplebody{int}}}
%%   \},
%%   \METAtyvar
%% }$
%% (where, using our notation, the first component of the pair is a
%% constraint set that constrains the second component of the pair which
%% is a type variable)
%% with the application \inexamplebody{(1 1)}.  However, for this
%% expression to be typable, one needs more complex type constructors
%% such as the ones used by Neubauer and Thiemann~\cite{Neubauer+Thiermann:2003}.
%% %
%% Also, because Sulzmann, Muller and Zenger's type inference algorithm
%% is not based on substitutions anymore (but on constraints), they
%% obtain simpler results (e.g., their completeness of inference) than
%% with Sulzmann, Odersky and Wehr's
%% system~\cite{Odersky+Sulzmann+Wehr:1999}.
%% %
%% M\"{u}ller~\cite{Muller:1998} claims that an advantage of HM(X) is
%% that ``it provide generic proofs of correctness, principality, and
%% completeness of type inference''.

%% We discuss other constrained based systems below, by Hage and
%% Heeren~\cite{Heeren:2005,Heeren+Hage+Swierstra:2003a,Hage+Heeren:2005a,Hage+Heeren:2009},
%% by M\"{u}ller~\cite{Muller:1994}, by Gustavsson and
%% Svenningsson~\cite{Gustavsson+Svenningsson:2001}, and by Pottier and
%% R\'emy~\cite{Pottier+Remy:2005,Pottier:2005}.





%% % Discuss~\cite{Heeren+Hage+Swierstra:2003b}?
%% % Discuss~\cite{Pottier:1999}?

%% %\end{itemize}


%% %Discuss~\cite{Tofte+Taplin:1994}
%% %Discuss~\cite{Remy:1989}




%% \subsubsection{Constrained types}
%% \label{sec:constrainedtypes}


%% Pottier defines a system~\cite{Pottier:1996}, similar to the one used
%% by Eifrig, Smith and Trifonov~\cite{Eifrig+Smith+Trifonov:1994}, that
%% uses constrained types of the form
%% $\CONSPOconstype{\METAPOtype}{\METAPOcsset}$, where $\METAPOtype$ is a
%% type and $\METAPOcsset$ is a (subtyping) constraint set.  These forms
%% are not allowed in types but only in type judgements and in type
%% schemes which are of the following form:
%% $\CONSPOscheme{\METAPOtyvarset}{\CONSPOconstype{\METAPOtype}{\METAPOcsset}}$
%% (similar to those used by Pottier and R\'emy~\cite{Pottier+Remy:2005})
%% where $\METAPOtyvarset$ is a set of type variables.
%% %
%% As opposed to other
%% systems~\cite{Odersky+Sulzmann+Wehr:1999,Kaes:1992}, Pottier allows
%% constrained types in typing judgement because in his system a typing
%% judgement is of the form
%% $\CONSPOjudgement{\METAPOenv}{\METAPOexp}{\CONSPOconstype{\METAPOtype}{\METAPOcsset}}$
%% where $\METAPOenv$ is a type environment and $\METAPOexp$ is an
%% expression of the external syntax.

%% Odersky, Sulzmann and Wehr~\cite{Odersky+Sulzmann+Wehr:1999} and
%% Kaes~\cite{Kaes:1992} also consider constrained types in their type
%% schemes.  However, because they use a different presentation style of
%% their constraint generation algorithm, constrained types are not
%% allowed in type judgements (a constrained type is not a component of a
%% type judgement).  Instead of writing
%% $\CONSPOjudgement{\METAPOenv}{\METAPOexp}{\CONSPOconstype{\METAPOtype}{\METAPOcsset}}$
%% (using Pottier's syntax) they would write such a typing judgement as
%% follows:
%% $\CONSPOjudgementb{\METAPOenv}{\METAPOexp}{\METAPOtype}{\METAPOcsset}$
%% where $\METAPOcsset$ also constrains $\METAPOtype$ but where such a
%% constrained form is not explicitly defined.


%% %Discuss~\cite{Palsberg:1995}


%% %% Aiken and Wimmers~\cite{Aiken+Wimmers:1993} also use constrained type
%% %% schemes.
%% %% % Is a type scheme a type?
%% %% % Why are the constraint sets in the premises of the let rule the same?

%% In our constraint system, types can only be constrained via equality
%% constraints as in the following environment:
%% $\CONSenvenv{(\csou{\METAlabty_1}{\METAlabty_2})}{\METAcsenv}$ where
%% both $\METAlabty_1$ and $\METAlabty_2$ are constrained by the
%% environment $\METAcsenv$.  For example, our constraint generation
%% rule~$\MEMgencgrulec$ for expression applications generates an
%% environment of the form
%% $\CONSenvenv
%% {\CONSenvenv
%%   {(\cso{\METAtyvar_1}{\METAlabtyarrowp{\METAtyvar_2}{\METAtyvar}{}}{\METAlab})}
%%   {\METAcsenv_2}
%% }
%% {\METAcsenv_1}$
%% where $\METAcsenv_1$ and $\METAtyvar_1$ are generated for the function
%% part of the application, and where $\METAcsenv_2$ and $\METAtyvar_2$
%% are generated for the argument part of the application.
%% In this environment, both $\METAcsenv_1$ and $\METAcsenv_2$ constrain
%% both $\METAtyvar_1$ and $\METAtyvar_2$ even though $\METAtyvar_1$ only
%% depends on $\METAcsenv_1$ and $\METAtyvar_2$ only depends on
%% $\METAcsenv_2$.  We could then imagine a constraint system where we
%% allow constrained types to be types.  Constrained types could be of
%% the form $(\CONSenvenv{\METAlabty}{\METAcsenv})$.  This would allow
%% one to generate instead, for expression applications, an environment
%% of the form
%% $\cso
%% {(\CONSenvenv{\METAtyvar_1}{\METAcsenv_1})}
%% {\METAlabtyarrowp
%%   {(\CONSenvenv{\METAtyvar_2}{\METAcsenv_2})}
%%   {\METAtyvar}
%%   {}
%% }
%% {\METAlab}$.
%% The drawback of such a system is that types are not shallow anymore
%% which complicates constraint filtering and solving.



%\item Discuss \cite{Chitil:2001}

\subsubsection{Comparison with Haack and Wells' constraint system}



The method of Haack and Wells (\HWTES) makes use of intersection
types.
%
A type $\METAHWty$ in \HWTES\ can either be a type variable, the
integer type or an arrow type.  A type set is denoted by
$\METAHWtyset$.  An intersection type is denoted
$\CONSHWinter{\METAHWtyset}$.
%
\HWTES' constraint generation algorithm gathers the types of bound
occurrences of identifiers in type environments which associate
intersection types with identifiers.

Let us consider the following simple piece of code:
%
\inexamplebody{x x}.
%
Given this piece of code, \HWTES\ generates the triple
$\mytuple{\METAHWtyenv_{x},\METAHWtyvar_{x},\METAHWcsset_{x}}$, where
the type environments $\METAHWtyenv_{x}$, the type variable
$\METAHWtyvar_{5}$, and the constraint set $\METAHWcsset_{x}$ are
described below.  First, the type environment $\METAHWtyenv_{x}$ is of
the form
$\{\asgn{\mbox{\inexamplebody{x}}}{\CONSHWinter{\{\METAHWtyvar_{1},\METAHWtyvar_{2}\}}}\}$\footnote{Environments
  in \HWTES\ are total functions from identifiers to intersection
  types.  Therefore, the environment
  $\{\asgn{\mbox{\inexamplebody{x}}}{\CONSHWinter{\{\METAHWtyvar_{1},\METAHWtyvar_{2}\}}}\}$
  denotes the total function that associates
  $\CONSHWinter{\{\METAHWtyvar_{1},\METAHWtyvar_{2}\}}$ with
  $\mbox{\inexamplebody{x}}$ and that associates $\CONSHWinter{\{\}}$
  with any identifier different from $\mbox{\inexamplebody{x}}$.}  where
$\METAHWtyvar_{1}\not=\METAHWtyvar_{2}$, $\METAHWtyvar_{1}$ is a type
variable generated for \inexamplebody{x}'s first occurrence, and
$\METAHWtyvar_{2}$ is a type variable generated for \inexamplebody{x}'s
second occurrence.  The constraint set $\METAHWcsset_{x}$ contains,
among other things, constraints on $\METAHWtyvar_{1}$ and
$\METAHWtyvar_{2}$, and is of the following form:
$\{
\cso{\METAHWtyvar_{1}}{\METAHWtyvar'_{1}}{\METAlab_{1}},
\cso{\METAHWtyvar_{2}}{\METAHWtyvar'_{2}}{\METAlab_{2}},
\cso{\METAHWtyvar'_{1}}{\CONSarrowty{\METAHWtyvar_{3}}{\METAHWtyvar_{4}}}{\METAlab_{3}},
\cso{\METAHWtyvar'_{2}}{\METAHWtyvar_{3}}{\METAlab_{3}},
\cso{\METAHWtyvar_{\mbox{\inexamplebody{x}}}}{\METAHWtyvar_{4}}{\METAlab_{3}}
\}$ where
$\METAlab_{1}$ is \inexamplebody{x}'s first occurrence's label,
$\METAlab_{2}$ is \inexamplebody{x}'s second occurrence's label, and
$\METAlab_{3}$ is the label associated with the application.
%% TODO: give the constraint.
%
%
%% The term $\wedge\{\METAHWtyvar_1,\METAHWtyvar_2\}$ is an intersection
%% type.

Let us now consider a monomorphic binding of these two occurrences of
\inexamplebody{x}.  Let \inexamplebody{x} be bound via a monomorphic
\inexamplebody{fn}-binding as follows:
%
\inexamplebody{fn x => x x}.
%
Given this piece of code, \HWTES' constraint generation algorithm
generates the triple
$\mytuple{\METAHWtyenv_{m},\METAHWtyvar_{m},\METAHWcsset_{m}}$ (where
``m'' stands for ``monomorphic'').
The type environment $\METAHWtyenv_{m}$ is $\emptyset$ and
$\METAHWcsset_{m}$ is of the following form:
$\METAHWcsset_{x}
\cup
\{
\cso{\METAHWtyvar}{\METAHWtyvar_1}{\METAlab},
\cso{\METAHWtyvar}{\METAHWtyvar_2}{\METAlab},
\cso{\CONSarrowty{\METAHWtyvar}{\METAHWtyvar_{x}}}{\METAHWtyvar_{m}}{\METAlab}
\}$,
where $\METAlab$ is the label labelling the
\inexamplebody{fn}-expression, and where $\METAHWtyvar_1$ and
$\METAHWtyvar_2$ are obtained from $\METAHWtyenv_{x}$.

Let us now consider the polymorphic case.
%
First, assume that given \inexamplebody{fn y => z y}
(this piece of code is reused in the let-expression presented below),
where
\inexamplebody{z} is a free variable, \HWTES' constraint generation
algorithm generates the following triple:
$\mytuple{\METAHWtyenv_{z},\METAHWtyvar_{z},\METAHWcsset_{z}}$.
%
The type environment $\METAHWtyenv_{z}$ is of the form
$\{\asgn{\mbox{\inexamplebody{z}}}{\CONSHWinter{\{\METAHWtyvar_{5}\}}}\}$.
%
Let us now consider the following polymorphic let-binding of \inexamplebody{x}:
%
\inexamplebody{let val x = fn y => z y in x x end}.
%
%% \HWTES' constraint generation algorithm generates the
%% following triple for \inexamplebody{y y}:
%% $\mytuple{\METAHWtyenv_0,\METAHWtyvar_0,\METAHWcsset_0}$, where
%% $\METAHWtyenv_0=\{\asgn{\mbox{\inexamplebody{y}}}{\CONSHWinter{\{\METAHWtyvar_1,\METAHWtyvar_2\}}}\}$
%% and $\METAHWtyvar_1\not=\METAHWtyvar_2$.
Now, because $\METAHWtyenv_{x}$ (defined above) associates two type
variables with \inexamplebody{x}, \HWTES' constraint generation
algorithm generates two ``fresh'' copies of
$\mytuple{\METAHWtyenv_{z},\METAHWtyvar_{z},\METAHWcsset_{z}}$ namely
$\mytuple{\METAHWtyenv'_{z},\METAHWtyvar'_{z},\METAHWcsset'_{z}}$ and
$\mytuple{\METAHWtyenv''_{z},\METAHWtyvar''_{z},\METAHWcsset''_{z}}$.
%
The type environments $\METAHWtyenv'_{z}$ and $\METAHWtyenv''_{z}$ are
of the form
$\{\asgn{\mbox{\inexamplebody{z}}}{\CONSHWinter{\{\METAHWtyvar'_{5}\}}}\}$
and
$\{\asgn{\mbox{\inexamplebody{z}}}{\CONSHWinter{\{\METAHWtyvar''_{5}\}}}\}$
respectively.
%
It finally generates the following triple for the entire
let-expression:
$\mytuple{
  \CONSHWinterenv{\METAHWtyenv'_{z}}{\METAHWtyenv''_{z}},
  \METAHWtyvar',
  \METAHWcsset_{x}
  \cup
  \METAHWcsset'_{z}
  \cup
  \METAHWcsset''_{z}
  \cup
  \{\cso{\METAHWtyvar'_{z}}{\METAHWtyvar_1}{\METAlab},
  \cso{\METAHWtyvar''_{z}}{\METAHWtyvar_2}{\METAlab},
  \cso{\METAHWtyvar'}{\METAHWtyvar_{x}}{\METAlab}\}
}$
where $\METAlab$ is the label labelling the let-expression,
where $\METAHWtyvar_1$ and $\METAHWtyvar_2$ are obtained from
$\METAHWtyenv_{x}$,
and where
$\CONSHWinterenv{\METAHWtyenv'_{z}}{\METAHWtyenv''_{z}}
=
\{\asgn{x}{\CONSHWinter{\METAHWtyset_1\cup\METAHWtyset_2}}
\mid
\afunc{\METAHWtyenv'_{z}}{x}=\CONSHWinter{\METAHWtyset_1}
\wedge
\afunc{\METAHWtyenv''_{z}}{x}=\CONSHWinter{\METAHWtyset_2}\}
=
\{\asgn{\mbox{\inexamplebody{z}}}{\CONSHWinter{\{\METAHWtyvar'_{5},\METAHWtyvar''_{5}\}}}\}$
($x$ is Haack and Wells' notation for program variables).
Note that polymorphism involves heavy constraint and type environment
duplications which leads to a combinatorial constraint size explosion
at constraint generation.
%  This is discussed further below.



\subsubsection{Comparison with Hage and Heeren's constraint system}


The approach followed by Hage and
Heeren~\cite{Heeren:2005,Heeren+Hage+Swierstra:2003a,Hage+Heeren:2005a,Hage+Heeren:2009}
is as follows: given a piece of code, first a constraint tree is
generated, then this constraint tree is converted into a list (many
conversions are possible which result in different lists), and finally
the constraints are solved.  Because different conversions of trees
into lists are allowed, their system allows them to emulate algorithms
such as \walgo~\cite{Damas+Milner:1982}, \malgo~\cite{Lee+Yi:1998} or
\uaealgo~\cite{Yang:2000}.
%

In their system, a constraint tree can among other things (we only
present some of their constructs), be a strict node as follows:
$\CONSHHstrictnode{\METAHHtree_1}{\METAHHtree_2}$ where
$\METAHHtree_1$ and $\METAHHtree_2$ are constraint trees.  A
constraint can be attached to a tree using for example the following
construct: $\CONSHHattachcs{\METAHHcs}{\METAHHtree}$, which makes the
constraint $\METAcs$ ``part of the constraint associated with the root
of $\METAHHtree$''~\cite{Hage+Heeren:2009}.  A tree can also pack
together trees as follows:
$\CONSHHtreepackn{\METAHHtree_1}{\METAHHtree_n}$.  A constraint itself
can among other things be: an equality constraint
$\CONSHHcseq{\METAHHty_1}{\METAHHty_2}$, a generalisation constraint
$\CONSHHcsgen{\METAHHscheme}{\METAHHtyvarset}{\METAHHty}$ where
$\METAHHtyvarset$ is a (monomorphic) type variable set and
$\METAHHscheme$ is a scheme variable, or a instantiation constraint
$\CONSHHcsins{\METAHHty}{\METAHHscheme}$.  Hage and
Heeren~\cite{Hage+Heeren:2009} say about their generalisation and
instantiation constraints: ``The reason we have constraints to
explicitly represent generalization and instantiation is the same as
why, e.g., Pottier and R\'emy do~\cite{Pottier+Remy:2005}: otherwise
we would be forced to (make a fresh) duplicate of the set of
constraints every single time we use a polymorphically defined
identifier''.
%

Their equality types are similar to ours.  Their generalisation
constraints are related to $\CONStopolySYMB$ environments but are
restricted to types.  Another difference is that the monomorphic type
variable set that are not allowed to be quantified over when
generating a type scheme is part of a generalisation constraint in
their system while in our system, such a set is computed at constraint
solving.  Their instantiation constraints are related to our accessors
but they do not mention external syntax (external identifiers) and do
not have identifier bindings in their constraint language.
%

Trees in their system can be regarded as sophisticated constraints.
They are used to provide extra structure on constraint sets.
%% Our environments also allow ordering
%% constraints via the sequence environments of the form
%% $\CONSenvenv{\METAcsenv_2}{\METAcsenv_1}$.
%
In our system a single equality constraint can be an environment.
Similarly, in their system a single constraint can be a tree.
%
Their strict nodes of the form
$\CONSHHstrictnode{\METAHHtree_1}{\METAHHtree_2}$ can be seen as a
restricted version of our \COMPENVS\ of the form
$\CONSenvenv{\METAcsenv_2}{\METAcsenv_1}$.  Environments of the form
$\CONSenvenv{\METAcsenv_2}{\METAcsenv_1}$ also enforce $\METAcsenv_1$
to be solved before $\METAcsenv_2$.  A major difference is that in our
system, not only in an environment
$\CONSenvenv{\METAcsenv_2}{\METAcsenv_1}$, the environment
$\METAcsenv_1$ has to be solved before $\METAcsenv_2$ but also
$\METAcsenv_2$ looks up in $\METAcsenv_1$ to access binders.
%
Also a major difference between trees and constraint/environments is
that in their system trees do not act as environments, they do not
allow one to associate static semantics with identifiers.
%
We do not allow non-strict nodes (such as their nodes of the form
$\CONSHHtreepackn{\METAHHtree_1}{\METAHHtree_n}$) because our system
does not rearrange the order in which constraints are initially
generated.
%
Their constraint rearrangement mechanism can be seen as a
restriction of our enumeration algorithm.

Enforcing to solve constraints before other introduces a bias.  Our
\TES\ is unbiased thanks to our enumeration algorithm which, given an
environment $\METAcsenv$, run our constraint solver on the different
environments that can be obtain from $\METAcsenv$ using our filtering
function.  We believe that Hage and Heeren only partially remove the
bias thanks to their ordering strategies.

The main difference between their transformation of a type inference
problem into a constraint solving problem and ours (and so the main
difference between their constraint system and our constraint system)
is that we also encode the bindings of identifiers into our constraint
system.  Bindings of identifiers are solved at constraint solving in
our system while they are solved at constraint generation in Hage and
Heeren's system.  We do so thanks to our binders and accessors.  We
moved from a binding resolution at initial constraint generation to a
binding resolution at constraint solving in order to handle \SML\
features such as the \inexamplebody{open} feature.  Thanks to our binders and
accessors, we can generate a ``faithful'' representation of a \SML\
program, that uses intricate features such as \inexamplebody{open}, into our
constraint language.

Moreover, we believe that in addition to the motivation of generating
``faithful'' representations of \SML\ programs in our constraint
language, binders and accessors are necessary to distinctly separate
the constraint generation and constraint solving phases of a
constraint based type inference algorithm for \SML.  To illustrate this
point let us consider the following typable \SML\ program:

\examplebody{
\Bl
structure S = struct val c = fn () => () end
\\
structure T = S
\\
structure U = T
\\
open U
\\
val d = c ()
\El
}

Without binders and accessors, one needs to use type environments at
constraint generation to be able to access identifiers' static
semantics when analysing identifiers at bound positions.  At
constraint generation, in order to be able to generate a proper
environment for the declaration \inexamplebody{open U} so that it can
be used when dealing with the declaration \inexamplebody{val d = c
  ()}, one needs to resolve the chain of structure equalities.  This
means that solving structures' static semantics at constraint
generation becomes necessary which goes against a clear separation
between constraint generation (generation of constraints on the static
semantics of the analysed piece of code) and constraint solving.

The necessity of having bindings solved at constraint solving rather
than at constraint generation is also motivated by the will of having
a compositional constraint generation algorithm while dealing with the
inherent identifier status ambiguity in \SML\ which is dealt with in
Sec.~\ref{sec:idstatuses}.
%
Here we anticipate Sec.~\ref{sec:idstatuses} where unconfirmed binders
of the form $\CONSbindu{\METAid}{\METAtyvar}$ are introduced to deal
with \SML's identifier status ambiguity.  When initially generated,
such unconfirmed binders are neither binders nor accessors but lie
between the two.
%
As a matted of fact, for a piece of code such as
\inexamplebody{fn x => fn c => x c}, from Sec.~\ref{sec:idstatuses}
on, the binders generated for
\inexamplebody{x} and \inexamplebody{c} are unconfirmed binders and the
static semantics of \inexamplebody{x}'s second occurrence does not
depend on the static semantics of \inexamplebody{x}'s first occurrence
until the unconfirmed binder generated for \inexamplebody{x} is turned
into a confirmed one
(and similarly for \inexamplebody{c}).  If it turns out at constraint
solving that, e.g., \inexamplebody{c} is a datatype constructor then
\inexamplebody{c}'s unconfirmed binder is turned into an accessor.
Otherwise \inexamplebody{c}'s unconfirmed
binder turns into a dependent or independent (on \inexamplebody{c}'s
status) confirmed binder (still at constraint solving only and not at
constraint generation).
%
Note that a similar argument holds about \inexamplebody{open}
declarations.
%
Compositionality is further discussed in
Sec.~\ref{sec:compositionality}.



\subsubsection{Comparison with M\"{u}ller's constraint system}


M\"{u}ller~\cite{Muller:1994} defines the \emph{relational calculus}
$\METAMUcalculus$ to ``implement Damas-Milner polymorphic type
inference''.  This calculus allows one to generate constraints of
linear size.
%% because it allows simplifying the constraints generated for a
%% polymorphic let-binding (for a polymorphic declaration in general)
%% before accessing it.
It does that by generating identifier binders with which are
associated static semantics.  The semantics attached to an identifier
binder can then be simplified before being ``used'', i.e., before
instantiating the polymorphic type.
%
The language considered by M\"{u}ller is the $\lambda$-calculus
extended with polymorphic let-expressions (\COREML).  M\"{u}ller also
forces bound variables in $\lambda$-expressions to be ``pairwise
different and distinct from the free variables''.
%
His constraint language is a two layer language.  He first defines a
constraint set and then an expression set containing the constraint
set.
%
What M\"{u}ller calls an expression will sometimes be called a
constraint expression in this discussion when we need to distinguish
between a $\lambda$-expression (an external expression) and an
expression (an internal or constraint expression).  M\"{u}ller's
syntax of constraints and expressions is defined as follows:
\begin{center}
  \begin{\sizeintablesp}
    \begin{tabular}{lrl}
      $\METAMUcs,\METAMUcsb$
      & $::=$
      & $\CONSMUcstop
      \mid\CONSMUcsbot
      \mid\CONSMUex{\METAMUtyvara}{\METAMUcs}
      \mid\CONSMUand{\METAMUcs}{\METAMUcsb}
      \mid\CONSMUeqty{\METAMUtyvara}{\METAMUtyvarb}
      \mid\CONSMUeqty{\METAMUtyvara}{\CONSMUtyarrow{\METAMUtyvarb}{\METAMUtyvarc}}$
      \\

      $\METAMUexp,\METAMUexpb$
      & $::=$
      & $\METAMUcs
      \mid\CONSMUand{\METAMUexp}{\METAMUexpb}
      \mid\CONSMUex{\METAMUtyvara}{\METAMUexp}
      \mid\CONSMUabs{\METAMUid}{\METAMUtyvara}{\METAMUexp}
      \mid\CONSMUinterp{\METAMUlexp}{\METAMUtyvara}$
    \end{tabular}
  \end{\sizeintablesp}
\end{center}
where $\METAMUlexp$ is a $\lambda$-expression and $\METAMUtyvara$,
$\METAMUtyvarb$ and $\METAMUtyvarc$ are type variables.  The two
constant constraints are the satisfied constraint $\CONSMUcstop$ and
the unsatisfied constraint $\CONSMUcsbot$.  Constraints and
expressions of the forms $\CONSMUex{\METAMUtyvara}{\METAMUcs}$ and
$\CONSMUex{\METAMUtyvara}{\METAMUexp}$ introduce fresh variables.
Constraints and expressions of the form
$\CONSMUand{\METAMUcs}{\METAMUcsb}$ and
$\CONSMUand{\METAMUexp}{\METAMUexpb}$ are conjunctions.  The two last
forms of constraints are shallow equality constraints.

The most interesting forms in M\"{u}ller's constraint system are:
$\CONSMUabs{\METAMUid}{\METAMUtyvara}{\METAMUexp}$ and
$\CONSMUinterp{\METAMUlexp}{\METAMUtyvara}$.

An expression $\CONSMUabs{\METAMUid}{\METAMUtyvara}{\METAMUexp}$ is
called an \emph{abstraction} and associates the constrained static
semantics $\METAMUtyvara$, constrained by $\METAMUexp$, with the
identifier $\METAMUid$.
Such expressions are called abstractions because, e.g.,
$\CONSMUabs{\METAMUid}{\METAMUtyvara}{\METAMUexp}$
abstracts the type variable $\METAMUtyvara$.
%
The polymorphism of such forms comes from the fact that
expressions can be existential expressions.  If \inexamplebody{id} is
the polymorphic identity function, one can then generate the following
abstraction (binder) for \inexamplebody{id} (where some expressions
are omitted for clarity):
$\CONSMUabs
{\mbox{\inexamplebody{id}}}
{\METAMUtyvarc}
{\CONSMUex
  {\METAMUtyvarb}
  {\CONSMUeqty
    {\METAMUtyvarc}
    {\CONSMUtyarrow{\METAMUtyvarb}{\METAMUtyvarb}}
  }
}$.
Let us now assume a bound occurrence of \inexamplebody{id} with which is
associated the static semantics $\METAMUtyvara$.  One has then to
apply the abstraction generated for \inexamplebody{id} to
$\METAMUtyvara$ which results in
$\CONSMUex
{\METAMUtyvarb}
{\CONSMUeqty
  {\METAMUtyvara}
  {\CONSMUtyarrow{\METAMUtyvarb}{\METAMUtyvarb}}
}$.
A particularity of $\METAMUcalculus$ is that computations can occur
within the nested expression of an abstraction, which is within
$\METAMUexp$ in an abstraction of the form
$\CONSMUabs{\METAMUid}{\METAMUtyvara}{\METAMUexp}$.


Intuitively, we believe that an abstraction of the form
$\CONSMUabs{\METAMUid}{\METAMUtyvara}{\METAMUexp}$ would be
represented in our system by an environment of the form
$\CONStopoly{\CONSenvenv{\CONSbind{\METAMUid}{\METAtyvar}}{\METAcsenv}}$
where $\METAMUexp$ is represented by $\METAcsenv$.

Note that because of the restriction on free and bound variables,
M\"{u}ller does not need to define local constraints to restrict the
scope of abstractions.  Given such a restriction on the
$\lambda$-expressions, M\"{u}ller's inference algorithm cannot
generate two abstractions for the same identifier.


An expression of the form $\CONSMUinterp{\METAMUlexp}{\METAMUtyvara}$
is called a \emph{proof obligation} and it ``represent the constraint
$\CONSMUeqty{\METAMUtyvara}{\METAMUty}$  for the principal type
$\METAMUty$ of $\METAMUlexp$'', where $\METAMUty$ is an internal type
in M\"{u}ller's system.
%
A constraint expression of the form
$\CONSMUinterp{\METAMUlexp}{\METAMUtyvara}$ is used to analyse (infer
a type for) the lambda expression $\METAMUlexp$.

The constraint based type inference algorithm defined by M\"{u}ller
does not distinguish between constraint generation and constraint
solving and no specific constraint solving strategy is presented
(constraint generation and solving interleave).
%
Especially, it seems that M\"{u}ller's system does not enforce
simplifying the constraints generated for a polymorphic identifier
$\METAMUid$ before applying the abstraction generated for $\METAMUid$.
This can therefore lead to the exponential growth of the size of the
constraint expression generated for a $\lambda$-expression.  Let us
consider the following simple let-expression called $\METAMUlexp$
(where \inexamplebody{fn x => x} is written as
$\CONSMUlambda{\mbox{\inexamplebody{x}}}{\mbox{\inexamplebody{x}}}$
using M\"{u}ller's $\lambda$-expressions' syntax):

\examplebody{
\Bl
let id = fn x => x
\\
in let f = id id in f f end
\\
end
\El
}

Let $\METAMUlexp'$ be \inexamplebody{let f = id id in f f end}.
Fig.~\ref{fig:MUderiv} presents the inference of $\METAMUlexp$'type
using M\"{u}ller's type inference algorithm.  One can observe the
duplication of the constraint expression generated for
\inexamplebody{id}'s body.

\begin{\myfigure}[t]
  \begin{\sizeintables}
    \begin{tabular}{ll}
      & $\CONSMUinterp{\METAMUlexp}{\METAMUtyvara}$
      \\

      $\fra$
      & $\CONSMUand
      {\CONSMUand
        {\CONSMUinterp{\METAMUlexp'}{\METAMUtyvara}}
        {\METAMUexpb}
      }
      {\CONSMUabs
        {\mbox{\inexamplebody{id}}}
        {\METAMUtyvarc}
        {\METAMUexp}
      }$,
      where
      $\METAMUexp=\CONSMUinterp{\mbox{\inexamplebody{fn x => x}}}{\METAMUtyvarc}$
      and
      $\METAMUexpb=\CONSMUex{\METAMUtyvarb}{(\CONSMUinterp{\mbox{\inexamplebody{id}}}{\METAMUtyvarb})}$
      \\

      $\fra$
      & $\CONSMUand
      {\CONSMUand
        {\CONSMUand
          {\CONSMUand
            {\CONSMUinterp{\mbox{\inexamplebody{f f}}}{\METAMUtyvara}}
            {\METAMUexpb'}
          }
          {\CONSMUabs
            {\mbox{\inexamplebody{f}}}
            {\METAMUtyvarc'}
            {\CONSMUinterp{\mbox{\inexamplebody{id id}}}{\METAMUtyvarc'}}
          }
        }
        {\METAMUexpb}
      }
      {\CONSMUabs
        {\mbox{\inexamplebody{id}}}
        {\METAMUtyvarc}
        {\METAMUexp}
      }$,
      where
      $\METAMUexpb'=\CONSMUex{\METAMUtyvarb'}{(\CONSMUinterp{\mbox{\inexamplebody{f}}}{\METAMUtyvarb'})}$
      \\

      $\fra$
      & $\CONSMUand
      {\CONSMUand
        {\CONSMUand
          {\CONSMUand
            {(\CONSMUex
              {\METAMUtyvarb''}
              {\CONSMUex
                {\METAMUtyvarc''}
                {(\CONSMUand
                  {\CONSMUand
                    {\CONSMUinterp{\mbox{\inexamplebody{f}}}{\METAMUtyvarb''}}
                    {\CONSMUinterp{\mbox{\inexamplebody{f}}}{\METAMUtyvarc''}}
                  }
                  {\CONSMUeqty{\METAMUtyvarb''}{\CONSMUtyarrow{\METAMUtyvarc''}{\METAMUtyvara}}})
                }
              })
            }
            {\METAMUexpb'}
          }
          {\CONSMUabs
            {\mbox{\inexamplebody{f}}}
            {\METAMUtyvarc'}
            {\CONSMUinterp{\mbox{\inexamplebody{id id}}}{\METAMUtyvarc'}}
          }
        }
        {\METAMUexpb}
      }
      {\CONSMUabs
        {\mbox{\inexamplebody{id}}}
        {\METAMUtyvarc}
        {\METAMUexp}
      }$
      \\

      $\fra$
      & $\CONSMUand
      {\CONSMUand
        {\CONSMUand
          {\CONSMUand
            {(\CONSMUex
              {\METAMUtyvarb''}
              {\CONSMUex
                {\METAMUtyvarc''}
                {(\CONSMUand
                  {\CONSMUand
                    {\CONSMUinterp{\mbox{\inexamplebody{f}}}{\METAMUtyvarb''}}
                    {\CONSMUinterp{\mbox{\inexamplebody{f}}}{\METAMUtyvarc''}}
                  }
                  {\CONSMUeqty{\METAMUtyvarb''}{\CONSMUtyarrow{\METAMUtyvarc''}{\METAMUtyvara}}})
                }
              })
            }
            {\METAMUexpb'}
          }
          {\CONSMUabs
            {\mbox{\inexamplebody{f}}}
            {\METAMUtyvarc'}
            {\METAMUexp'}
          }
        }
        {\METAMUexpb}
      }
      {\CONSMUabs
        {\mbox{\inexamplebody{id}}}
        {\METAMUtyvarc}
        {\METAMUexp}
      }$
      \\
      & \hspace*{0.2in}where
      $\METAMUexp'
      =\CONSMUex
      {\METAMUtyvarb'''}
      {\CONSMUex
        {\METAMUtyvarc'''}
        {(\CONSMUand
          {\CONSMUand
            {\CONSMUinterp{\mbox{\inexamplebody{id}}}{\METAMUtyvarb'''}}
            {\CONSMUinterp{\mbox{\inexamplebody{id}}}{\METAMUtyvarc'''}}
          }
          {\CONSMUeqty{\METAMUtyvarb'''}{\CONSMUtyarrow{\METAMUtyvarc'''}{\METAMUtyvarc'}}})
        }
      }$
      \\

      $\ffra$
      & $\CONSMUand
      {\CONSMUand
        {\CONSMUand
          {\CONSMUand
            {(\CONSMUex
              {\METAMUtyvarb''}
              {\CONSMUex
                {\METAMUtyvarc''}
                {(\CONSMUand
                  {\CONSMUand
                    {\CONSMUinterp{\mbox{\inexamplebody{f}}}{\METAMUtyvarb''}}
                    {\CONSMUinterp{\mbox{\inexamplebody{f}}}{\METAMUtyvarc''}}
                  }
                  {\CONSMUeqty{\METAMUtyvarb''}{\CONSMUtyarrow{\METAMUtyvarc''}{\METAMUtyvara}}})
                }
              })
            }
            {\METAMUexpb'}
          }
          {\CONSMUabs
            {\mbox{\inexamplebody{f}}}
            {\METAMUtyvarc'}
            {\METAMUexp''}
          }
        }
        {\METAMUexpb}
      }
      {\CONSMUabs
        {\mbox{\inexamplebody{id}}}
        {\METAMUtyvarc}
        {\METAMUexp}
      }$
      \\
      & \hspace*{0.2in}where
      $\METAMUexp''=
      \CONSMUex
          {\METAMUtyvarb'''}
          {\CONSMUex
            {\METAMUtyvarc'''}
            {(\CONSMUand
              {\CONSMUand
                {\CONSMUsubst{\METAMUexp}{\METAMUtyvarb'''}{\METAMUtyvarc}}
                {\CONSMUsubst{\METAMUexp}{\METAMUtyvarc'''}{\METAMUtyvarc}}
              }
              {\CONSMUeqty{\METAMUtyvarb'''}{\CONSMUtyarrow{\METAMUtyvarc'''}{\METAMUtyvarc'}}})
            }
          }$
          \\


      $\ffra$
      & $\CONSMUand
      {\CONSMUand
        {\CONSMUand
          {\CONSMUand
            {(\CONSMUex
              {\METAMUtyvarb''}
              {\CONSMUex
                {\METAMUtyvarc''}
                {(\CONSMUand
                  {\CONSMUand
                    {\CONSMUsubst{\METAMUexp''}{\METAMUtyvarb''}{\METAMUtyvarc'}}
                    {\CONSMUsubst{\METAMUexp''}{\METAMUtyvarc''}{\METAMUtyvarc'}}
                  }
                  {\CONSMUeqty{\METAMUtyvarb''}{\CONSMUtyarrow{\METAMUtyvarc''}{\METAMUtyvara}}})
                }
              })
            }
            {\METAMUexpb'}
          }
          {\CONSMUabs
            {\mbox{\inexamplebody{f}}}
            {\METAMUtyvarc'}
            {\METAMUexp''}
          }
        }
        {\METAMUexpb}
      }
      {\CONSMUabs
        {\mbox{\inexamplebody{id}}}
        {\METAMUtyvarc}
        {\METAMUexp}
      }$
      \\

    \end{tabular}
  \end{\sizeintables}
  \caption{Derivation using M\"{u}ller's type inference algorithm}
  \label{fig:MUderiv}
\end{\myfigure}



\subsubsection{Comparison with Gustavsson and Svenningsson's constraint system}



Gustavsson and Svenningsson~\cite{Gustavsson+Svenningsson:2001}
defined a constraint system where solutions can be found in cubic
time.  Their constraint syntax is based on: the satisfied constraint
$\CONSSScstop$, inequality constraints on variables of the form
$\CONSSSineq{\METASSvar}{\METASSvarb}$ where $\METASSvar$ and
$\METASSvarb$ are variables, conjunctions of constraints of the form
$\CONSSSand{\METASScs}{\METASScsb}$ where $\METASScs$ and $\METASScsb$
are constraint terms, and existential constraints of the form
$\CONSSSex{\METASSvar}{\METASScs}$.  They also add to their syntax,
abstractions and applications.

Constraint abstractions are inspired by let-expressions and are of the
form: $\CONSSSabs{\METASSid}{\METASSvargroup}{\METASScs}$, where
$\METASSid$ is a constraint abstraction variable (the name of an
abstraction), $\METASSvargroup$ is a set\footnote{Even though it is
  not explicitly stated in their paper, vectors seem to be used for
  sets.} of variables, and $\METASScs$ is a constraint term.
Constraint abstractions are used in let-constraint terms.  A
let-constraint term is of the form:
$\CONSSSlet{\{\METASSabsgroup\}}{\METASScs}$, where $\METASSabsgroup$
is a set of abstractions and $\METASScs$ is a constraint term.
Abstractions in a let-constraint are mutually recursive so in a
let-constraint $\CONSSSlet{\{\METASSabsgroup\}}{\METASScs'}$, if
$\CONSSSabs{\METASSid}{\METASSvargroup}{\METASScs}$ is a constraint
abstraction in $\METASSabsgroup$, then all the uses of $\METASSid$ in
$\METASSabsgroup$ and $\METASScs'$ all refer to this occurrence of
$\METASSid$.

We believe a let-constraint as follows:
\begin{center}
  \begin{\sizeintablesp}
    $\CONSSSlet
    {
      \{
      \CONSSSabs{\METASSid_1}{\METASSvargroup_1}{\METASScs_1},
      \dots,
      \CONSSSabs{\METASSid_n}{\METASSvargroup_n}{\METASScs_n}
      \}
    }
    {\METASScs}$
  \end{\sizeintablesp}
\end{center}
would be represented in our system by an environment as follows:
\begin{center}
  \begin{\sizeintablesp}
    $\csbind
    {\CONSenvenv
      {\METAcsenv}
      {\CONStopoly
        {\CONSenvenv
          {\CONSenvenvn
            {\METAcsenv_n}
            {}
            {\METAcsenv_1}
          }
          {\CONSenvenvn
            {\CONSbind{\METASSid_n}{\METAtyvar_n}}
            {}
            {\CONSbind{\METASSid_1}{\METAtyvar_1}}
          }
        }
      }
    }$
  \end{\sizeintablesp}
\end{center}
where $\METASScs_i$ would be represented by $\METAcsenv_i$ for each
$i\in\{1,\dots,n\}$, where $\METASScs$ would be represented by
$\METAcsenv$, and where $\METASSvargroup_i$, for each
$i\in\{1,\dots,n\}$, would be computed when dealing at constraint
solving with the $\CONStopolySYMB$ constraint.

Abstractions are applied thanks to application constraint terms of the
form $\CONSSSapp{\METASSid}{\METASSvargroup}$.  An abstraction of the
form $\CONSSSapp{\METASSid}{\METASSvargroup}$ would be represented in
our system by an accessor of the form
$\CONSacc{\METASSid}{\METAtyvar}$.

Gustavsson and Svenningsson define a constraint solving algorithm and
prove it to be of cubic complexity.  Such a result is obtained by
enforcing that abstractions are simplified before being applied.
%% Thanks to LIVE basically.
Their constraint solver is based on a rewriting system that allows
four kinds of reductions: a transitivity reduction rule and three
reduction rules allowing reducing abstractions at various places in a
let-constraint (in the body of the let-constraint, in the body of the
abstraction that is applied or in the body of another abstraction
declared in the same let-constraint).

These reduction rules do not allow one to copy the whole body of an
abstraction when it is applied.  Only the ``live'' inequality
constraints are allowed to be copied at an application location, where
an inequality constraint is said to be ``live'' in a constraint term
if it does not use a variable which is bound in the term.
%

%% Pottier and R\'emy's constraint
%% system~\cite{Pottier+Remy:2005,Pottier:2005} discussed below can be
%% seen as an improvement of the system defined by Gustavsson where not
%% atomic constraints are not restricted to inequalities on variables but
%% can also be, e.g., type equalities and subtyping constraints.



\subsubsection{Comparison with Pottier and R\'emy's let-constraints} %$\marka$
\label{sec:comparisonpottierremy}


%%% LET-BINDINGS
Our constraint system has evolved through many versions.
One earlier version of our constraint system had a kind of constraint
that was very close to the let-constraints\footnote{Technically, the
  let-constraints of Pottier and R\'emy are based on their more
  primitive def-constraints.} of systems of Pottier and
R\'emy~\cite{Pottier+Remy:2005,Pottier:2005}.
%
Pottier and R\'emy define a constraint system~\cite{Pottier+Remy:2005}
which allows one ``to reduce type inference problems for HM($X$) to
constraint solving problems''.  Pottier defines a very similar
system~\cite{Pottier:2005}.  Using their let-constraints Pottier and
R\'emy ``achieve the desired separation between constraint generation,
on the one hand, and constraint solving and simplification, on the
other hand, without compromising
efficiency''~\cite{Pottier+Remy:2005}.
%
%% Pottier and R\'emy define a system~\cite{Pottier+Remy:2005}
%% that is an instance of HM($X$)~\cite{Odersky+Sulzmann+Wehr:1999}, and
%% Pottier defines a very similar system~\cite{Pottier:2005} as a
%% variation of the Damas/Milner type system.
%
In our discussion, we will collectively refer to these two systems as
the \PR\ (Pottier/R\'emy) system and ignore their technical differences,
although our presentation will follow more closely the presentation of
Pottier and R\'emy~\cite{Pottier+Remy:2005}.

In \PR, a constraint can, among other things, be a let-constraint, a
subtyping constraint, a type scheme instantiation constraint, a
conjunction of constraints, or the constant (and satisfied)
$\CONS{true}$ constraint.
A \PR\ let-constraint looks like
\(
  \cslet{\csletbind{\METAgenid}{\METAschemepr}}
        {\META{C}}
\)
where $\METAschemepr$ ranges over type schemes, and $\META{C}$ ranges
over constraints.
In \PR, type schemes are of the form
$\csletscheme{\METAtoset{X}}{\META{C}}{\META{T}}$ where
$\METAtoset{X}$ is a type variable set, $\META{C}$ is a constraint, and
$\META{T}$ is a type.
We borrow for our discussion two abbreviations that Pottier and R\'emy
define: (1)~the form $\csletschemeb{\METAtoset{X}}{\META{T}}$ stands for the type
scheme $\csletscheme{\METAtoset{X}}{\CONS{true}}{\META{T}}$, and
(2)~the form $\cslet{\csletbind{\METAgenid}{\META{T}}}{\META{C}}$ stands for
$\cslet{\csletbind{\METAgenid}{\csletschemeb{\emptyset}{\META{T}}}}{\META{C}}$.



The idea of let-constraints is that a constraint of the form
$$
  \cslet{\csletbind{\METAgenid}{\csletscheme{\METAtoset{X}}{\META{C}}{\META{T}}}}
        {(\METAgenid = \META{T_1} \wedge \METAgenid = \META{T_2})}
$$
is (roughly) equivalent to a constraint of this form:
$$
  (\exists\METAtoset{X}.({\META{C}}\wedge\META{T} = \META{T_1}))
  \wedge
  (\exists\METAtoset{X}.({\META{C}}\wedge\META{T} = \META{T_2}))
  \wedge
  (\exists\METAtoset{X}.{\META{C}})
$$
The key point is that one can get the effect of making the appropriate
number of copies of $\META{C}$ and $\META{T}$ while keeping the size
of the constraint proportional to the program size.
The constraints will need to be copied and each copy solved independently, but each copy
can be solved immediately before the next copy is made, avoiding an
exponential increase in the amount of memory used during constraint solving.
To get the full benefit of this, an implementation should be eager in
simplifying $\META{C}$ and calculating $\META{T}$ as much as possible
before making any copies.
(In our application, it could be good to also be lazy in simplifying
and calculating only those portions of $\META{C}$ and $\META{T}$ that
are actually needed by the uses of $\METAgenid$, because our \TES\
needs to spend most of its time finding minimal portions
of unsatisfiable constraints.
We leave investigating this idea for future work.)

\tocheck{Identifier bindings occurring in let-constraints are
similar to abstractions as defined by M\"{u}ller~\cite{Muller:1994}.
A binding as defined by Pottier and R\'emy is of the form
$\csletbind{\METAgenid}{\csletscheme{\METAtoset{X}}{\META{C}}{\META{T}}}$
where the type scheme $\csletscheme{\METAtoset{X}}{\META{C}}{\META{T}}$
associated with $\METAgenid$ is a constrained type scheme where the
constraint $\META{C}$ constrains the type $\META{T}$.
An abstraction as defined by M\"{u}ller~\cite{Muller:1994} is of the form
$\CONSMUabs{\METAMUid}{\METAMUtyvara}{\METAMUexp}$ where the static
semantics associated with the identifier $\METAMUid$ is the type
variable $\METAMUtyvara$ which is constrained by the expression
$\METAMUexp$.}

In our latest system, the equivalent of let-constraints can be
represented as a special case of what our system supports.
Informally, a let-constraint of the form
\(
  \cslet{\csletbind{\METAgenid}{\csletscheme{\METAtoset{X}}{\META{C}_1}{\META{T}}}}
        {\META{C}_2}
\)
%generated for a \SML\ $\CONS{val}\ \CONS{rec}$ declaration would be represented
%in our system by
%% $$
%%   \csbind{\CONSenvenv{\METAcsenv_2}
%%                     {\CONSenvenv{\CONStopoly{\CONSbind{\METAgenid}
%%                                                      {\CONSvidsem{\METAlabty}
%%                                                                  {\CONSstatusv}}}}
%%                                {\METAcsenv_1}}}
%% $$
generated for a \SML\ recursive $\CONS{let}$-binding
% (an expression of the form \inexamplebody{let val rec f = exp1 in
% exp2})
would be represented in our system by (using a combination of
rules~$\MEMgencgruleb$ and~$\MEMgencgrulel$ in Fig.~\ref{fig:consGenAlgo})
$$
  \csbind{\CONSenvenv{\METAcsenv_2}
                    {\CONStopoly{\CONSenvenv{\METAcsenv_1}
                                           {(\CONSbind{\METAgenid}
                                                      {\METAlabty})}}}}
$$
where $\META{C}_i$ is represented by $\METAcsenv_i$ and $\META{T}$
is represented by $\METAlabty$.
(Let-constraints generated for other \SML\ forms would not necessarily
get the same representation.)
There is no explicit representation of $\METAtoset{X}$ in the
representation in our system; instead the correct set of type variables
that can be quantified is calculated by $\MEMtopolySYMB$ which
generates type schemes when it handles environments of the form
\(
  \CONStopoly{\METAcsenv}
\)
(see Fig.~\ref{fig:monotopoly}).


\tocheck{Let us have a closer look at the different components of a
let-constraint.
A let-constraint is of the form
$\cslet
{\csletbind
  {\METAgenid}
  {\csletscheme{\METAtoset{X}}{\META{C}_1}{\META{T}}}
}
{\META{C}_2}$.
Such a constraint: (1)~assigns static semantics to the identifier
$\METAgenid$ (thanks to the form
$\csletbind{\METAgenid}{\METAPRscheme}$), (2)~quantifies the static
semantics associated with
$\METAgenid$ over a set of variables (generates a polymorphic type),
(3)~makes the access to $\METAgenid$'s semantics local to
$\META{C}_2$, and (4)~defines an order in which the constraints have
to be solved ($\META{C}_1$ before $\META{C}_2$).  Such a constraint
can then be seen as the combination of (at least) four primitive
constraints.  The first one is a binder in our system, the second one
is a $\CONStopolySYMB$ environment in our system, the third one is an
environment of the form $\csbind{\METAcsenv}$ in our system, and the
fourth one is an environment of the form
$\CONSenvenv{\METAcsenv_2}{\METAcsenv_1}$ in our system.}


%%% RECURSIVE VALUE DECLARATIONS
We now give an example comparing the constraints that would be
generated for \SML\ recursive value declarations in the \PR\ system and
our system.  Consider the \SML\ expression
$$
  \mbox{\inexamplebody{let val rec f = fn z => $\METAexp_1$ in $\METAexp_2$}}
$$
where $\METAexp_1$ and $\METAexp_2$ are two sub-expressions.
The constraint generated in \PR\ for this let-expression would be
$$
\begin{\sizeintablesp}
\cslet
{\csletbind
  {\mbox{\inexamplebody{f}}}
  {\csletscheme
    {\META{X}\META{Y}}
    {\cslet
      {
        \csletbind{\mbox{\inexamplebody{f}}}{\META{X}\rightarrow\META{Y}}
      }
      {\cslet
        {
          \csletbind{\mbox{\inexamplebody{z}}}{\META{X}}
        }
        {\META{C}_1}
      }
    }
    {\META{X}\rightarrow\META{Y}}
  }
}
{\META{C}_2}
\end{\sizeintablesp}
$$
where $\META{X}$ and $\META{Y}$ are internal type variables, where
$\META{X}\META{Y}$ is \PR\ notation for the set $\{\META{X},\META{Y}\}$,
where $\META{C}_i$ for $i\in\{1,2\}$ is the constraint generated for
$\METAexp_i$, and where $\META{Y}$ is the result type of $\METAexp_1$.
Due to the way let-constraints declare a local environment, the \PR\
system needs two binders for \inexamplebody{f}.
The outer one polymorphically binds the occurrences of
\inexamplebody{f} in $\METAexp_2$ and the inner one monomorphically
binds the occurrences of \inexamplebody{f} in $\METAexp_1$.

Some of the differences between \PR\ and our system can be seen when
comparing how this example is handled.
Our constraint generator builds roughly\footnote{We have omitted
  labels and simplified a bit.  The actual constraint that is
  generated (still omitting labels though) is
  $$
    %\begin{\sizeintables}
      \csbind{
        \CONSenvenv
            {\METAcs_3}
            {\CONSenvenv
              {\METAcsenv_2}
              {\CONSenvenv
                {\METAenvvar_2}
                {
                  (
                  \csou{\METAenvvar_2}
                       {\CONStopoly{
                           \CONSenvenv
                               {\METAcs_2}
                               {\CONSenvenv
                                 {\csbind{
                                     \CONSenvenv
                                         {\METAcs_1}
                                         {\CONSenvenv
                                           {\METAcsenv_1}
                                           {\CONSenvenv
                                             {\METAenvvar_1}
                                             {(\csou{\METAenvvar_1}{(\CONSbindu{\mbox{\inexamplebody{z}}}{\METAtyvar_2})})}
                                           }
                                         }
                                   }
                                 }
                                 {\CONSbind{\mbox{\inexamplebody{f}}}{\METAtyvar_1}}
                               }
                         }
                       }
                       )
                }
              }
            }
      }
    %\end{\sizeintables}
  $$
  where
  $\METAcs_1=(\csou{\METAtyvar_3}{\METAlabtyarrowp{\METAtyvar_2}{\METAtyvar_4}{}})$,
  $\METAcs_2=(\csou{\METAtyvar_1}{\METAtyvar_3})$,
  $\METAcs_3=(\csou{\METAtyvar_5}{\METAtyvar_6})$,
  $\mytuple{\METAtyvar_4,\METAcsenv_1}$ is generated for $\METAexp_1$,
  $\mytuple{\METAtyvar_6,\METAcsenv_2}$ is generated for $\METAexp_2$,
  and $\METAtyvar_5$ is the type of the entire let-expression.}
the following constraint (technically, an environment) for the example
let-expression:
$$
  %\begin{\sizeintables}
  \csbind{
    \CONSenvenv
        {\METAcsenv_2}
        {\CONStopoly{
            \CONSenvenv
                {\csbind{
                    \CONSenvenv
                        {\METAcsenv_1}
                        {(\CONSbindu{\mbox{\inexamplebody{z}}}
                                    {\METAtyvar_1})}
                  }
                }
                {\CONSbind{\mbox{\inexamplebody{f}}}
                          {\METAlabtyarrowp{\METAtyvar_1}
                                           {\METAtyvar_2}
                                           {}}}
          }
        }
  }
  %\end{\sizeintables}
$$
In contrast to how \PR\ handles this example, only one binder for
\inexamplebody{f} is needed in our system.
Two features of our system interact to allow this.
First, in a \COMPENV\
($\CONSenvenv{\METAcsenv_2}{\METAcsenv_1}$), the bindings from
$\METAcsenv_1$ are available in $\METAcsenv_2$, but also form part of
the result (except where bindings in $\METAcsenv_2$ shadow them).
Second, in an environment of the form $\CONStopoly{\METAcsenv}$, the
$\CONStopolySYMB$ operator changes the status of binders in the
result from the status they had internally.
In the example constraint (environment) above, \inexamplebody{f}'s
binder is monomorphic within the scope of the $\CONStopolySYMB$
operator (in $\METAcsenv_1$) and polymorphic outside (in $\METAcsenv_2$).

There is a sense in which what the \PR\ system does is similar to what
would happen in our system if the $\CONStopolySYMB$ operator worked on
just single types or single bindings rather than entire environments.
It is significant that we can form environments of the form
\(
  \CONSenvenv
    {\METAcsenv_2}
    {\CONStopoly
       {
        \CONSenvenv
          {\METAcsenv_1}
          {\CONSbind{\METAid}
                    {\METAlabty}
          }
       }}
\),
\relax
in which the type for $\METAid$ is available monomorphically in
${\METAcsenv_1}$ and polymorphically in ${\METAcsenv_2}$.

%%% SEQUENCES OF DECLARATIONS
The differences between the \PR\ system and our system gain greater
significance when we consider how to handle the \SML\ module system.
The most basic construct of the module system is what forms the body
of a structure, namely
a sequence of declarations
$\METAdec_1\cdots\METAdec_n$.
For this discussion, assume each $\METAdec_i$ declares exactly one
identifier $x_i$.
Consider how declaration sequences can be handled by the \PR\ system and
our system.
\PR\ can handle such a sequence with nested let-constraints as
follows:
%% AND THEY DO SO IN THEIR IMPLEMENTATION
$$
\begin{\sizeintablesp}
\cslet{\csletbind{x_1}{\METAschemepr_1}}{(\cdots\cslet{\csletbind{x_n}{\METAschemepr_n}}{\META{C}_0}\cdots)}
\end{\sizeintablesp}
$$
%
The constraints must be nested as indicated because each $x_i$ is only
visible in the ``$\csinL$'' part of the corresponding
let-constraint, where an identifier binding occurrence is
visible when constraints can refer to it.
In contrast, our system handles the same declaration sequence with the
environment
$$
\begin{\sizeintablesp}
\CONSenvenvn{\METAcsenv_n}{}{\METAcsenv_1}
\end{\sizeintablesp}
$$
where $\METAcsenv_i$ is the environment generated for the declaration
$\METAdec_i$ for each $i\in\{1,\ldots,n\}$.

% WTF does this mean?:
% Thus, a difference between their constraint system and ours is that
% our constraint generator is compositional while their is not.

%%% STRUCTURES
The importance of the difference becomes clearer when we consider how
to represent full structures and structure bindings.
Take the above example declaration sequence and wrap it up in a
structure definition:
$$
  \LABstrdecStr
    {\LABstrbindBas
       {\METAstrid}
       {\LABstrexpMul{\METAdec_1}{\METAdec_n}{}}
       {}}
$$
A structure expression packs into a unit a sequence of declarations.
The normal scope of the declarations ends at the end of the structure,
and subsequent access to the declarations must go through the
structure itself, which must first be bound to a name via either a
structure declaration like above or a functor application.
When performing type inference for \SML\ structure expressions, it is
most natural and straightforward that the type inferred for a
structure will be a sequence of individual mappings from
declared names to their types\footnote{
% type constructor names to type functions
% and from value identifier names to type schemes.
The order of the sequence is important because a type scheme for one
value identifier in a structure can refer to a type constructor name
defined by the structure, while at the same time a type scheme for a
different value identifier can use the same type constructor name to
refer to a definition outside the structure.}.
Such sequences are often called \textit{environments}.
It seems clear that any type inference method will need to handle
environments.

The \PR\ system has never been extended to handle \ML-style
structures\footnote{Fran\c{c}ois Pottier told us this on 2010-08-09.},
but let us imagine how it might be extended to do this.
First, let us point out that Pottier and R\'emy abbreviate the
above example of nested let-constraints as follows:
$$
\begin{\sizeintablesp}
\cslet{\Gamma_{\mathrm{d}}}{\META{C}_0}\mbox{, where }\Gamma_{\mbox{d}}=\csletbind{x_1}{\METAschemepr_1};\cdots;\csletbind{x_n}{\METAschemepr_n}
\end{\sizeintablesp}
$$
Let us call this constraint $\META{C}_{\mathrm{d}}$ where the ``d''
means ``declarations''.
Given an \SML\ structure definition, this kind of constraint can
represent the constraints required for typability of the sequence of
declarations in the structure body, and it is the only easy way to do
so in the context of the \PR\ system.

Now, how do we represent the connection of the structure's body to the
structure's name?
The immediately (and naively) obvious idea is to extend \PR\ with
let-constraints of a form similar to
$\cslet{\csletbind{\METAstrid}{\Gamma_{\mathrm{s}}}}{\META{C}}$,
where $\METAstrid$ is a structure identifier, and
$\Gamma_{\mathrm{s}}$ is an environment (the type of a structure).
Let us call this new constraint $\META{C}_{\mathrm{s}}$.
This is not enough, because there needs to be some way to connect the
constraint $\META{C}_{\mathrm{d}}$ to the environment
$\Gamma_{\mathrm{s}}$.
In fact, the environment $\Gamma_{\mathrm{d}}$ inside
$\META{C}_{\mathrm{d}}$ is just what we need, but there is no easy way
to get at it, because there is no mechanism in \PR\ for generating an
environment from a constraint.
The easiest thing to do is to nest the entire constraint
$\META{C}_{\mathrm{s}}$ inside the constraint $\META{C}_0$ inside of
$\META{C}_{\mathrm{d}}$, because the types of the $x_i$'s are not
accessible from outside $\META{C}_{\mathrm{d}}$, but this seems like
turning the program inside out, because the entire rest of the program
must be nested inside the scope of the constraints for just the
structure's body.

So one might then want to extend the \PR\ constraint system
with an exporting mechanism and generate a constrained environment of
the form $\csletcons{\META{C}_{\mathrm{d}}}{\Gamma_{\mathrm{s}}}$ for
the structure expression where $\META{C}_{\mathrm{d}}$ would export
the type schemes of the $x_i$s and where
$\Gamma_{\mathrm{s}}$ would refer to these exported type
schemes.
But, all this technicality really should not be needed because
$\Gamma_{\mathrm{d}}$ is already the environment that we would want to
generate for the structure expression.

%
%%   Now, because, each generated binder is not
%% ``visible'' anymore from outside the constraint, in order to generate
%% a suitable constraint for the structure expression, another mechanism
%% is needed to ``export'' them.  By exporting a binder we mean that
%% additional constraints (not generated inside the let-constraint)
%% should be able to refer to it.
%
%What gets in the way of generating $\Gamma$ only are the restrictions
%imposed by let-constraints.

The way our constraint system achieves that is by instead of having
only one mechanism (the let-constraints) to bind identifiers and to
restrict their scope (let-constraints define a local scope),
it has two separate mechanisms: one for bindings that does not restrict
the scope of the binders (we obtain this behaviour by having binding
constraints of form $\CONSbind{\METAgenid}{x}$ and by having our
general \COMPENV\ forms
$\CONSenvenv{\METAcsenv_2}{\METAcsenv_1}$ where the accessors occurring
in $\METAcsenv_2$ can depend on the binders occurring in
$\METAcsenv_1$), and another one for constraining the scope of a type
environment (obtained thanks to our environments of the form
$\csbind{\METAcsenv}$).
%
The environment we generate for the structure expression presented
above is then similar to the environment $\Gamma_{\mathrm{d}}$.




\subsection{Related work on presenting type errors and types}
\label{sec:relatedwork}



%% \ifvv
%% In this section we report on similar approaches and briefly compare
%% some of them to our \TES.
%% \fi



%\subsubsection{Methods making use of slices}




\subsubsection{Methods making use of slices}
%
After the first version of \TES\ presented by Haack and
Wells~\cite{Haack+Wells:2003,Haack+Wells:2004}, many researchers began
to present type errors as program slices obtained from unsolvable sets
of constraints.



%
\tocheck{Tip and Dinesh~\cite{Tip+Dinesh:2001} report type error slices
for a Pascal-like language called CLaX, which is an
explicitly typed language (where explicit types are enforced, e.g., on
function parameters).  Their method consists of defining the type
checker of the CLaX language as a rewriting system.  This rewriting
system rewrites a piece of code into either a type if the
piece of code is typable, or into a list of error messages if the piece
of code is untypable.  To compute slices they use ``dependence
tracking''~\cite{Field+Tip:1994,Field+Tip:1998}.  Tip and Dinesh
explain that ``Dependence tracking is a method for computing term
slices that relies on an analysis of rewriting rules to determine how
the application of rewriting rules causes \emph{creation} of new
function symbols, and the \emph{residuation} (i.e., copying, moving
around, or erasing) of previously existing
subterms''~\cite{Tip+Dinesh:2001}.  Developments (w.r.t.\ a sequence
of rewriting steps on a piece of code) are trimmed to retain only the
necessary symbols of a piece of code, i.e., the ones responsible for
an error to occur.
%
Tip and Dinesh also applied their techniques to
\MINIML~\cite{Clement+Despeyroux+Kahn+Despeyroux:1986} which is a
subset of \ML\ (``a simple typed $\lambda$-calculus with constants,
products, conditionals, and recursive function
definitions''~\cite{Clement+Despeyroux+Kahn+Despeyroux:1986}).
%
However, Tip and Dinesh face some minimality issues when applying
their method to \MINIML\ (``in some cases slices are computed that
seem larger than necessary''~\cite{Tip+Dinesh:2001}).
%
This issue is related to the lack of a minimisation algorithm.}
%
%% They use paths instead of labels.


%\medskip
Neubauer and
Thiemann~\cite{Neubauer+Thiermann:2003}  use flow analysis to
compute type dependencies for a small \ML-like language to report
type errors.  Their system uses discriminative sum types and can
analyze any term.  Their
first step (``collecting phase'') labels
the studied term and infers type information.  This
analysis generates a set of program point sets.  These program
points are directly stored in the discriminative sum types.  A
conflicting type (``multivocal'') is then paired with the locations
responsible for its generation.  Their second step
(``reporting phase'') consists of generating error reports from the
conflicts generated during the first phase.  Slices are built from
which highlighting are produced.  An interesting detail
is that a type derivation can be viewed as the
description of all type errors in an untypable piece of code, from
which another step
% then
computes error reports.


%\medskip
Similar to ours is work by Stuckey, Sulzmann
and Wazny~\cite{Stuckey+Sulzmann+Wazny:2006,Wazny:2006}
(based on earlier work without
slices~\cite{Stuckey+Sulzmann+Wazny:2003,Stuckey+Sulzmann+Wazny:2004}).
They do type inference, type checking and report type errors for the
\CHAMELEON\ language (a modified \HASKELL\ subset).  \CHAMELEON\
includes
% advanced type system features (such as
algebraic data types,
%(page 22 it is written that they do only type checking)
type-class overloading, and functional dependencies.
%  As in many recent works,
They code the typing problem into a constraint
problem
and attach labels to constraints to track program locations
%.  These labels are used to
and
highlight parts of untypable pieces of code.  First they compute a
minimal unsatisfiable set of generated constraints from which they
select one of the type error locations to provide their type
explanation.  They finally provide a highlighting and an error message
depending on the selected location.  They provide slice highlighting
but using a different strategy from ours.
They focus
% more
on explaining conflicts in the inferred types at one program
point inside the error location set.
It is not completely clear, but they do not seem to worry much
about whether the program text they are highlighting is exactly (no more and
no less) a complete explanation of the type error.
For example, they do not highlight applications
because ``they have no explicit tokens in the source code''.  It is
then stated: ``We leave it to the user to understand when we highlight
a function position we may also refer to its application''.  This
%deliberate choice of theirs
differs from our strategy because
we think it is preferable to highlight all the
program locations responsible for an error even if these are
white spaces.
%  However, They do not seem to highlight every part of
% an untypable piece of code needed to understand a type error and do
% not compute (minimal) slices.
Moreover, they do not appear to highlight the parts of
datatype declarations relevant to type errors.
%

When running on a translation of the code presented in
Sec.~\ref{sec:complexExample} into \HASKELL, \CHAMELEONGECKO\ outputs
the error report partially displayed below (the rest of the output
seems to be internal information from their solver).

\examplebody{
\Bl
ERROR: Type error; conflicting sites:\\
y = (\boxR{trans} \boxR{x1,} x2)
\El
}

%information computed during unification).
%
This highlighting identifies the same
% error
location as \SMLNJ\ and would not help solve the error.



\hidden{
Let us present another simple example.  Wazny provides the following
highlighting in his thesis~\cite{Wazny:2006}:

\examplebody{
\Bl
sumLengths [] = \boxR{[]}
\\
sumLengths (xs:xss) = \boxR{length} xs \boxR{+} sumLengths xss
\El
}

In comparison \IMPLTES\ reports the following highlighting:

\examplebody{
\Bl
\boxR{structure} \boxR{Basis :> sig}
\\
\boxR{eqtype} \boxB{int}
\\
\boxR{val} \boxR{length : }'a list \boxR{-> int}
\\
\boxR{end =} \_structBasis
\\
\boxR{open} \boxR{Basis}
\\
\boxR{overload +   : 'a * 'a ->} 'a\boxR{  with} \boxR{'a} \boxR{in} (in Int, in Word, in Real)
\\
\\
\boxR{fun} \boxR{sumLengths }\fboxR{[]}\boxR{ = }\boxG{[]}
\\
\ \ \boxR{|} sumLengths (xs::xss) = \boxR{length} xs + sumLengths xss
\El
}

The first part of our report comes from the basis file provided with
\IMPLTES.  The signature of the structure \inexamplebody{Basis}
specifies the top-level declarations (this is achieved thanks to the
declaration \inexamplebody{open Basis}).
%
The second part of our report comes from the user code.
%
We believe the fact that \inexamplebody{[]} is returned by
\inexamplebody{sumLengths} and the fact that the application of
\inexamplebody{}.}


%All their concepts are implemented in their Chameleon system.
% Type-class overloading is said to be critical.
%Unlike \SML, in \HASKELL\ the distinction between identifier status
%is syntactic.
%\mynote{2009-07-14}{Another (minor) difference is that...}
Significantly, because they handle a \HASKELL-like language, they face
%technical
challenges for accurate type error location that are
different from the ones for \SML.





\mynote{2009-03-02}{ They claim that Haack and
  Wells~\cite{Haack+Wells:2004} (it is said to be the work the closest
  to their work) ``only report errors by highlighting the locations
  involved'' which is wrong because Haack and Wells also compute
  slices.  Maybe what they mean is that they don't provide any verbose
  explanation.}


%\medskip
Gast~\cite{Gast:2004} generates ``detailed explanations of ML
type errors in terms of data flows''.  His method is in three steps:
%
generation of subtyping constraints annotated by reasons for their
generation;
%
%unification of the generated constraints gathering reasons during the
%process;
%
gathering of reasons during constraint solving; % while unifying the generated constraints;
%
transformation of the gathered reasons into explanations by data
flows.
%
He provides
%, among other things,
a visually convenient display of
the data flows with arrows in \XEMACS.  Gast's method (which seems to
be designed only for a small portion of \OCAML) can be considered as a
slicing method with
% some
data flow explanations.

%\medskip
\brael~\cite{Brael:2004} presents a generic approach
(implemented for the language Curry) for type error reporting
that consists of two different procedures.  The first one
tries to replace portions of code by dummy terms that can
be assigned any type.  If an untypable piece of code becomes typable
when one of its subtrees has been replaced by a dummy term then the
process goes on to apply the same strategy inside the subtree.  The
second procedure consists in using of a heuristic to guide the
search of type errors.  The heuristic is based on two principles: it
will always ``prefer an inner correction point to an outer one'' and
will always ``prefer the point which is located in a function farther
away in the call graph from the function which was reported by the
type checker as the error location''.
% This method does not compute minimal slices.
\brael's method does not seem to compute proper slices but instead
singles out different locations that might be the cause of a type
error inside a piece of code.
%  His method is similar to our minimisation algorithm.




%subsection{Significant non-slicing type explanation methods}



%\medskip
\subsubsection{Significant non-slicing type explanation methods}
%
%\medskip
Heeren et al.\ designed a method used in the Helium
project~\cite{Heeren+Jeuring+Swierstra+Alcocer:2002,Hage+Heeren:2005,Heeren:2005,Hage+Heeren:2006}
to provide error messages for the \HASKELL\ language relying on a
constraint-based type inference.  First, a constraint graph is
generated from a piece of code.  For an ill-typed piece of code,
a conflicting path called an inconsistency is extracted from the
constraint graph.  Such a conflicting path is a structured unsolvable
set of type constraints.  Heuristics are used to remove
inconsistencies.  A trust value is associated with each type constraint and
depending on these values and the defined heuristics, some constraints
are discarded until the inconsistency is removed.  They also propose
some ``program correcting heuristics'' used to search for a typable
piece of code from an untypable one.  Such a heuristic is for example
the permutation of parameters which is a common mistake in
programming.  Their approach has been used with
students learning functional programming.  Using pieces of code
written by students and their expertise of the language they refined
their heuristics.
%\ifvv
They also designed a system of ``directives'' which
are commands specified by the programmer to constrain the set of types
derivable from a type class.
%\fi
This approach differs from ours by
privileging locations over others by the use of some heuristics.  They
do not compute minimal slices and highlightings.

\mynote{2009-07-16}{
\examplebody{
\Bl
data T a b c \Bl
             = Red\ \ \ \ (a, b, c)\\
	     | Blue\ \ \ (a, b, c)\\
             | Pink\ \ \ (a, b, c)\\
             | Green\ \ (a, b, b)\\
	     | Yellow (a, b, c)\\
	     | Orange (a, b, c)
             \El\\
trans (Red\ \ \ \ (x, y, z)) = Blue\ \ \ (y, x, z)\\
trans (Blue\ \ \ (x, y, z)) = Pink\ \ \ (y, x, z)\\
trans (Pink\ \ \ (x, y, z)) = Green\ \ (y, x, z)\\
trans (Green\ \ (x, y, z)) = Yellow (y, x, z)\\
trans (Yellow (x, y, z)) = Orange (y, x, z)\\
trans (Orange (x, y, z)) = Red\ \ \ \ (y, x, z)\\
type U a b = (T a a b, b)\\
(x1, x2) = (Red (2, 2, False), True)\\
y :: U Int Bool\\
y = (trans x1, x2)\\
main = putStrLn "foo"\\
\El
}}



We present below the most interesting part of the error report
obtained using Helium on a translation of the code presented in
Sec.~\ref{sec:complexExample} into \HASKELL.  It comes with some
warnings (which are not displayed here) on the bindings of identifiers
such as the binding of \inexamplebody{y} in \inexamplebody{trans}
(some of these warnings explain, for example, that \inexamplebody{y}'s
declaration at the end of the code does not bind any of the
\inexamplebody{y}'s in \inexamplebody{trans}'s definition).

\examplebody{
\Bl
(16,6): Type error in application\\
 expression\ \ \ \ \ \ \ : trans x1\\
 term\ \ \ \ \ \ \ \ \ \ \ \ \ : trans\\
   \Bi
   type\ \ \ \ \ \ \ \ \ \ \ : T a\ \ \ a\ \ \ a\ \ \ \ -> T a\ \ \ a\ \ \ a\\
   does not match : T Int Int Bool -> T Int Int Bool
   \Ei\\
\\
Compilation failed with 1 error
\El
}

It is reported that
% somehow
\inexamplebody{x1} and \inexamplebody{trans} don't have the expected
types.  The application, which is at the end of the code, is then
blamed when our programming error is at the very beginning of the
code.
% and that the Helium's report blames some code at
%its end.

%\vspace{-0.05in}



%\vspace{-0.05in}


Also, they have
% recently
tackled the task to report type errors for
Java~\cite{Boustani+Hage:2009,Boustani+Hage:2010}.
Error reports
provided by usual
compilers can be of little help, especially in the presence of
generics.  El Boustani and Hage try to do
a better job by keeping
track of more information during type checking.
% Having more
% information at hands
When analysing an untypable piece of code, it
allows a more global view of its type errors and leads to more
informative error reports.  The main difference between type error
reporting for \SML\ and for \JAVA\ is that in \JAVA\ ``types are
instantiated based on local information only and not through a long
and complicated sequence of unifications''~\cite{Boustani+Hage:2009}.



% \medskip Hage and Heeren~\cite{Hage+Heeren:2005} have as goal ``to
% improve the type error messages in the presence of Haskell98 type
% classes''.  They design a system of ``directives'' which are commands
% specified by the programmer to constrain the set of types derivable
% from a type class.


Lerner, Flower, Grossman and
Chambers~\cite{Chambers+Grossman+Flower+Lerner:2007} present type
error messages by constructing well-typed programs from ill-typed ones
using different techniques (like Heeren et
al.~\cite{Hage+Heeren:2006}), e.g., switching two parameters.
Automatically conceived modifications to the ill-typed piece of code
are checked for typability.  They target \CAML, and also developed a
prototype for \CPP.  The new typable generated code is presented as
possible code that the programmer might have intended.  It could be
interesting to study the combination of this with \TES.

\hidden{%\medskip
Lerner, Flower, Grossman and
Chambers~\cite{Chambers+Grossman+Flower+Lerner:2007} present a new
approach for type error messages.  Given an ill-typed piece of code,
their method makes use of an unaltered type checker as ``an oracle for
a search procedure that finds similar programs that do type-check''.
The considered language is \CAML, but they also developed a
prototype for \CPP.
%
%
Even if
the process cannot always find the code the programmer had in
mind, it appears that the error locations reported are better than the
ones obtained using the usual type checker alone.  Other advantages
are that the original type checker stays unchanged and does not have to
deal anymore with error reporting.
%
Different techniques are used to generate a well-typed program from an
ill-typed piece of code.  These techniques are: removal of parts of
the given code (if such an incomplete code type checks then the removed
part is likely to be involved in a type error), constructive change of
code (such as switching two parameters, association in different
orders, etc.), adaptation to context (the type constraint linking a
piece of code to its context is removed) and triage (that tries to
``ignore some other parts of the program to focus on one problem'' in
the case of the presence of more than one error).
%
The focus of their method is not to precisely report on existing type
errors but to provide hints that could help the user to turn an
untypable piece of code into a typable one.  It is a completely
different approach from the slicing approach.}


\mynote{2009-07-15}{MAYBE SOMETHING LIKE: None of these works tackles
  the problem to develop a \TES\ for a full language with
  all its features and without incorporating heuristics which might
  leads to confusing error reports for the user.}



%% \subsection{Future work}
%% %\subsection{Conclusion}
%% \label{sec:conclusion}
%% %% \label{sec:contributions}
%% %% \label{sec:concl-impl}


%% %\input{included/contributions}

%% % \mynote{2009-07-15}{HERE OR SOMEWHERE ELSE: We already implemented
%% %   other kind of context dependencies.  These are on the binding of
%% %   explicit type variables and are related to their implicit binding.
%% %   For example in \inexamplebody{val f : 'a -> 'a = fn x => x},
%% %   \inexamplebody{'a} is implicitly bound to the declaration}

%% %\subsection{Future work}
%% %

%% \ifthesis
%% We have already implemented some merging of minimal slices and
%% are extending this idea to other kind of errors than record
%% clashes, such as for unmatched signature specifications.
%% \fi

%% \hidden{ Merging errors is useful to emphasise the
%% locations shared by different slices for the same programming
%% error.  It might involve using different colour shades
%% depending on the percentage of minimal slices to which a location
%% contributes.  (If a location is shared by many slices it does
%% not always mean that it is more likely to be a programming
%% error location.)
%% %neither it is for an end point.
%% }

%% \hidden{We plan more constraint annotations to enhance error reports when
%% non-obvious features might be responsible for an error, e.g., to help
%% explain problems caused by \SML's ``value polymorphism restriction''.
%% % or would be some context dependent explanation about the implicit
%% % binding of explicit type variable.
%% }

%% \hidden{We have already sped up our minimisation algorithm by tuning
%%   our constraint solver so that when found errors are closer to being
%%   minimal.  We believe this could be improved further and that such an
%%   exercise will teach us useful lessons on type error slicing.}


%% In the near future, we plan to finish extending \TES\ to the full
%% \SML\ language.
%% %
%% This includes handling features such as flexible records, equality
%% types, or type and structure sharing, which can cause errors we
%% currently do not detect.

%% %% This includes finishing handling the key feature of functors
%% %% and less vital features such as flexible records or equality types,
%% %% which can cause errors we currently do not detect.

%% \newtext{
%% We also plan to extend our ideas to other languages such as the \FSHARP\
%% programming language or the \CPP\ template language.}


%% % Begun designing proper scientific experiments.  We still need to
%% % carry them out.


%% Finally, we have begun designing proper scientific experiments to
%% compare the effectiveness in improving the productivity of real users
%% of \TES\ vs.\ more traditional type error messages.
%% We have not yet carried them out.
%% %
%% %When our type error slicer reaches practical usability on normal
%% %programs (i.e., no severe restrictions on the use of \SML\ features), we
%% %want to run experiments
%% %% to compare the effectiveness in improving the
%% %% productivity of real users of \TES\ vs.\ more traditional
%% %% type error messages.

%% \mynote{2009-07-15}{MAYBE ADD SOMETHING LIKE: We are currently using a
%%   proper type environment that is conceptually equivalent to a set of
%%   new kind of constraints.  We are planning on completely transform
%%   these environments into proper constraints that would then involve
%%   identifiers (as done by Pottier and
%%   R\'emy~\cite{Pottier+Remy:2005,Pottier:2005}).  We believe this
%%   transformation would drastically simplify the presentation the
%%   implementation as well as the presentation of our type error
%%   slicer.}

%% \mynote{2009-07-15}{MAYBE SOMETHING LIKE: We have already started the
%%   process of running experiments on real users using our type error
%%   slicer...}

%%   % \mynote{2009-05-01}{Maybe it's not a good idea to present the
%%   %   following kind of error.}

%%   % \medskip We already started implementing structures and report the
%%   % \textbf{presence of a long value variable inside a pattern} as
%%   % follows (reported under the assumption that \inexamplebody{T.true}
%%   % is a value variable):

%%   % \examplebody{ \Bl \boxR{val} \boxR{T.true} \boxR{=} true \El }

%% % Our current approach to constraint generation is inspired by a naive
%% % approach to using intersection types.
%% % As a result, the constraint set size grows too quickly as program size
%% % increases.
%% % We are currently working on schemes that avoid too rapid growth in
%% % constraint set size.


\bibliography{biblio}

\end{document}
