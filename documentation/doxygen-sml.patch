From c7286a5d0aff69ea9d74eefec109e52c94e1f7af Mon Sep 17 00:00:00 2001
From: John Pirie <jpirie23@gmail.com>
Date: Mon, 25 Nov 2013 12:29:23 +0000
Subject: [PATCH] Addition of support for Standard ML language

---
 Doxyfile              |    2 +
 src/Makefile.in       |    5 +-
 src/config.l          |    2 +
 src/docsets.cpp       |    1 +
 src/doxygen.cpp       |    3 +
 src/libdoxygen.pro.in |    4 +
 src/libdoxygen.t.in   |    6 +
 src/smlcode.h         |   45 ++
 src/smlcode.l         | 1462 +++++++++++++++++++++++++++++++++++++++++++++++
 src/smlscanner.h      |   67 +++
 src/smlscanner.l      | 1513 +++++++++++++++++++++++++++++++++++++++++++++++++
 src/types.h           |    3 +-
 src/util.cpp          |    6 +-
 13 files changed, 3115 insertions(+), 4 deletions(-)
 create mode 100644 src/smlcode.h
 create mode 100644 src/smlcode.l
 create mode 100644 src/smlscanner.h
 create mode 100644 src/smlscanner.l

diff --git a/Doxyfile b/Doxyfile
index 2c49548..c21f812 100644
--- a/Doxyfile
+++ b/Doxyfile
@@ -118,8 +118,10 @@ EXCLUDE                = src/code.cpp \
                          src/commentcnv.cpp \
                          src/commentscan.cpp \
                          src/pycode.cpp \
+                         src/smlcode.cpp \
                          src/config.cpp \
                          src/pyscanner.cpp \
+                         src/smlscanner.cpp \
                          src/fortranscanner.cpp \
                          src/fortrancode.cpp \
                          src/vhdlscanner.cpp \
diff --git a/src/Makefile.in b/src/Makefile.in
index 7d1d0d9..5c4777a 100644
--- a/src/Makefile.in
+++ b/src/Makefile.in
@@ -45,8 +45,9 @@ distclean: clean
 	-$(RM) scanner.cpp code.cpp config.cpp pre.cpp constexp.cpp \
 	       ce_parse.cpp ce_parse.h tag.cpp commentscan.cpp \
 	       declinfo.cpp defargs.cpp commentcnv.cpp doctokenizer.cpp \
-	       pycode.cpp pyscanner.cpp fortrancode.cpp fortranscanner.cpp \
-	       vhdlscanner.cpp vhdlcode.cpp tclscanner.cpp vhdlparser.h \
+	       pycode.cpp pyscanner.cpp smlcode.cpp smlscanner.cpp
+	       fortrancode.cpp fortranscanner.cpp vhdlscanner.cpp \
+               vhdlcode.cpp tclscanner.cpp vhdlparser.h \
 	       vhdlparser.cpp
 
 # clean also the generated files which are in SVN
diff --git a/src/config.l b/src/config.l
index cc0a2f8..2ddff6a 100644
--- a/src/config.l
+++ b/src/config.l
@@ -1387,6 +1387,8 @@ void Config::check()
     filePatternList.append("*.mm");
     filePatternList.append("*.dox");
     filePatternList.append("*.py");
+    filePatternList.append("*.sml");
+    filePatternList.append("*.sig");
     filePatternList.append("*.f90");
     filePatternList.append("*.f");
     filePatternList.append("*.for");
diff --git a/src/docsets.cpp b/src/docsets.cpp
index 2aa2918..9ffcda5 100644
--- a/src/docsets.cpp
+++ b/src/docsets.cpp
@@ -328,6 +328,7 @@ void DocSets::addIndexItem(Definition *context,MemberDef *md,
     case SrcLangExt_Java:    lang="java"; break;       // Java
     case SrcLangExt_JS:      lang="javascript"; break; // Javascript
     case SrcLangExt_Python:  lang="python"; break;     // Python
+    case SrcLangExt_Sml:     lang="sml"; break;        // Standard ML
     case SrcLangExt_Fortran: lang="fortran"; break;    // Fortran
     case SrcLangExt_VHDL:    lang="vhdl"; break;       // VHDL
     case SrcLangExt_XML:     lang="xml"; break;        // DBUS XML
diff --git a/src/doxygen.cpp b/src/doxygen.cpp
index 6f9a8bf..48820a6 100644
--- a/src/doxygen.cpp
+++ b/src/doxygen.cpp
@@ -71,6 +71,7 @@
 #include "parserintf.h"
 #include "htags.h"
 #include "pyscanner.h"
+#include "smlscanner.h"
 #include "fortranscanner.h"
 #include "dbusxmlscanner.h"
 #include "tclscanner.h"
@@ -9833,6 +9834,7 @@ void initDoxygen()
   Doxygen::parserManager = new ParserManager;
   Doxygen::parserManager->registerParser("c",       new CLanguageScanner, TRUE);
   Doxygen::parserManager->registerParser("python",  new PythonLanguageScanner);
+  Doxygen::parserManager->registerParser("sml",     new SmlLanguageScanner);
   Doxygen::parserManager->registerParser("fortran", new FortranLanguageScanner);
   Doxygen::parserManager->registerParser("vhdl",    new VHDLLanguageScanner);
   Doxygen::parserManager->registerParser("dbusxml", new DBusXMLScanner);
@@ -10854,6 +10856,7 @@ void parseInput()
   preFreeScanner();
   scanFreeScanner();
   pyscanFreeScanner();
+  smlscanFreeScanner();
 
   if (!g_storage->open(IO_ReadOnly))
   {
diff --git a/src/libdoxygen.pro.in b/src/libdoxygen.pro.in
index b230b2f..e8f33aa 100644
--- a/src/libdoxygen.pro.in
+++ b/src/libdoxygen.pro.in
@@ -108,6 +108,8 @@ HEADERS      =	arguments.h \
                 printdocvisitor.h \
                 pycode.h \
                 pyscanner.h \
+                smlcode.h \
+                smlscanner.h \
                 fortrancode.h \
                 fortranscanner.h \
                 dbusxmlscanner.h \
@@ -216,6 +218,8 @@ SOURCES      =	arguments.cpp \
 		pre.cpp \
 		pycode.cpp \
 		pyscanner.cpp \    
+		smlcode.cpp \
+		smlscanner.cpp \    
 		qhp.cpp \
 		qhpxmlwriter.cpp \
 		reflist.cpp \
diff --git a/src/libdoxygen.t.in b/src/libdoxygen.t.in
index f131f70..f810530 100644
--- a/src/libdoxygen.t.in
+++ b/src/libdoxygen.t.in
@@ -67,6 +67,12 @@ sub GenerateLex {
 #$ GenerateDep("pycode.cpp","pycode.l");
 #$ GenerateLex("pycode",0);
 
+#$ GenerateDep("smlscanner.cpp","smlscanner.l");
+#$ GenerateLex("smlscanner",0);
+
+#$ GenerateDep("smlcode.cpp","smlcode.l");
+#$ GenerateLex("smlcode",0);
+
 #$ GenerateDep("fortranscanner.cpp","fortranscanner.l");
 #$ GenerateLex("fortranscanner",1);
 
diff --git a/src/smlcode.h b/src/smlcode.h
new file mode 100644
index 0000000..5d242d4
--- /dev/null
+++ b/src/smlcode.h
@@ -0,0 +1,45 @@
+/******************************************************************************
+ *
+ * 
+ *
+ * Copyright (C) 1997-2013 by Dimitri van Heesch.
+ *
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation under the terms of the GNU General Public License is hereby 
+ * granted. No representations are made about the suitability of this software 
+ * for any purpose. It is provided "as is" without express or implied warranty.
+ * See the GNU General Public License for more details.
+ *
+ * Documents produced by Doxygen are derivative works derived from the
+ * input used in their production; they are not affected by this license.
+ *
+ */
+/*  This code is based on the work done by the MoxyPyDoxy team
+ *  (Linda Leong, Mike Rivera, Kim Truong, and Gabriel Estrada)
+ *  in Spring 2005 as part of CS 179E: Compiler Design Project
+ *  at the University of California, Riverside; the course was
+ *  taught by Peter H. Froehlich <phf@acm.org>.
+ */
+
+
+#ifndef SMLCODE_H
+#define SMLCODE_H
+
+#include "types.h"
+
+class CodeOutputInterface;
+class FileDef;
+class MemberDef;
+class QCString;
+class Definition;
+
+extern void parseSmlCode(CodeOutputInterface &,const char *,const QCString &,
+             bool ,const char *,FileDef *fd,
+	     int startLine,int endLine,bool inlineFragment,
+             MemberDef *memberDef,bool showLineNumbers,Definition *searchCtx,
+             bool collectXRefs);
+
+
+extern void resetSmlCodeParserState();
+
+#endif
diff --git a/src/smlcode.l b/src/smlcode.l
new file mode 100644
index 0000000..4ad3375
--- /dev/null
+++ b/src/smlcode.l
@@ -0,0 +1,1462 @@
+/******************************************************************************
+ *
+ *
+ *
+ * Copyright (C) 1997-2013 by Dimitri van Heesch.
+ *
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation under the terms of the GNU General Public License is hereby
+ * granted. No representations are made about the suitability of this software
+ * for any purpose. It is provided "as is" without express or implied warranty.
+ * See the GNU General Public License for more details.
+ *
+ * Documents produced by Doxygen are derivative works derived from the
+ * input used in their production; they are not affected by this license.
+ *
+ */
+/*  This code is based on the work done by the MoxyPyDoxy team
+ *  (Linda Leong, Mike Rivera, Kim Truong, and Gabriel Estrada)
+ *  in Spring 2005 as part of CS 179E: Compiler Design Project
+ *  at the University of California, Riverside; the course was
+ *  taught by Peter H. Froehlich <phf@acm.org>.
+ */
+
+
+%{
+
+#include <stdio.h>
+#include <qvaluestack.h>
+
+#include "smlcode.h"
+#include "message.h"
+
+#include "scanner.h"
+#include "entry.h"
+#include "doxygen.h"
+#include "outputlist.h"
+#include "util.h"
+#include "membername.h"
+#include "searchindex.h"
+#include "config.h"
+#include "groupdef.h"
+#include "classlist.h"
+#include "filedef.h"
+#include "namespacedef.h"
+#include "tooltip.h"
+
+// Toggle for some debugging info
+//#define DBG_CTX(x) fprintf x
+#define DBG_CTX(x) do { } while(0)
+
+#define YY_NEVER_INTERACTIVE 1
+#define YY_NO_INPUT 1
+
+static ClassSDict    g_codeClassSDict(17);
+static QCString      g_curClassName;
+static QStrList      g_curClassBases;
+
+
+static CodeOutputInterface * g_code;
+static const char *  g_inputString;     //!< the code fragment as text
+static int	     g_inputPosition;   //!< read offset during parsing
+static const char *  g_currentFontClass;
+static bool          g_needsTermination;
+static Definition   *g_searchCtx;
+static bool          g_collectXRefs;
+static int           g_inputLines;      //!< number of line in the code fragment
+static int	     g_yyLineNr;        //!< current line number
+static FileDef *     g_sourceFileDef;
+static Definition *  g_currentDefinition;
+static MemberDef *   g_currentMemberDef;
+static bool          g_includeCodeFragment;
+static QCString      g_realScope;
+//static bool          g_insideBody;
+static int           g_bodyCurlyCount;
+static bool          g_searchingForBody;
+static QCString      g_classScope;
+static int           g_paramParens;
+//static int           g_anchorCount;
+
+static bool          g_exampleBlock;
+static QCString      g_exampleName;
+static QCString      g_exampleFile;
+
+static QCString      g_type;
+static QCString      g_name;
+
+static bool          g_doubleStringIsDoc;
+static bool          g_doubleQuote;
+static bool          g_noSuiteFound;
+static int           g_stringContext;
+
+static void endFontClass();
+
+
+/*! Represents a stack of variable to class mappings as found in the
+ *  code. Each scope is enclosed in pushScope() and popScope() calls.
+ *  Variables are added by calling addVariables() and one can search
+ *  for variable using findVariable().
+ */
+class SmlVariableContext
+{
+  public:
+    static const ClassDef *dummyContext;
+    class Scope : public SDict<ClassDef>
+    {
+      public:
+	Scope() : SDict<ClassDef>(17) {}
+    };
+
+    SmlVariableContext()
+    {
+      m_scopes.setAutoDelete(TRUE);
+    }
+
+    virtual ~SmlVariableContext()
+    {
+    }
+
+    void pushScope()
+    {
+      m_scopes.append(new Scope);
+    }
+
+    void popScope()
+    {
+      if (m_scopes.count()>0)
+      {
+	m_scopes.remove(m_scopes.count()-1);
+      }
+    }
+
+    void clear()
+    {
+      m_scopes.clear();
+      m_globalScope.clear();
+    }
+
+    void clearExceptGlobal()
+    {
+      m_scopes.clear();
+    }
+
+    void addVariable(const QCString &type,const QCString &name);
+    ClassDef *findVariable(const QCString &name);
+
+  private:
+    Scope        m_globalScope;
+    QList<Scope> m_scopes;
+};
+
+void SmlVariableContext::addVariable(const QCString &type,const QCString &name)
+{
+  //printf("SmlVariableContext::addVariable(%s,%s)\n",type.data(),name.data());
+  QCString ltype = type.simplifyWhiteSpace();
+  QCString lname = name.simplifyWhiteSpace();
+
+  Scope *scope = m_scopes.count()==0 ? &m_globalScope : m_scopes.getLast();
+  ClassDef *varType;
+  if (
+      (varType=g_codeClassSDict[ltype]) ||  // look for class definitions inside the code block
+      (varType=getResolvedClass(g_currentDefinition,g_sourceFileDef,ltype)) // look for global class definitions
+     )
+  {
+    scope->append(lname,varType); // add it to a list
+  }
+  else
+  {
+    if (m_scopes.count()>0) // for local variables add a dummy entry so the name
+			    // is hidden to avoid FALSE links to global variables with the same name
+			    // TODO: make this work for namespaces as well!
+    {
+      scope->append(lname,dummyContext);
+    }
+  }
+}
+
+ClassDef *SmlVariableContext::findVariable(const QCString &name)
+{
+  if (name.isEmpty()) return 0;
+  ClassDef *result = 0;
+  QListIterator<Scope> sli(m_scopes);
+  Scope *scope;
+  // search from inner to outer scope
+  for (sli.toLast();(scope=sli.current());--sli)
+  {
+    result = scope->find(name);
+    if (result)
+    {
+      return result;
+    }
+  }
+  // nothing found -> also try the global scope
+  result=m_globalScope.find(name);
+  return result;
+}
+
+static SmlVariableContext g_theVarContext;
+const ClassDef *SmlVariableContext::dummyContext = (ClassDef*)0x8;
+
+class SmlCallContext
+{
+  public:
+    struct Ctx
+    {
+      Ctx() : name(g_name), type(g_type), cd(0) {}
+      QCString name;
+      QCString type;
+      ClassDef *cd;
+    };
+
+    SmlCallContext()
+    {
+      m_classList.append(new Ctx);
+      m_classList.setAutoDelete(TRUE);
+    }
+
+    virtual ~SmlCallContext() {}
+
+    void setClass(ClassDef *cd)
+    {
+      Ctx *ctx = m_classList.getLast();
+      if (ctx)
+      {
+	ctx->cd=cd;
+      }
+    }
+    void pushScope()
+    {
+      m_classList.append(new Ctx);
+    }
+
+    void popScope()
+    {
+      if (m_classList.count()>1)
+      {
+	Ctx *ctx = m_classList.getLast();
+	if (ctx)
+	{
+	  g_name = ctx->name;
+	  g_type = ctx->type;
+	}
+	m_classList.removeLast();
+      }
+      else
+      {
+      }
+    }
+
+    void clear()
+    {
+      m_classList.clear();
+      m_classList.append(new Ctx);
+    }
+
+    ClassDef *getClass() const
+    {
+      Ctx *ctx = m_classList.getLast();
+
+      if (ctx)
+	return ctx->cd;
+      else
+	return 0;
+    }
+
+  private:
+    QList<Ctx> m_classList;
+};
+
+static SmlCallContext g_theCallContext;
+
+
+/*! counts the number of lines in the input */
+static int countLines()
+{
+  const char *p=g_inputString;
+  char c;
+  int count=1;
+  while ((c=*p))
+  {
+    p++ ;
+    if (c=='\n') count++;
+  }
+  if (p>g_inputString && *(p-1)!='\n')
+  { // last line does not end with a \n, so we add an extra
+    // line and explicitly terminate the line after parsing.
+    count++,
+    g_needsTermination=TRUE;
+  }
+  return count;
+}
+
+static void setCurrentDoc(const QCString &anchor)
+{
+  if (Doxygen::searchIndex)
+  {
+    if (g_searchCtx)
+    {
+      Doxygen::searchIndex->setCurrentDoc(g_searchCtx,g_searchCtx->anchor(),FALSE);
+    }
+    else
+    {
+      Doxygen::searchIndex->setCurrentDoc(g_sourceFileDef,anchor,TRUE);
+    }
+  }
+}
+
+static void addToSearchIndex(const char *text)
+{
+  if (Doxygen::searchIndex)
+  {
+    Doxygen::searchIndex->addWord(text,FALSE);
+  }
+}
+
+
+static ClassDef *stripClassName(const char *s,Definition *d=g_currentDefinition)
+{
+  int pos=0;
+  QCString type = s;
+  QCString className;
+  QCString templSpec;
+  while (extractClassNameFromType(type,pos,className,templSpec)!=-1)
+  {
+    QCString clName=className+templSpec;
+
+    ClassDef *cd=0;
+    if (!g_classScope.isEmpty())
+    {
+      cd=getResolvedClass(d,g_sourceFileDef,g_classScope+"::"+clName);
+    }
+    if (cd==0)
+    {
+      cd=getResolvedClass(d,g_sourceFileDef,clName);
+    }
+    if (cd)
+    {
+      return cd;
+    }
+  }
+
+  return 0;
+}
+
+
+/*! start a new line of code, inserting a line number if g_sourceFileDef
+ * is TRUE. If a definition starts at the current line, then the line
+ * number is linked to the documentation of that definition.
+ */
+static void startCodeLine()
+{
+  //if (g_currentFontClass) { g_code->endFontClass(); }
+  if (g_sourceFileDef)
+  {
+    //QCString lineNumber,lineAnchor;
+    //lineNumber.sprintf("%05d",g_yyLineNr);
+    //lineAnchor.sprintf("l%05d",g_yyLineNr);
+   
+    Definition *d   = g_sourceFileDef->getSourceDefinition(g_yyLineNr);
+    //printf("startCodeLine %d d=%p\n",g_yyLineNr,d);
+    //g_code->startLineNumber();
+    if (!g_includeCodeFragment && d && d->isLinkableInProject())
+    {
+      g_currentDefinition = d;
+      g_currentMemberDef = g_sourceFileDef->getSourceMember(g_yyLineNr);
+      //g_insideBody = FALSE;
+      g_searchingForBody = TRUE;
+      g_realScope = d->name().copy();
+      g_classScope = d->name().copy();
+      //printf("Real scope: `%s'\n",g_realScope.data());
+      g_bodyCurlyCount = 0;
+      QCString lineAnchor;
+      lineAnchor.sprintf("l%05d",g_yyLineNr);
+      if (g_currentMemberDef)
+      {
+        g_code->writeLineNumber(g_currentMemberDef->getReference(),
+	                        g_currentMemberDef->getOutputFileBase(),
+	                        g_currentMemberDef->anchor(),g_yyLineNr);
+        setCurrentDoc(lineAnchor);
+      }
+      else
+      {
+        g_code->writeLineNumber(d->getReference(),
+	                        d->getOutputFileBase(),
+	                        0,g_yyLineNr);
+        setCurrentDoc(lineAnchor);
+      }
+    }
+    else
+    {
+      //g_code->codify(lineNumber);
+      g_code->writeLineNumber(0,0,0,g_yyLineNr);
+    }
+    //g_code->endLineNumber();
+  }
+  g_code->startCodeLine(g_sourceFileDef); 
+  if (g_currentFontClass)
+  {
+    g_code->startFontClass(g_currentFontClass);
+  }
+}
+
+
+static void codify(const char* text)
+{
+  g_code->codify(text);
+}
+
+static void endCodeLine()
+{
+  endFontClass();
+  g_code->endCodeLine();
+}
+
+static void nextCodeLine()
+{
+  const char *fc = g_currentFontClass;
+  endCodeLine();
+  if (g_yyLineNr<g_inputLines)
+  {
+    g_currentFontClass = fc;
+    startCodeLine();
+  }
+}
+
+
+/*! writes a link to a fragment \a text that may span multiple lines, inserting
+ * line numbers for each line. If \a text contains newlines, the link will be
+ * split into multiple links with the same destination, one for each line.
+ */
+static void writeMultiLineCodeLink(CodeOutputInterface &ol,
+		  Definition *d,
+		  const char *text)
+{
+  static bool sourceTooltips = Config_getBool("SOURCE_TOOLTIPS");
+  TooltipManager::instance()->addTooltip(d);
+  QCString ref  = d->getReference();
+  QCString file = d->getOutputFileBase();
+  QCString anchor = d->anchor();
+  QCString tooltip;
+  if (!sourceTooltips) // fall back to simple "title" tooltips
+  {
+    tooltip = d->briefDescriptionAsTooltip();
+  }
+  bool done=FALSE;
+  char *p=(char *)text;
+  while (!done)
+  {
+    char *sp=p;
+    char c;
+    while ((c=*p++) && c!='\n') { }
+    if (c=='\n')
+    {
+      g_yyLineNr++;
+      *(p-1)='\0';
+      //printf("writeCodeLink(%s,%s,%s,%s)\n",ref,file,anchor,sp);
+      ol.writeCodeLink(ref,file,anchor,sp,tooltip);
+      nextCodeLine();
+    }
+    else
+    {
+      //printf("writeCodeLink(%s,%s,%s,%s)\n",ref,file,anchor,sp);
+      ol.writeCodeLink(ref,file,anchor,sp,tooltip);
+      done=TRUE;
+    }
+  }
+}
+
+
+static void codifyLines(char *text)
+{
+  //printf("codifyLines(%d,\"%s\")\n",g_yyLineNr,text);
+  char *p=text,*sp=p;
+  char c;
+  bool done=FALSE;
+  while (!done)
+  {
+    sp=p;
+    while ((c=*p++) && c!='\n') { }
+    if (c=='\n')
+    {
+      g_yyLineNr++;
+      *(p-1)='\0';
+      g_code->codify(sp);
+      nextCodeLine();
+    }
+    else
+    {
+      g_code->codify(sp);
+      done=TRUE;
+    }
+  }
+}
+
+#if 0
+static QCString fileLocation()
+{
+  QCString result = g_sourceFileDef?g_sourceFileDef->absFilePath():QCString("[unknown]");
+  result+=":"+QCString().setNum(g_yyLineNr);
+  result+=":"+QCString().setNum(1);
+  return result;
+}
+
+static void addDocCrossReference(MemberDef *src,MemberDef *dst)
+{
+  static bool referencedByRelation = Config_getBool("REFERENCED_BY_RELATION");
+  static bool callerGraph =  Config_getBool("CALLER_GRAPH");
+  static bool referencesRelation = Config_getBool("REFERENCES_RELATION");
+  static bool callGraph = Config_getBool("CALL_GRAPH");
+  if (dst->isTypedef() || dst->isEnumerate()) return; // don't add types
+  //printf("addDocCrossReference src=%s,dst=%s\n",src->name().data(),dst->name().data());
+  if ((referencedByRelation || callerGraph) && (src->isFunction() || src->isSlot()))
+  {
+    dst->addSourceReferencedBy(src,fileLocation());
+  }
+  if ((referencesRelation || callGraph) && (src->isFunction() || src->isSlot()))
+  {
+    src->addSourceReferences(dst,fileLocation());
+  }
+}
+#endif
+
+
+
+static bool getLinkInScope(const QCString &c,  // scope
+			   const QCString &m,  // member
+			   const char *memberText, // exact text
+			   CodeOutputInterface &ol,
+			   const char *text
+			  )
+{
+  MemberDef    *md;
+  ClassDef     *cd;
+  FileDef      *fd;
+  NamespaceDef *nd;
+  GroupDef     *gd;
+  //printf("Trying `%s'::`%s'\n",c.data(),m.data());
+  if (getDefs(c,m,"()",md,cd,fd,nd,gd,FALSE,g_sourceFileDef) &&
+      md->isLinkable())
+  {
+    //Definition *d=0;
+    //if (cd) d=cd; else if (nd) d=nd; else if (fd) d=fd; else d=gd;
+
+    Definition *d = md->getOuterScope()==Doxygen::globalScope ?
+		    md->getBodyDef() : md->getOuterScope();
+    //printf("Found! d=%s\n",d?d->name().data():"<none>");
+    if (md->getGroupDef()) d = md->getGroupDef();
+    if (d && d->isLinkable())
+    {
+      g_theCallContext.setClass(stripClassName(md->typeString(),md->getOuterScope()));
+      //printf("g_currentDefinition=%p g_currentMemberDef=%p\n",
+      //        g_currentDefinition,g_currentMemberDef);
+
+      if (g_currentDefinition && g_currentMemberDef &&
+	  md!=g_currentMemberDef && g_collectXRefs)
+      {
+	addDocCrossReference(g_currentMemberDef,md);
+      }
+      //printf("d->getReference()=`%s' d->getOutputBase()=`%s' name=`%s' member name=`%s'\n",d->getReference().data(),d->getOutputFileBase().data(),d->name().data(),md->name().data());
+
+      writeMultiLineCodeLink(ol,md, text ? text : memberText);
+      addToSearchIndex(text ? text : memberText);
+      return TRUE;
+    }
+  }
+  return FALSE;
+}
+
+static bool getLink(const char *className,
+		    const char *memberName,
+		    CodeOutputInterface &ol,
+		    const char *text=0)
+{
+  QCString m=removeRedundantWhiteSpace(memberName);
+  QCString c=className;
+  if (!getLinkInScope(c,m,memberName,ol,text))
+  {
+    if (!g_curClassName.isEmpty())
+    {
+      if (!c.isEmpty()) c.prepend("::");
+      c.prepend(g_curClassName);
+      return getLinkInScope(c,m,memberName,ol,text);
+    }
+    return FALSE;
+  }
+  return TRUE;
+}
+
+/*
+  For a given string in the source code,
+  finds its class or global id and links to it.
+*/
+static void generateClassOrGlobalLink(CodeOutputInterface &ol,char *clName,
+                                      bool typeOnly=FALSE)
+{
+  QCString className=clName;
+
+  // Don't do anything for empty text
+  if (className.isEmpty()) return;
+
+  DBG_CTX((stderr,"generateClassOrGlobalLink(className=%s)\n",className.data()));
+
+  ClassDef *cd=0,*lcd=0;  /** Class def that we may find */
+  MemberDef *md=0;        /** Member def that we may find */
+  //bool isLocal=FALSE;
+
+  if ((lcd=g_theVarContext.findVariable(className))==0) // not a local variable
+  {
+    Definition *d = g_currentDefinition;
+    QCString scope = substitute(className,".","::");
+
+    cd = getResolvedClass(d,g_sourceFileDef,substitute(className,".","::"),&md);
+
+    DBG_CTX((stderr,"d=%s g_sourceFileDef=%s\n",
+        d?d->displayName().data():"<null>",
+        g_currentDefinition?g_currentDefinition->displayName().data():"<null>"));
+    DBG_CTX((stderr,"is found as a type %s\n",cd?cd->name().data():"<null>"));
+
+    if (cd==0 && md==0) // also see if it is variable or enum or enum value
+    {
+      NamespaceDef *nd = getResolvedNamespace(scope);
+      if (nd)
+      {
+        writeMultiLineCodeLink(ol,nd,clName);
+        addToSearchIndex(className);
+        return;
+      }
+      else if (getLink(g_classScope,clName,ol,clName))
+      {
+	return;
+      }
+    }
+  }
+  else
+  {
+    if (lcd!=SmlVariableContext::dummyContext) 
+    {
+      g_theCallContext.setClass(lcd);
+    }
+    //isLocal=TRUE;
+    DBG_CTX((stderr,"is a local variable cd=%p!\n",cd));
+  }
+
+  if (cd && cd->isLinkable()) // is it a linkable class
+  {
+    writeMultiLineCodeLink(ol,cd,clName);
+    addToSearchIndex(className);
+    if (md)
+    {
+      Definition *d = md->getOuterScope()==Doxygen::globalScope ?
+                      md->getBodyDef() : md->getOuterScope();
+      if (md->getGroupDef()) d = md->getGroupDef();
+      if (d && d->isLinkable() && md->isLinkable() && 
+          g_currentMemberDef && g_collectXRefs)
+      {
+        addDocCrossReference(g_currentMemberDef,md);
+      }
+    }
+  }
+  else // not a class, maybe a global member
+  {
+    int scopeEnd = className.findRev(".");
+    if (scopeEnd!=-1 && !typeOnly) // name with explicit scope
+    {
+      QCString scope = substitute(className.left(scopeEnd),".","::");
+      QCString locName = className.right(className.length()-scopeEnd-1);
+      ClassDef *mcd = getClass(scope);
+      DBG_CTX((stderr,"scope=%s locName=%s mcd=%p\n",scope.data(),locName.data(),mcd));
+      if (mcd)
+      {
+	MemberDef *md = mcd->getMemberByName(locName);
+	if (md)
+	{
+          g_theCallContext.setClass(stripClassName(md->typeString(),md->getOuterScope()));
+          writeMultiLineCodeLink(ol,md,clName);
+          addToSearchIndex(className);
+	  Definition *d = md->getOuterScope()==Doxygen::globalScope ?
+	                  md->getBodyDef() : md->getOuterScope();
+	  if (md->getGroupDef()) d = md->getGroupDef();
+	  if (d && d->isLinkable() && md->isLinkable() && 
+              g_currentMemberDef && g_collectXRefs)
+	  {
+	    addDocCrossReference(g_currentMemberDef,md);
+	  }
+	  return;
+	}
+      }
+      else // check namespace as well
+      {
+        NamespaceDef *mnd = getResolvedNamespace(scope);
+        if (mnd)
+        {
+  	  MemberDef *md=mnd->getMemberByName(locName);
+	  if (md)
+          {
+	    //printf("name=%s scope=%s\n",locName.data(),scope.data());
+	    g_theCallContext.setClass(stripClassName(md->typeString(),md->getOuterScope()));
+            writeMultiLineCodeLink(ol,md,clName);
+            addToSearchIndex(className);
+	    Definition *d = md->getOuterScope()==Doxygen::globalScope ?
+	                    md->getBodyDef() : md->getOuterScope();
+	    if (md->getGroupDef()) d = md->getGroupDef();
+	    if (d && d->isLinkable() && md->isLinkable() && 
+                g_currentMemberDef && g_collectXRefs)
+	    {
+	      addDocCrossReference(g_currentMemberDef,md);
+	    }
+	    return;
+          }
+        }
+      }
+    }
+    
+    // nothing found, just write out the word
+    codifyLines(clName);
+    addToSearchIndex(clName);
+  }
+}
+
+/*
+   As of June 1, this function seems to work
+   for file members, but scopes are not
+   being correctly tracked for classes
+   so it doesn't work for classes yet.
+
+*/
+static void generateFunctionLink(CodeOutputInterface &ol,char *funcName)
+{
+  //CodeClassDef *ccd=0;
+  ClassDef *ccd=0;
+  QCString locScope=g_classScope.copy();
+  QCString locFunc=removeRedundantWhiteSpace(funcName);
+  DBG_CTX((stdout,"*** locScope=%s locFunc=%s\n",locScope.data(),locFunc.data()));
+  int i=locFunc.findRev("::");
+  if (i>0)
+  {
+    locScope=locFunc.left(i);
+    locFunc=locFunc.right(locFunc.length()-i-2).stripWhiteSpace();
+  }
+  //printf("generateFunctionLink(%s) classScope=`%s'\n",locFunc.data(),locScope.data());
+  if (!locScope.isEmpty() && (ccd=g_codeClassSDict[locScope]))
+  {
+    //printf("using classScope %s\n",g_classScope.data());
+    if (ccd->baseClasses())
+    {
+      BaseClassListIterator bcli(*ccd->baseClasses());
+      for ( ; bcli.current() ; ++bcli)
+      {
+	if (getLink(bcli.current()->classDef->name(),locFunc,ol,funcName))
+	{
+	  return;
+	}
+      }
+    }
+  }
+  if (!getLink(locScope,locFunc,ol,funcName))
+  {
+    generateClassOrGlobalLink(ol,funcName);
+  }
+  return;
+}
+
+static bool findMemberLink(CodeOutputInterface &ol,Definition *sym,const char *symName)
+{
+  //printf("sym %s outerScope=%s equal=%d\n",
+  //    sym->name().data(),sym->getOuterScope()->name().data(),
+  //    sym->getOuterScope()==g_currentDefinition);
+
+  if (sym->getOuterScope() &&
+      sym->getOuterScope()->definitionType()==Definition::TypeClass &&
+      g_currentDefinition->definitionType()==Definition::TypeClass)
+  {
+    ClassDef *cd = (ClassDef*)sym->getOuterScope();
+    ClassDef *thisCd = (ClassDef *)g_currentDefinition;
+    if (sym->definitionType()==Definition::TypeMember)
+    {
+      if (g_currentMemberDef && g_collectXRefs)
+      {
+	addDocCrossReference(g_currentMemberDef,(MemberDef*)sym);
+      }
+    }
+    DBG_CTX((stderr,"cd=%s thisCd=%s\n",cd?cd->name().data():"<none>",thisCd?thisCd->name().data():"<none>"));
+
+    // TODO: find the nearest base class in case cd is a base class of
+    // thisCd 
+    if (cd==thisCd || (thisCd && thisCd->isBaseClass(cd,TRUE)))
+    {
+      writeMultiLineCodeLink(ol,sym,symName);
+      return TRUE;
+    }
+  }
+  return FALSE;
+}
+
+static void findMemberLink(CodeOutputInterface &ol,char *symName)
+{
+  //printf("Member reference: %s scope=%s member=%s\n",
+  //    yytext,
+  //    g_currentDefinition?g_currentDefinition->name().data():"<none>",
+  //    g_currentMemberDef?g_currentMemberDef->name().data():"<none>"
+  //    );
+  if (g_currentDefinition)
+  {
+    DefinitionIntf *di = Doxygen::symbolMap->find(symName);
+    if (di)
+    {
+      if (di->definitionType()==DefinitionIntf::TypeSymbolList) // multiple symbols
+      {
+	DefinitionListIterator dli(*(DefinitionList*)di);
+	Definition *sym;
+	for (dli.toFirst();(sym=dli.current());++dli)
+	{
+	  if (findMemberLink(ol,sym,symName)) return;
+	}
+      }
+      else // single symbol
+      {
+	if (findMemberLink(ol,(Definition*)di,symName)) return;
+      }
+    }
+  }
+  //printf("sym %s not found\n",&yytext[5]);
+  codify(symName);
+}
+
+static void startFontClass(const char *s)
+{
+  endFontClass();
+  g_code->startFontClass(s);
+  g_currentFontClass=s;
+}
+
+static void endFontClass()
+{
+  if (g_currentFontClass)
+  {
+    g_code->endFontClass();
+    g_currentFontClass=0;
+  }
+}
+
+#undef YY_INPUT
+#define YY_INPUT(buf,result,max_size) result=yyread(buf,max_size);
+
+static int yyread(char *buf,int max_size)
+{
+  int c=0;
+  while( c < max_size && g_inputString[g_inputPosition] )
+  {
+    *buf = g_inputString[g_inputPosition++] ;
+    c++; buf++;
+  }
+  return c;
+}
+
+%}
+
+
+BB                [ \t]+
+B                 [ \t]*
+NEWLINE           \n
+
+DIGIT             [0-9]
+LETTER            [A-Za-z]
+NONEMPTY          [A-Za-z0-9_]
+EXPCHAR           [#(){}\[\],:.%/\\=`*~|&<>!;+-]
+NONEMPTYEXP       [^ \t\n:]
+PARAMNONEMPTY     [^ \t\n():]
+
+IDENTIFIER        ({LETTER}|"'")({LETTER}|{DIGIT}|"_"|"'")*
+
+BORDER            ([^A-Za-z0-9])
+
+POUNDCOMMENT      "#".*
+
+TRISINGLEQUOTE    "'''"
+TRIDOUBLEQUOTE    "\"\"\""
+LONGSTRINGCHAR    [^\\"']
+ESCAPESEQ         ("\\")(.)
+LONGSTRINGITEM    ({LONGSTRINGCHAR}|{ESCAPESEQ})
+SMALLQUOTE        ("\"\""|"\""|"'"|"''")
+LONGSTRINGBLOCK   ({LONGSTRINGITEM}+|{SMALLQUOTE})
+
+SHORTSTRING       ("'"{SHORTSTRINGITEM}*"'"|'"'{SHORTSTRINGITEM}*'"')
+SHORTSTRINGITEM   ({SHORTSTRINGCHAR}|{ESCAPESEQ})
+SHORTSTRINGCHAR   [^\\\n"]
+STRINGLITERAL     {STRINGPREFIX}?( {SHORTSTRING} | {LONGSTRING})
+STRINGPREFIX      ("r"|"u"|"ur"|"R"|"U"|"UR"|"Ur"|"uR")
+KEYWORD ("lambda"|"import"|"class"|"assert"|"as"|"from"|"global"|"def"|"True"|"False")
+FLOWKW  ("or"|"and"|"is"|"not"|"print"|"for"|"in"|"if"|"try"|"except"|"yield"|"raise"|"break"|"continue"|"pass"|"if"|"return"|"while"|"elif"|"else"|"finally")
+QUOTES            ("\""[^"]*"\"")
+SINGLEQUOTES      ("'"[^']*"'")
+
+LONGINTEGER       {INTEGER}("l"|"L")
+INTEGER           ({DECIMALINTEGER}|{OCTINTEGER}|{HEXINTEGER})
+DECIMALINTEGER    ({NONZERODIGIT}{DIGIT}*|"0")
+OCTINTEGER        "0"{OCTDIGIT}+
+HEXINTEGER        "0"("x"|"X"){HEXDIGIT}+
+NONZERODIGIT      [1-9]
+OCTDIGIT          [0-7]
+HEXDIGIT          ({DIGIT}|[a-f]|[A-F])
+FLOATNUMBER       ({POINTFLOAT}|{EXPONENTFLOAT})
+POINTFLOAT        ({INTPART}?{FRACTION}|{INTPART}".")
+EXPONENTFLOAT     ({INTPART}|{POINTFLOAT}){EXPONENT}
+INTPART             {DIGIT}+
+FRACTION             "."{DIGIT}+
+EXPONENT             ("e"|"E")("+"|"-")?{DIGIT}+
+IMAGNUMBER ({FLOATNUMBER}|{INTPART})("j"|"J")
+ATOM              ({IDENTIFIER}|{LITERAL}|{ENCLOSURE})
+ENCLOSURE             ({PARENTH_FORM}|{LIST_DISPLAY}|{DICT_DISPLAY}|{STRING_CONVERSION})
+LITERAL             ({STRINGLITERAL}|{INTEGER}|{LONGINTEGER}|{FLOATNUMBER}|{IMAGNUMBER})
+PARENTH_FORM       "("{EXPRESSION_LIST}?")"
+TEST             ({AND_TEST}("or"{AND_TEST})*|{LAMBDA_FORM})
+TESTLIST             {TEST}( ","{TEST})*","?
+LIST_DISPLAY        "["{LISTMAKER}?"]"
+LISTMAKER             {EXPRESSION}({LIST_FOR}|(","{EXPRESSION})*","?)
+LIST_ITER             ({LIST_FOR}|{LIST_IF})
+LIST_FOR             "for"{EXPRESSION_LIST}"in"{TESTLIST}{LIST_ITER}?
+LIST_IF             "if"{TEST}{LIST_ITER}?
+DICT_DISPLAY             "\{"{KEY_DATUM_LIST}?"\}"
+KEY_DATUM_LIST       {KEY_DATUM}(","{KEY_DATUM})*","?
+KEY_DATUM              {EXPRESSION}":"{EXPRESSION}
+STRING_CONVERSION        "`"{EXPRESSION_LIST}"`"
+PRIMARY             ({ATOM}|{ATTRIBUTEREF}|{SUBSCRIPTION}|{SLICING}|{CALL})
+ATTRIBUTEREF             {PRIMARY}"."{IDENTIFIER}
+SUBSCRIPTION             {PRIMARY}"["{EXPRESSION_LIST}"]"
+SLICING            ({SIMPLE_SLICING}|{EXTENDED_SLICING})
+SIMPLE_SLICING             {PRIMARY}"["{SHORT_SLICE}"]"
+EXTENDED_SLICING           {PRIMARY}"["{SLICE_LIST}"]"
+SLICE_LIST          {SLICE_ITEM}(","{SLICE_ITEM})*","?
+SLICE_ITEM           ({EXPRESSION}|{PROPER_SLICE}|{ELLIPSIS})
+PROPER_SLICE           ({SHORT_SLICE}|{LONG_SLICE})
+SHORT_SLICE              {LOWER_BOUND}?":"{UPPER_BOUND}?
+LONG_SLICE             {SHORT_SLICE}":"{STRIDE}?
+LOWER_BOUND             {EXPRESSION}
+UPPER_BOUND             {EXPRESSION}
+STRIDE             {EXPRESSION}
+ELLIPSIS             "..."
+CALL             {PRIMARY}"("({ARGUMENT_LIST}","?)?")"
+ARGUMENT_LIST       ({POSITIONAL_ARGUMENTS}(","{KEYWORD_ARGUMENTS})?(",""*"{EXPRESSION})?(",""**"{EXPRESSION})?|{KEYWORD_ARGUMENTS}(",""*"{EXPRESSION})?(",""**"{EXPRESSION})?|"*"{EXPRESSION}(",""**"{EXPRESSION})?|"**"{EXPRESSION})
+POSITIONAL_ARGUMENTS             {EXPRESSION}(","{EXPRESSION})*
+KEYWORD_ARGUMENTS              {KEYWORD_ITEM}(","{KEYWORD_ITEM})*
+KEYWORD_ITEM           {IDENTIFIER}"="{EXPRESSION}
+POWER             {PRIMARY}("**"{U_EXPR})?
+U_EXPR            ({POWER}|"-"{U_EXPR}|"+"{U_EXPR}|"\~"{U_EXPR})
+M_EXPR            ({U_EXPR}|{M_EXPR}"*"{U_EXPR}|{M_EXPR}"//"{U_EXPR}|{M_EXPR}"/"{U_EXPR}|{M_EXPR}"\%"{U_EXPR})
+A_EXPR         ({M_EXPR}|{A_EXPR}"+"{M_EXPR}|{A_EXPR}"-"{M_EXPR}
+SHIFT_EXPR            ({A_EXPR}|{SHIFT_EXPR}("<<"|">>"){A_EXPR})
+AND_EXPR            ({SHIFT_EXPR}|{AND_EXPR}"\;SPMamp;"{SHIFT_EXPR}
+XOR_EXPR            ({AND_EXPR}|{XOR_EXPR}"\textasciicircum"{AND_EXPR})
+OR_EXPR            ({XOR_EXPR}|{OR_EXPR}"|"{ XOR_EXPR})
+
+COMPARISON             {OR_EXPR}({COMP_OPERATOR}{OR_EXPR})*
+COMP_OPERATOR         ("<"|">"|"=="|">="|"<="|"<>"|"!="|"is""not"?|"not"?"in")
+EXPRESSION            ({OR_TEST}|{LAMBDA_FORM})
+OR_TEST             ({AND_TEST}|{OR_TEST}"or"{AND_TEST})
+AND_TEST          ({NOT_TEST}|{AND_TEST}"and"{NOT_TEST})
+NOT_TEST           ({COMPARISON}|"not"{NOT_TEST})
+LAMBDA_FORM       "lambda"{PARAMETER_LIST}?":"{EXPRESSION}
+EXPRESSION_LIST      {EXPRESSION}(","{EXPRESSION})*","?
+SIMPLE_STMT       ({EXPRESSION_STMT}|{ASSERT_STMT}|{ASSIGNMENT_STMT}|{AUGMENTED_ASSIGNMENT_STMT}|{PASS_STMT}|{DEL_STMT}|{PRINT_STMT}|{RETURN_STMT}|{YIELD_STMT}|{RAISE_STMT}|{BREAK_STMT}|{CONTINUE_STMT}|{IMPORT_STMT}|{GLOBAL_STMT}|{EXEC_STMT})
+EXPRESSION_STMT     {EXPRESSION_LIST}
+ASSERT_STMT             "assert"{EXPRESSION}(","{EXPRESSION})?
+ASSIGNMENT_STMT     ({TARGET_LIST}"=")+{EXPRESSION_LIST}
+TARGET_LIST             {TARGET}(","{TARGET})*","?
+TARGET           ({IDENTIFIER}|"("{TARGET_LIST}")"|"["{TARGET_LIST}"]"|{ATTRIBUTEREF}|{SUBSCRIPTION}|{SLICING})
+
+
+%option noyywrap
+%option nounput
+
+%x Body
+
+%x FunctionDec
+%x FunctionParams
+
+%x ClassDec
+%x ClassInheritance
+
+%x Suite
+%x SuiteStart
+%x SuiteMaintain
+%x SuiteContinuing
+
+%x LongString
+
+%x SingleQuoteString
+%x DoubleQuoteString
+%x TripleString
+
+%%
+
+<Body,Suite>{
+      "fun"{BB}                     {
+					startFontClass("keyword");
+					codify(yytext);
+					endFontClass();
+					BEGIN( FunctionDec );
+				    }
+
+      "class"{BB}                   {
+					startFontClass("keyword");
+					codify(yytext);
+					endFontClass();
+					BEGIN( ClassDec );
+				    }
+      "None"                        {
+					startFontClass("keywordtype");
+					codify(yytext);
+					endFontClass();
+				    }
+      "self."{IDENTIFIER}/"("       {
+					codify("self.");
+					findMemberLink(*g_code,&yytext[5]);
+				    }
+      "self."{IDENTIFIER}           {
+					codify("self.");
+					findMemberLink(*g_code,&yytext[5]);
+				    }
+}
+
+<ClassDec>{IDENTIFIER}              {
+
+					generateClassOrGlobalLink(*g_code,yytext);
+					// codify(yytext);
+					g_curClassName = yytext;
+					g_curClassBases.clear();
+					BEGIN( ClassInheritance );
+				    }
+
+<ClassInheritance>{
+   ({BB}|[(,)])                     {
+					codify(yytext);
+				    }
+
+   ({IDENTIFIER}".")*{IDENTIFIER}   {
+					// The parser
+					// is assuming
+					// that ALL identifiers
+					// in this state
+					// are base classes;
+					// it doesn't check to see
+					// that the first parenthesis
+					// has been seen.
+
+					// This is bad - it should
+					// probably be more strict
+					// about what to accept.
+
+					g_curClassBases.inSort(yytext);
+					generateClassOrGlobalLink(*g_code,yytext);
+					// codify(yytext);
+				    }
+
+    ":"                             {
+				      codify(yytext);
+
+				      // Assume this will
+				      // be a one-line suite;
+				      // found counter-example
+				      // in SuiteStart.
+
+				      // Push a class scope
+
+				      ClassDef *classDefToAdd = new ClassDef("<code>",1,1,g_curClassName,ClassDef::Class,0,0,FALSE);
+				      g_codeClassSDict.append(g_curClassName,classDefToAdd);
+				      char *s=g_curClassBases.first();
+				      while (s)
+				      {
+					ClassDef *baseDefToAdd;
+					baseDefToAdd=g_codeClassSDict[s];
+
+					// Try to find class in global
+					// scope
+					if (baseDefToAdd==0)
+					{
+					  baseDefToAdd=getResolvedClass(g_currentDefinition,g_sourceFileDef,s);
+					}
+
+					if (baseDefToAdd && baseDefToAdd!=classDefToAdd)
+					{
+					  classDefToAdd->insertBaseClass(baseDefToAdd,s,Public,Normal);
+					}
+
+					s=g_curClassBases.next();
+				      }
+
+				      // Reset class-parsing variables.
+				      g_curClassName.resize(0);
+				      g_curClassBases.clear();
+
+				      g_noSuiteFound = TRUE;
+				      BEGIN( SuiteStart );
+				    }
+}
+
+
+<FunctionDec>{
+    {IDENTIFIER}                    {
+					generateFunctionLink(*g_code,yytext);
+					BEGIN( FunctionParams );
+				    }
+}
+
+<FunctionParams>{
+    ({BB}|",")                      {
+					 // Parses delimiters
+					 codify(yytext);
+				    }
+
+    ({IDENTIFIER}|{PARAMNONEMPTY}+) {
+					 codify(yytext);
+				    }
+
+    "="                             {
+				      codify(yytext);
+
+				      // Assume this will
+				      // be a one-line suite;
+				      // found counter-example
+				      // in SuiteStart.
+				      g_noSuiteFound = TRUE;
+				      BEGIN( SuiteStart );
+				    }
+}
+
+<Body,Suite>{
+
+    {KEYWORD}                  {
+				 // Position-sensitive rules!
+				 // Must come AFTER keyword-triggered rules
+				 // Must come BEFORE identifier NONEMPTY-like rules
+				 //   to syntax highlight.
+
+				 startFontClass("keyword");
+				 codify(yytext);
+				 endFontClass();
+			       }
+
+    {FLOWKW}                   {
+				 startFontClass("keywordflow");
+				 codify(yytext);
+				 endFontClass();
+			       }
+    ({IDENTIFIER}".")*{IDENTIFIER}/"("  {
+				 generateClassOrGlobalLink(*g_code,yytext);
+			       }
+    ({IDENTIFIER}".")+{IDENTIFIER} {
+				 generateClassOrGlobalLink(*g_code,yytext,TRUE);
+			       }
+    {IDENTIFIER}               { codify(yytext); }
+
+}
+
+
+
+<SuiteStart>{
+
+    {BB}                               {
+					 codify(yytext);
+				       }
+    "pass"			       {
+					  startFontClass("keyword");
+					  codifyLines(yytext);
+					  endFontClass();
+					  BEGIN(Body);
+				       }
+    {KEYWORD}                          {
+					  startFontClass("keyword");
+					  codifyLines(yytext);
+					  endFontClass();
+
+					  g_noSuiteFound = FALSE;
+				       }
+
+    {FLOWKW}                           {
+					  startFontClass("keywordflow");
+					  codifyLines(yytext);
+					  endFontClass();
+
+					  g_noSuiteFound = FALSE;
+				       }
+    {IDENTIFIER}                       {
+					 codify(yytext);
+				       }
+
+
+    {POUNDCOMMENT}                     {
+					  // This eats EVERYTHING
+					  // except the newline
+					  startFontClass("comment");
+					  codifyLines(yytext);
+					  endFontClass();
+				       }
+
+    {NEWLINE}                          {
+					  codifyLines(yytext);
+				       }
+}
+
+<SuiteMaintain>{
+
+    {BB}/({NONEMPTY}|{EXPCHAR}) {
+				 // This implements poor
+				 // indendation-tracking;
+				 // should be improved.
+				 // (translate tabs to space, etc)
+				 codifyLines(yytext);
+			       }
+
+    "\n"|({BB}"\n")            {
+				 // If this ever succeeds,
+				 // it means that this is
+				 // a blank line, and
+				 // can be ignored.
+				 codifyLines(yytext);
+			       }
+
+    ""/({NONEMPTY}|{EXPCHAR})  {
+				 // Default rule; matches
+				 // the empty string, assuming
+				 // real text starts here.
+				 // Just go straight to Body.
+			       }
+}
+
+
+<Suite>{NEWLINE}               {
+				 codifyLines(yytext);
+				 BEGIN( SuiteMaintain );
+			       }
+<Body>{IDENTIFIER}	       {
+				 codify(yytext);
+			       }
+<Body>{NEWLINE}                {
+				 codifyLines(yytext);
+			       }
+
+<SingleQuoteString>{ // Single quoted string like 'That\'s a """nice""" string!'
+    \\{B}\n                    { // line continuation
+				 codifyLines(yytext);
+			       }
+    \\.			       { // espaced char
+				 codify(yytext);
+			       }
+    {STRINGPREFIX}?{TRIDOUBLEQUOTE} { // tripple double quotes
+				 codify(yytext);
+			       }
+    "'"			       { // end of the string
+				 codify(yytext);
+				 endFontClass();
+				 BEGIN(g_stringContext);
+			       }
+    [^"'\n\\]+		       { // normal chars
+				 codify(yytext);
+			       }
+    .			       { // normal char
+				 codify(yytext);
+			       }
+}
+
+<DoubleQuoteString>{ // Double quoted string like "That's \"a '''nice'''\" string!"
+    \\{B}\n                    { // line continuation
+				 codifyLines(yytext);
+			       }
+    \\.			       { // espaced char
+				 codify(yytext);
+			       }
+    {STRINGPREFIX}?{TRISINGLEQUOTE} { // tripple single quotes
+				 codify(yytext);
+			       }
+    "\""		       { // end of the string
+				 codify(yytext);
+				 endFontClass();
+				 BEGIN(g_stringContext);
+			       }
+    [^"'\n\\]+		       { // normal chars
+				 codify(yytext);
+			       }
+    .			       { // normal char
+				 codify(yytext);
+			       }
+}
+
+<TripleString>{
+    {TRIDOUBLEQUOTE}   |
+    {TRISINGLEQUOTE}   {
+			  codify(yytext);
+			  if (g_doubleQuote==(yytext[0]=='"'))
+			  {
+			    endFontClass();
+			    BEGIN(g_stringContext);
+			  }
+		       }
+    {LONGSTRINGBLOCK}  {
+			 codifyLines(yytext);
+		       }
+    \n		       {
+			 codifyLines(yytext);
+		       }
+    .		       {
+			 codify(yytext);
+		       }
+}
+
+  /*
+<*>({NONEMPTY}|{EXPCHAR}|{BB})           { // This should go one character at a time.
+				 codify(yytext);
+				 // printf("[smlcode] '%s' [ state %d ]  [line %d] no match\n",
+				 //       yytext, YY_START, g_yyLineNr);
+
+				 //endFontClass();
+				 BEGIN(Body);
+			       }
+   */
+
+<*>{STRINGPREFIX}?{TRISINGLEQUOTE} |
+<*>{STRINGPREFIX}?{TRIDOUBLEQUOTE} {
+				 startFontClass("stringliteral");
+				 g_stringContext=YY_START;
+				 g_doubleQuote=yytext[yyleng-1]=='"';
+				 codify(yytext);
+				 BEGIN(TripleString);
+			       }
+<*>{STRINGPREFIX}?"'"	       { // single quoted string
+				 startFontClass("stringliteral");
+				 g_stringContext=YY_START;
+				 codify(yytext);
+				 BEGIN(SingleQuoteString);
+			       }
+<*>{STRINGPREFIX}?"\""         { // double quoted string
+				 startFontClass("stringliteral");
+				 g_stringContext=YY_START;
+				 codify(yytext);
+				 BEGIN(DoubleQuoteString);
+			       }
+<*>{POUNDCOMMENT}              {
+				 if (YY_START==SingleQuoteString ||
+				     YY_START==DoubleQuoteString ||
+				     YY_START==TripleString
+				    )
+				 {
+				   REJECT;
+				 }
+				 // This eats EVERYTHING
+				 // except the newline
+				 startFontClass("comment");
+				 codifyLines(yytext);
+				 endFontClass();
+			       }
+<*>{NEWLINE}                   {
+				 codifyLines(yytext);
+				 //printf("[smlcode] %d NEWLINE [line %d] no match\n",
+				 //       YY_START, g_yyLineNr);
+
+				 //endFontClass();
+				 BEGIN(Body);
+			       }
+
+<*>[ \t]+                      {
+				 codify(yytext);
+				 BEGIN(Body);
+			       }
+<*>.                           {
+				 codify(yytext);
+				 // printf("[smlcode] '%s' [ state %d ]  [line %d] no match\n",
+				 //        yytext, YY_START, g_yyLineNr);
+
+				 //endFontClass();
+				 BEGIN(Body);
+			       }
+
+%%
+
+/*@ ----------------------------------------------------------------------------
+ */
+
+void resetSmlCodeParserState()
+{
+  g_currentDefinition = 0;
+  g_currentMemberDef = 0;
+  g_doubleStringIsDoc = FALSE;
+  g_paramParens = 0;
+  BEGIN( Body );
+}
+
+void parseSmlCode(CodeOutputInterface &od,const char * /*className*/,
+		 const QCString &s,bool exBlock, const char *exName,
+		 FileDef *fd,int startLine,int endLine,bool /*inlineFragment*/,
+		 MemberDef *,bool,Definition *searchCtx,bool collectXRefs)
+{
+
+  //printf("***parseCode()\n");
+
+  //--------------------------------------
+  if (s.isEmpty()) return;
+  TooltipManager::instance()->clearTooltips();
+  g_code = &od;
+  g_inputString   = s;
+  g_inputPosition = 0;
+  g_currentFontClass = 0;
+  g_needsTermination = FALSE;
+  g_searchCtx=searchCtx;
+  g_collectXRefs=collectXRefs;
+  if (endLine!=-1)
+    g_inputLines  = endLine+1;
+  else
+    g_inputLines  = countLines();
+
+  if (startLine!=-1)
+    g_yyLineNr    = startLine;
+  else
+    g_yyLineNr    = 1;
+
+  g_exampleBlock  = exBlock;
+  g_exampleName   = exName;
+  g_sourceFileDef = fd;
+
+  bool cleanupSourceDef = FALSE;
+  if (fd==0)
+  {
+    // create a dummy filedef for the example
+    g_sourceFileDef = new FileDef("",(exName?exName:"generated"));
+    cleanupSourceDef = TRUE;
+  }
+  if (g_sourceFileDef)
+  {
+    setCurrentDoc("l00001");
+  }
+
+  // Starts line 1 on the output
+  startCodeLine();
+
+  smlcodeYYrestart( smlcodeYYin );
+
+  smlcodeYYlex();
+
+
+  if (g_needsTermination)
+  {
+    endCodeLine();
+  }
+  if (fd)
+  {
+    TooltipManager::instance()->writeTooltips(*g_code);
+  }
+  if (cleanupSourceDef)
+  {
+    // delete the temporary file definition used for this example
+    delete g_sourceFileDef;
+    g_sourceFileDef=0;
+  }
+  return;
+}
+
+
+#if !defined(YY_FLEX_SUBMINOR_VERSION)
+extern "C" { // some bogus code to keep the compiler happy
+  void smlcodeYYdummy() { yy_flex_realloc(0,0); }
+}
+#elif YY_FLEX_SUBMINOR_VERSION<33
+#error "You seem to be using a version of flex newer than 2.5.4. These are currently incompatible with 2.5.4, and do NOT work with doxygen! Please use version 2.5.4 or expect things to be parsed wrongly! A bug report has been submitted (#732132)."
+#endif
diff --git a/src/smlscanner.h b/src/smlscanner.h
new file mode 100644
index 0000000..729af8f
--- /dev/null
+++ b/src/smlscanner.h
@@ -0,0 +1,67 @@
+/******************************************************************************
+ *
+ * 
+ *
+ * Copyright (C) 1997-2013 by Dimitri van Heesch.
+ *
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation under the terms of the GNU General Public License is hereby 
+ * granted. No representations are made about the suitability of this software 
+ * for any purpose. It is provided "as is" without express or implied warranty.
+ * See the GNU General Public License for more details.
+ *
+ * Documents produced by Doxygen are derivative works derived from the
+ * input used in their production; they are not affected by this license.
+ *
+ */
+/*  This code is based on the work done by the MoxyPyDoxy team
+ *  (Linda Leong, Mike Rivera, Kim Truong, and Gabriel Estrada)
+ *  in Spring 2005 as part of CS 179E: Compiler Design Project
+ *  at the University of California, Riverside; the course was
+ *  taught by Peter H. Froehlich <phf@acm.org>.
+ */
+
+
+#ifndef SMLSCANNER_H
+#define SMLSCANNER_H
+
+#include "parserintf.h"
+
+/** \brief Sml Language parser using state-based lexical scanning.
+ *
+ * This is the Sml language parser for doxygen.
+ */
+class SmlLanguageScanner : public ParserInterface
+{
+  public:
+    virtual ~SmlLanguageScanner() {}
+    void startTranslationUnit(const char *) {}
+    void finishTranslationUnit() {}
+    void parseInput(const char * fileName,
+                    const char *fileBuf,
+                    Entry *root,
+                    bool sameTranslationUnit,
+                    QStrList &filesInSameTranslationUnit);
+    bool needsPreprocessing(const QCString &extension);
+    void parseCode(CodeOutputInterface &codeOutIntf,
+                   const char *scopeName,
+                   const QCString &input,
+                   SrcLangExt lang,
+                   bool isExampleBlock,
+                   const char *exampleName=0,
+                   FileDef *fileDef=0,
+                   int startLine=-1,
+                   int endLine=-1,
+                   bool inlineFragment=FALSE,
+                   MemberDef *memberDef=0,
+                   bool showLineNumbers=TRUE,
+                   Definition *searchCtx=0,
+                   bool collectXrefs=TRUE
+                  );
+    void resetCodeParserState();
+    void parsePrototype(const char *text);
+};
+
+void smlscanFreeScanner();
+
+#endif
diff --git a/src/smlscanner.l b/src/smlscanner.l
new file mode 100644
index 0000000..87f1ec4
--- /dev/null
+++ b/src/smlscanner.l
@@ -0,0 +1,1513 @@
+%{
+
+/* includes */
+#include <stdio.h>
+#include <stdlib.h>
+#include <assert.h>
+#include <ctype.h>
+
+#include <qarray.h>
+#include <qregexp.h>
+#include <unistd.h>
+#include <qfile.h>
+#include <qfileinfo.h>
+
+#include "smlscanner.h"
+#include "entry.h"
+#include "message.h"
+#include "config.h"
+#include "doxygen.h"
+#include "util.h"
+#include "defargs.h"
+#include "language.h"
+#include "commentscan.h"
+#include "smlcode.h"
+#include "arguments.h"
+
+// Toggle for some debugging info
+//#define DBG_CTX(x) fprintf x
+#define DBG_CTX(x) do { } while(0)
+
+#define YY_NEVER_INTERACTIVE 1
+#define YY_NO_INPUT 1
+
+static ParserInterface *g_thisParser;
+static const char *     inputString;
+static int		inputPosition;
+static QFile            inputFile;
+
+static Protection	protection;
+
+static Entry*		current_root = 0 ;
+static Entry*		current      = 0 ;
+static Entry*		previous     = 0 ;
+static Entry*		bodyEntry    = 0 ;
+static int		yyLineNr     = 1 ;
+static QCString		yyFileName;
+static MethodTypes      mtype;
+static bool             gstat;
+static Specifier        virt;
+
+static int              docBlockContext;
+static QCString         docBlock;
+static QCString         docBlockName;
+static bool             docBlockInBody;
+static bool             docBlockJavaStyle;
+static bool             docBrief;
+static bool             docBlockSpecial;
+
+/* used to handle tuples */
+static char             g_atomStart;
+static char             g_atomEnd;
+static int              g_atomCount;
+
+static bool             g_doubleQuote;
+static bool             g_inComment;
+static bool             g_specialBlock;
+static int              g_stringContext;
+static QGString *       g_copyString;
+
+static QDict<QCString>  g_packageNameCache(257);
+static QCString         g_packageScope;
+
+static QCString         g_moduleScope;
+static QCString         g_packageName;
+
+static bool             g_inSignature;
+static QCString         g_valDoc;
+static QCString         g_andKeyword;
+static QCString         g_documentingStructure;
+static QCString         g_defVal;
+static int              g_braceCount;
+
+static bool             g_lexInit = FALSE;
+static bool             g_packageCommentAllowed;
+
+/* used for detecting what the 'and' keyword is declaring. */
+typedef QCString stackElement;
+
+/* a stack for the 'and' keyword. */
+typedef struct {stackElement contents[1000]; int maxSize; int top; } stackType ;
+
+/* pushes a declaritive keyword onto the stack. */
+stackType stack_push(stackType stack, stackElement element)
+{
+  stack.contents[++stack.top] = element;
+  return stack;
+}
+
+/* tests whether a stack is empty. */
+int stack_isEmpty(stackType stack)
+{
+  return stack.top < 0;
+}
+
+/* pops an element from the stack. */
+stackType stack_pop(stackType stack)
+{
+  if (stack_isEmpty(stack)) {
+    fprintf(stderr, "Error: attempted to pop element from empty stack!.\n");
+    exit(1);
+  }
+  stack.top--;
+  return stack;
+}
+
+/* gets the top element of the stack. */
+stackElement stack_top(stackType stack) {
+  if (stack_isEmpty(stack)) {
+    fprintf(stderr, "Error: attempted to get top element of an empty stack!.\n");
+    exit(1);
+  }
+  return stack.contents[stack.top];
+}
+
+/* declare a new stack, myStack. Used for handling the 'and' keyword */
+static stackType myStack;
+
+static void initParser()
+{
+  protection = Public;
+  mtype = Method;
+  gstat = FALSE;
+  virt = Normal;
+  previous = 0;
+  g_packageCommentAllowed = TRUE;
+  g_packageNameCache.setAutoDelete(TRUE);
+}
+
+static void initEntry()
+{
+  current->protection = protection ;
+  current->mtype      = mtype;
+  current->virt       = virt;
+  current->stat       = gstat;
+  current->lang       = SrcLangExt_Sml;
+  current->setParent(current_root);
+  initGroupInfo(current);
+  gstat = FALSE;
+}
+
+static void newEntry()
+{
+  previous = current;
+  current_root->addSubEntry(current);
+  current = new Entry ;
+  initEntry();
+}
+
+static void newVariable()
+{
+  if (!current->name.isEmpty() && current->name.at(0)=='_') // mark as private
+  {
+    current->protection=Private;
+  }
+  if (current_root->section&Entry::COMPOUND_MASK) // mark as class variable
+  {
+    current->stat = TRUE;
+  }
+  newEntry();
+}
+
+static QCString findPackageScopeFromPath(const QCString &path)
+{
+  QCString *pScope = g_packageNameCache.find(path);
+  if (pScope)
+  {
+    return *pScope;
+  }
+  QFileInfo pf(path+"/__init__.py"); // found package initialization file
+  if (pf.exists())
+  {
+    int i=path.findRev('/');
+    if (i!=-1)
+    {
+      QCString scope = findPackageScopeFromPath(path.left(i));
+      if (!scope.isEmpty())
+      {
+        scope+="::";
+      }
+      scope+=path.mid(i+1);
+      g_packageNameCache.insert(path,new QCString(scope));
+      return scope;
+    }
+  }
+  return "";
+}
+
+static QCString findPackageScope(const char *fileName)
+{
+  if (fileName==0) return "";
+  QFileInfo fi(fileName);
+  return findPackageScopeFromPath(fi.dirPath(TRUE).data());
+}
+
+//-----------------------------------------------------------------------------
+
+static void lineCount()
+{
+  DBG_CTX((stderr,"yyLineNr=%d\n",yyLineNr));
+  for (const char *p = yytext; *p; ++p)
+  {
+    yyLineNr += (*p == '\n') ;
+  }
+}
+
+static void incLineNr()
+{
+  DBG_CTX((stderr,"yyLineNr=%d\n",yyLineNr));
+  yyLineNr++;
+}
+
+#if 0
+// Appends the current-name to current-type;
+// Destroys current-name.
+// Destroys current->args and current->argList
+static void addType( Entry* current )
+{
+    uint tl=current->type.length();
+    if ( tl>0 && !current->name.isEmpty() && current->type.at(tl-1)!='.')
+    {
+      current->type += ' ' ;
+    }
+    current->type += current->name ;
+    current->name.resize(0) ;
+    tl=current->type.length();
+    if ( tl>0 && !current->args.isEmpty() && current->type.at(tl-1)!='.')
+    {
+      current->type += ' ' ;
+    }
+    current->type += current->args ;
+    current->args.resize(0) ;
+    current->argList->clear();
+}
+
+static QCString stripQuotes(const char *s)
+{
+  QCString name;
+  if (s==0 || *s==0) return name;
+  name=s;
+  if (name.at(0)=='"' && name.at(name.length()-1)=='"')
+  {
+    name=name.mid(1,name.length()-2);
+  }
+  return name;
+}
+#endif
+//-----------------------------------------------------------------
+
+//-----------------------------------------------------------------
+static void startCommentBlock(bool brief)
+{
+  if (brief)
+  {
+    current->briefFile = yyFileName;
+    current->briefLine = yyLineNr;
+  }
+  else
+  {
+    current->docFile = yyFileName;
+    current->docLine = yyLineNr;
+  }
+}
+
+static void handleCommentBlock(const QCString &doc,bool brief)
+{
+  //printf("handleCommentBlock(doc=[%s] brief=%d docBlockInBody=%d docBlockJavaStyle=%d\n",
+  //    doc.data(),brief,docBlockInBody,docBlockJavaStyle);
+
+  // TODO: Fix me
+  docBlockInBody=FALSE;
+
+  if (docBlockInBody && previous && !previous->doc.isEmpty())
+  {
+    previous->doc=previous->doc.stripWhiteSpace()+"\n\n";
+  }
+
+  int position = 0;
+  bool needsEntry;
+  int lineNr = brief ? current->briefLine : current->docLine;
+  while (parseCommentBlock(
+        g_thisParser,
+        (docBlockInBody && previous) ? previous : current,
+        doc,     // text
+        yyFileName, // file
+        lineNr,
+        docBlockInBody ? FALSE : brief,
+    docBlockJavaStyle, // javadoc style // or FALSE,
+        docBlockInBody,
+        protection,
+        position,
+        needsEntry)
+     ) // need to start a new entry
+  {
+    if (needsEntry)
+    {
+      newEntry();
+    }
+  }
+  if (needsEntry)
+  {
+    newEntry();
+  }
+
+}
+
+static void endOfDef(int correction=0)
+{
+  if (bodyEntry)
+  {
+    bodyEntry->endBodyLine  = yyLineNr-correction;
+    bodyEntry = 0;
+  }
+  newEntry();
+}
+
+static inline void addToString(const char *s)
+{
+  if (g_copyString) (*g_copyString)+=s;
+}
+
+static void initTriDoubleQuoteBlock()
+{
+  docBlockContext   = YY_START;
+  docBlockInBody    = FALSE;
+  docBlockJavaStyle = TRUE;
+  docBlockSpecial   = yytext[3]=='!';
+  docBlock.resize(0);
+  g_doubleQuote = TRUE;
+  startCommentBlock(FALSE);
+}
+
+static void initTriSingleQuoteBlock()
+{
+  docBlockContext   = YY_START;
+  docBlockInBody    = FALSE;
+  docBlockJavaStyle = TRUE;
+  docBlockSpecial   = yytext[3]=='!';
+  docBlock.resize(0);
+  g_doubleQuote = FALSE;
+  startCommentBlock(FALSE);
+}
+
+static void initSpecialBlock()
+{
+  docBlockContext   = YY_START;
+  docBlockInBody    = FALSE;
+  docBlockJavaStyle = TRUE;
+  docBrief = TRUE;
+  docBlock.resize(0);
+  startCommentBlock(TRUE);
+}
+
+static void searchFoundDef()
+{
+  current->fileName  = yyFileName;
+  current->startLine = yyLineNr;
+  current->bodyLine  = yyLineNr;
+  current->section = Entry::FUNCTION_SEC;
+  current->protection = protection = Public;
+  current->lang = SrcLangExt_Sml;
+  current->virt = Normal;
+  current->stat = gstat;
+  current->mtype = mtype = Method;
+  current->type.resize(0);
+  current->name.resize(0);
+  current->args.resize(0);
+  current->argList->clear();
+  g_packageCommentAllowed = FALSE;
+  gstat=FALSE;
+}
+
+static void searchFoundClass()
+{
+  current->section = Entry::CLASS_SEC;
+  current->argList->clear();
+  current->type += "structure" ;
+  current->fileName  = yyFileName;
+  current->startLine  = yyLineNr;
+  current->bodyLine  = yyLineNr;
+  g_packageCommentAllowed = FALSE;
+}
+
+#undef	YY_INPUT
+#define	YY_INPUT(buf,result,max_size) result=yyread(buf,max_size);
+
+static int yyread(char *buf,int max_size)
+{
+  int c=0;
+  while ( c < max_size && inputString[inputPosition] )
+  {
+    *buf = inputString[inputPosition++] ;
+    //printf("%d (%c)\n",*buf,*buf);
+    c++; buf++;
+  }
+  return c;
+}
+
+%}
+
+       /* start command character */
+
+
+
+BB                [ \t]+
+B                 [ \t]*
+NEWLINE           \n
+BN                [ \t\n]
+
+DIGIT             [0-9]
+
+HEXNUMBER         "0"[xX][0-9a-fA-F]+[lL]?
+OCTNUMBER         "0"[0-7]+[lL]?
+NUMBER            {DIGIT}+[lLjJ]?
+INTNUMBER         {HEXNUMBER}|{OCTNUMBER}|{NUMBER}
+FLOATNUMBER       {DIGIT}+"."{DIGIT}+([eE][+\-]?{DIGIT}+)?[jJ]?
+LETTER            [A-Za-z]
+NONEMPTY          [A-Za-z0-9_]
+EXPCHAR           [#(){}\[\],:.%/\\=`*~|&<>!;+-]
+NONEMPTYEXP       [^ \t\n:]
+PARAMNONEMPTY     [^ \t\n():]
+
+IDENTIFIER        ({LETTER}|"'")({LETTER}|{DIGIT}|"_"|"'")*
+
+SCOPE             {IDENTIFIER}("."{IDENTIFIER})*
+BORDER            ([^A-Za-z0-9])
+
+TRISINGLEQUOTE    "'''"(!)?
+TRIDOUBLEQUOTE    "\"\"\""(!)?
+LONGSTRINGCHAR    [^\\"']
+ESCAPESEQ         ("\\")(.)
+LONGSTRINGITEM    ({LONGSTRINGCHAR}|{ESCAPESEQ})
+SMALLQUOTE        ("\"\""|"\""|"'"|"''")
+LONGSTRINGBLOCK   ({LONGSTRINGITEM}+|{SMALLQUOTE})
+
+SHORTSTRING       ("'"{SHORTSTRINGITEM}*"'"|'"'{SHORTSTRINGITEM}*'"')
+SHORTSTRINGITEM   ({SHORTSTRINGCHAR}|{ESCAPESEQ})
+SHORTSTRINGCHAR   [^\\\n"]
+STRINGLITERAL     {STRINGPREFIX}?( {SHORTSTRING} | {LONGSTRING})
+STRINGPREFIX      ("r"|"u"|"ur"|"R"|"U"|"UR"|"Ur"|"uR")
+DECKW             ("(** "|"val"|"type"|"datatype"|"abstype"|"exception"|"local"|"open"|"infix"|"infixr"|"nofix"|"eqtype"|"include"|"end")
+
+STARTDOCSYMS      "(** "
+
+%option noyywrap
+
+  /* Main start state */
+
+%x Search
+%x SearchMemVars
+
+  /* Mid-comment states */
+
+  /* %x FuncDoubleComment */
+  /* %x ClassDoubleComment */
+%x TryClassDocString
+%x TripleComment
+%x StandardComment
+%x LinkToStructure
+%x SpecialComment
+%x Test
+
+
+  /* Function states */
+
+%x FunctionDec
+%x FunctionParams
+%x SmlPattern
+%x SmlVal
+%x SmlType
+%x SmlEqtype
+%x SmlAbstype
+%x SmlDatatype
+%x SmlException
+%x SmlInclude
+%x SmlQuoteString
+%x FunctionParamDefVal
+%x StructureWrapper
+
+  /* Class states */
+
+%x ClassDec
+%x ClassInheritance
+%x ClassBody
+
+/* Variable states */
+%x VariableAtom
+
+
+/* String states */
+
+%x SingleQuoteString
+%x DoubleQuoteString
+%x TripleString
+
+%%
+
+  /* ------------ Function recognition rules -------------- */
+
+<Search>{
+
+     "fun"{BB} {
+                 g_andKeyword = "fun";
+                 searchFoundDef();
+                 BEGIN( FunctionDec );
+               }
+     "structure"{BB}{IDENTIFIER}{B}"="{B}"struct" {yyless(0); BEGIN( StructureWrapper); }
+     "structure"{BB}{IDENTIFIER}{B}"="{B}{IDENTIFIER}   	{}
+     "structure"{BB}{IDENTIFIER}{B}":"{B}{IDENTIFIER}{B}^"="	{}
+     "structure"{BB}{IDENTIFIER}{B}":"{B}{IDENTIFIER}{B}\n	{}
+     "structure"{BB}	{
+                          g_andKeyword = "structure";
+                          g_inSignature = false;
+                          DBG_CTX((stderr,"Found class at %d\n",yyLineNr));
+                          searchFoundClass();
+                          BEGIN( ClassDec ) ;
+                        }
+     "functor"{BB}      {
+                          g_inSignature = false;
+                          searchFoundClass();
+                          BEGIN( ClassDec ) ;
+                       }
+     "signature"{BB}   {
+                          g_andKeyword = "signature";
+                          g_inSignature = true;
+                          DBG_CTX((stderr,"Found class at %d\n",yyLineNr));
+                          searchFoundClass();
+                          BEGIN( ClassDec ) ;
+                       }
+    "let"             { if (!g_inComment) {myStack = stack_push(myStack,g_andKeyword);} }
+    "local"           { if (!g_inComment) {myStack = stack_push(myStack,g_andKeyword);} }
+    "abstype"         { if (!g_inComment) {myStack = stack_push(myStack,g_andKeyword);} }
+    "end"             {
+                        if (!g_inComment) {
+                          // ending a structure, signature, or functor
+                          if (stack_isEmpty(myStack)) {
+			    endOfDef();
+			  }
+			  else {
+                            g_andKeyword = stack_top(myStack);
+                            myStack = stack_pop(myStack);
+			  }
+
+			}
+                      }
+
+     "and"{BB}    	{   // continuation of some definition, unput a space and then the keyword
+                            unput(' ');
+                            int i;
+                            for ( i = g_andKeyword.length() - 1; i >= 0; --i )
+                                unput( g_andKeyword[i] );
+                        }
+     "val"{BB}"_"{B}"="      {}
+     "val"{BB}      { g_andKeyword = "val"; BEGIN( SmlVal ); }
+     "exception"{B} { g_andKeyword = "exception"; BEGIN( SmlException ); }
+     "include"{B}   { BEGIN( SmlInclude );   }
+     "type"{BB}     { g_andKeyword = "type"; BEGIN( SmlType );      }
+     "eqtype"{B}    { BEGIN( SmlEqtype );    }
+     "datatype"{B}  {
+                      g_andKeyword = "datatype";
+                      g_defVal.resize(0);
+                      BEGIN( SmlDatatype );
+                    }
+     "abstype"{B}   { BEGIN( SmlAbstype ); }
+
+
+     "'"              { // start of a single quoted string
+                        g_stringContext=YY_START;
+                        g_copyString=0;
+                        g_packageCommentAllowed = FALSE;
+                        BEGIN( SingleQuoteString );
+                      }
+     "\""             { // start of a double quoted string
+                        if (g_inComment == 0) {
+                          g_stringContext=YY_START;
+                          g_copyString=0;
+                          g_packageCommentAllowed = FALSE;
+                          BEGIN( DoubleQuoteString );
+                        }
+                      }
+    "@staticmethod"  {
+                        gstat=TRUE;
+                      }
+    {IDENTIFIER}      { // some other identifier
+                        g_packageCommentAllowed = FALSE;
+                      }
+    ^{BB}             {}
+
+    {NEWLINE}+        { lineCount(); }
+
+    {TRIDOUBLEQUOTE}  { // start of a comment block
+                        initTriDoubleQuoteBlock();
+                        BEGIN(TripleComment);
+                      }
+
+    {TRISINGLEQUOTE}  { // start of a comment block
+                        initTriSingleQuoteBlock();
+                        BEGIN(TripleComment);
+                      }
+    {STARTDOCSYMS}/[^*]    {  // start of a special comment
+                        g_inComment = TRUE;
+                        g_packageCommentAllowed = FALSE;
+                        initSpecialBlock();
+                        BEGIN(SpecialComment);
+                      }
+    "(*"              { g_inComment = 1; BEGIN(StandardComment); }
+    [^\n]             { // any other character...
+                        // This is the major default
+                        // that should catch everything
+                        // else in Body.
+                      }
+}
+
+<StructureWrapper>{
+     "structure"{BB}	{ // start of structure declaration
+                          g_andKeyword = "structure";
+                          g_inSignature = false;
+                          DBG_CTX((stderr,"Found class at %d\n",yyLineNr));
+                          searchFoundClass();
+                          BEGIN( ClassDec ) ;
+                        }
+}
+
+<SmlVal>{
+
+"("          {
+                if (current->mtype!=Property) {
+		  current->type = "tuple";
+		}
+                g_atomStart='(';
+		g_atomEnd=')';
+		g_atomCount=1;
+		BEGIN( VariableAtom );
+             }
+
+{IDENTIFIER} {
+               if (g_inSignature) {
+                 g_valDoc = "View documentation in ";
+                 g_valDoc += g_documentingStructure;
+                 g_valDoc += ".";
+                 g_valDoc += yytext;
+                 g_valDoc += ".";
+                 handleCommentBlock(g_valDoc, true);
+               }
+
+               current->section   = Entry::VARIABLE_SEC;
+               current->name      = QCString(yytext).stripWhiteSpace();
+	       current->type      = "val";
+               current->fileName  = yyFileName;
+               current->startLine = yyLineNr;
+               current->bodyLine  = yyLineNr;
+               g_packageCommentAllowed = FALSE;
+               newVariable();
+               BEGIN(Search);
+             }
+
+}
+
+<VariableAtom>{
+    [\(\[\{]	      {
+                        if (g_atomStart==*yytext)
+			  g_atomCount++;
+                      }
+    [\)\]\}]	      {
+                        if (g_atomEnd==*yytext)
+			  g_atomCount--;
+			if (g_atomCount==0)
+			{
+
+                        current->section   = Entry::VARIABLE_SEC;
+                        current->name      = current->initializer;
+	                current->type      = "val";
+                        current->fileName  = yyFileName;
+                        current->startLine = yyLineNr;
+                        current->bodyLine  = yyLineNr;
+                        g_packageCommentAllowed = FALSE;
+
+			  newVariable();
+                          BEGIN(Search);
+			}
+                      }
+   ,                  {
+                        current->section   = Entry::VARIABLE_SEC;
+                        current->name      = current->initializer;
+                        current->type      = "val";
+                        current->fileName  = yyFileName;
+                        current->startLine = yyLineNr;
+                        current->bodyLine  = yyLineNr;
+                        g_packageCommentAllowed = FALSE;
+			newVariable();
+		      }
+   .		      { current->initializer+=*yytext; }
+   \n		      {
+      		        current->initializer+=*yytext;
+     			incLineNr();
+     		      }
+
+}
+
+<SmlType>{
+{IDENTIFIER}/{B} {
+               if (g_inSignature) {
+                 g_valDoc = "View documentation in ";
+                 g_valDoc += g_documentingStructure;
+                 g_valDoc += ".";
+                 g_valDoc += yytext;
+                 g_valDoc += ".";
+                 handleCommentBlock(g_valDoc, true);
+               }
+                          current->section   = Entry::VARIABLE_SEC;
+                          current->name      = QCString(yytext).stripWhiteSpace();
+			  current->type      = "type";
+                          current->protection = Protected;
+                          current->fileName  = yyFileName;
+                          current->startLine = yyLineNr;
+                          current->bodyLine  = yyLineNr;
+                          g_packageCommentAllowed = FALSE;
+                          newVariable();
+                          BEGIN(Search);
+                        }
+}
+
+<SmlDatatype>{
+"'"{IDENTIFIER}{B}{IDENTIFIER} {
+               current->section   = Entry::VARIABLE_SEC;
+               current->name      = QCString(yytext).stripWhiteSpace();
+	       current->type      = "datatype";
+               current->protection = Protected;
+               current->fileName  = yyFileName;
+               current->startLine = yyLineNr;
+               current->bodyLine  = yyLineNr;
+               g_packageCommentAllowed = FALSE;
+               newVariable();
+               yyless(0);
+               BEGIN(Search);
+             }
+"(".*")"{B}{IDENTIFIER} {
+               current->section   = Entry::VARIABLE_SEC;
+               current->name      = QCString(yytext).stripWhiteSpace();
+	       current->type      = "datatype";
+               current->protection = Protected;
+               current->fileName  = yyFileName;
+               current->startLine = yyLineNr;
+               current->bodyLine  = yyLineNr;
+               g_packageCommentAllowed = FALSE;
+               newVariable();
+               yyless(0);
+               BEGIN(Search);
+             }
+{IDENTIFIER} {
+               current->section   = Entry::VARIABLE_SEC;
+               current->name      = QCString(yytext).stripWhiteSpace();
+	       current->type      = "datatype";
+               current->protection = Protected;
+               current->fileName  = yyFileName;
+               current->startLine = yyLineNr;
+               current->bodyLine  = yyLineNr;
+               g_packageCommentAllowed = FALSE;
+               newVariable();
+               yyless(0);
+               BEGIN(Search);
+             }
+}
+
+<SmlEqtype>{
+{IDENTIFIER}/{B} {
+                          current->section   = Entry::VARIABLE_SEC;
+                          current->name      = QCString(yytext).stripWhiteSpace();
+			  current->type      = "eqtype";
+                          current->protection = Protected;
+                          current->fileName  = yyFileName;
+                          current->startLine = yyLineNr;
+                          current->bodyLine  = yyLineNr;
+                          g_packageCommentAllowed = FALSE;
+                          newVariable();
+                          BEGIN(Search);
+                        }
+}
+
+<SmlAbstype>{
+{IDENTIFIER}/{B} {
+                          current->section   = Entry::VARIABLE_SEC;
+                          current->name      = QCString(yytext).stripWhiteSpace();
+			  current->type      = "abstype";
+                          current->protection = Protected;
+                          current->fileName  = yyFileName;
+                          current->startLine = yyLineNr;
+                          current->bodyLine  = yyLineNr;
+                          g_packageCommentAllowed = FALSE;
+                          newVariable();
+                          BEGIN(Search);
+                        }
+}
+
+<SmlException>{
+{IDENTIFIER}/{B} {
+               if (g_inSignature) {
+                 g_valDoc = "View documentation in ";
+                 g_valDoc += g_documentingStructure;
+                 g_valDoc += ".";
+                 g_valDoc += yytext;
+                 g_valDoc += ".";
+                 handleCommentBlock(g_valDoc, true);
+               }
+
+                   current->section   = Entry::VARIABLE_SEC;
+                   current->name      = QCString(yytext).stripWhiteSpace();
+		   current->type      = "exn";
+                   current->fileName  = yyFileName;
+                   current->startLine = yyLineNr;
+                   current->bodyLine  = yyLineNr;
+                   g_packageCommentAllowed = FALSE;
+                   newVariable();
+                   BEGIN(Search);
+                 }
+}
+
+<SmlInclude>{
+{IDENTIFIER}/{B} {
+                   current->section   = Entry::VARIABLE_SEC;
+                   current->name      = QCString(yytext).stripWhiteSpace();
+		   current->type      = "include";
+                   current->fileName  = yyFileName;
+                   current->startLine = yyLineNr;
+                   current->bodyLine  = yyLineNr;
+                   g_packageCommentAllowed = FALSE;
+                   newVariable();
+                   BEGIN(Search);
+                 }
+}
+
+<SearchMemVars>{
+    "self."{IDENTIFIER}/{B}"=" {
+                        DBG_CTX((stderr,"Found member variable %s in %s at %d\n",&yytext[5],current_root->name.data(),yyLineNr));
+                        current->name=&yytext[5];
+                        current->section=Entry::VARIABLE_SEC;
+                        current->fileName  = yyFileName;
+                        current->startLine = yyLineNr;
+                        current->bodyLine  = yyLineNr;
+                        current->type.resize(0);
+                        if (current->name.at(0)=='_') // mark as private
+                        {
+                          current->protection=Private;
+                        }
+                        else
+                        {
+                          current->protection=Public;
+                        }
+                        newEntry();
+                      }
+    {TRIDOUBLEQUOTE}  { // start of a comment block
+                        initTriDoubleQuoteBlock();
+                        BEGIN(TripleComment);
+                      }
+
+    {TRISINGLEQUOTE}  { // start of a comment block
+                        initTriSingleQuoteBlock();
+                        BEGIN(TripleComment);
+                      }
+
+    {STARTDOCSYMS}/[^*]    {  // start of a special comment
+                        initSpecialBlock();
+                        BEGIN(SpecialComment);
+                      }
+    "'"               { // start of a single quoted string
+                        g_stringContext=YY_START;
+                        g_copyString=0;
+                        BEGIN( SingleQuoteString );
+                      }
+    "\""              { // start of a double quoted string
+                        g_stringContext=YY_START;
+                        g_copyString=0;
+                        BEGIN( DoubleQuoteString );
+                      }
+    \n                { incLineNr(); }
+    {IDENTIFIER}      // identifiers
+    [^'"\.#a-z_A-Z\n]+  // other uninteresting stuff
+    .                 // anything else
+}
+
+<FunctionDec>{
+
+    {IDENTIFIER}            {
+                              //found function name
+                              if (current->type.isEmpty())
+                              {
+                                  current->type = "fun";
+                              }
+                              current->name = yytext;
+                              current->name = current->name.stripWhiteSpace();
+                              BEGIN( FunctionParams );
+                            }
+}
+
+<FunctionParams>{
+    {IDENTIFIER}        { // Name of parameter
+                          lineCount();
+                          Argument *a = new Argument;
+                          current->argList->append(a);
+                          current->argList->getLast()->name = QCString(yytext).stripWhiteSpace();
+                          current->argList->getLast()->type = "";
+                        }
+   "_"                  { // Name of parameter
+                          lineCount();
+                          Argument *a = new Argument;
+                          current->argList->append(a);
+                          current->argList->getLast()->name = QCString(yytext).stripWhiteSpace();
+                          current->argList->getLast()->type = "";
+                        }
+    "("                 { // Name of parameter
+                          unput('(');
+                          g_defVal.resize(0);
+                          g_braceCount=0;
+                          BEGIN( SmlPattern );
+                        }
+    "["                 { // Name of parameter
+                          unput('[');
+                          g_defVal.resize(0);
+                          g_braceCount=0;
+                          BEGIN( SmlPattern );
+                        }
+    "{"                 { // Name of parameter
+                          unput('(');
+                          g_defVal.resize(0);
+                          g_braceCount=0;
+                          BEGIN( SmlPattern );
+                        }
+    "="                 {
+                          g_specialBlock = TRUE; // expecting a docstring
+                          bodyEntry = current;
+                          current->bodyLine  = yyLineNr;
+			  endOfDef();
+                          BEGIN( Search );
+                        }
+}
+
+<SmlPattern>{
+     [\(\[\{]           {
+                          g_braceCount++;
+                          g_defVal+=*yytext;
+                        }
+     [\)\]\}]           {
+                          g_braceCount--;
+                          if (g_braceCount==0) {
+                            g_defVal+=*yytext;
+                            lineCount();
+                            Argument *a = new Argument;
+                            current->argList->append(a);
+                            current->argList->getLast()->name = QCString(g_defVal).stripWhiteSpace();
+                            current->argList->getLast()->type = "";
+                            BEGIN( FunctionParams );
+                          }
+                          else { g_defVal+=*yytext; }
+                        }
+    "\""                {
+                          g_defVal+=*yytext;
+                          BEGIN( SmlQuoteString );
+                        }
+    .                   { g_defVal+=*yytext; }
+
+}
+
+
+<ClassBody>{
+    ^{BB}/\n          { // skip empty line
+                        current->program+=yytext;
+                      }
+    <<EOF>>           {
+                        endOfDef();
+                        yyterminate();
+                      }
+    [^ \t\n#'"]+      { // non-special stuff
+                        current->program+=yytext;
+                      }
+    {NEWLINE}         {
+                        current->program+=*yytext;
+                        incLineNr();
+                      }
+    .                 { // any character
+                        current->program+=*yytext;
+                      }
+}
+
+<ClassDec>{
+    {IDENTIFIER}{B}"(".*")" {
+                   if (current->type.isEmpty())
+                   {
+                     current->type = "structure";
+                   }
+
+                   current->section = Entry::CLASS_SEC;
+                   current->name = yytext;
+
+                   // prepend scope in case of nested classes
+                   if (current_root->section&Entry::SCOPE_MASK)
+                     current->name.prepend(current_root->name+"::");
+
+                   current->name = current->name.stripWhiteSpace();
+                   current->fileName = yyFileName;
+                   docBlockContext   = YY_START;
+                   docBlockInBody    = FALSE;
+                   docBlockJavaStyle = FALSE;
+                   docBlock.resize(0);
+
+                   BEGIN(ClassInheritance);
+                }
+
+    {IDENTIFIER} {
+                   if (current->type.isEmpty())
+                   {
+                     current->type = "structure";
+                   }
+
+                   current->section = Entry::CLASS_SEC;
+                   current->name = yytext;
+
+                   // prepend scope in case of nested classes
+                   if (current_root->section&Entry::SCOPE_MASK)
+                     current->name.prepend(current_root->name+"::");
+
+                   current->name = current->name.stripWhiteSpace();
+                   current->fileName = yyFileName;
+                   docBlockContext   = YY_START;
+                   docBlockInBody    = TRUE;
+                   docBlockJavaStyle = FALSE;
+                   docBlock.resize(0);
+
+                   BEGIN(ClassInheritance);
+                }
+}
+
+<ClassInheritance>{
+   ({BB}|[\(,\)])      {}
+
+    "="                { // begin of the class definition
+                         g_specialBlock = TRUE; // expecting a docstring
+                         current->bodyLine  = yyLineNr;
+                         current->program.resize(0);
+                         BEGIN(ClassBody);
+                       }
+
+    (":>")*{SCOPE}            {
+                         current->extends->append(
+                                              new BaseInfo(substitute(yytext,".","::"),Public,Normal)
+                                            );
+                         //Has base class-do stuff
+                       }
+}
+
+<TripleComment>{
+    {TRIDOUBLEQUOTE}   |
+    {TRISINGLEQUOTE}   {
+                          // printf("Expected module block %d special=%d\n",g_expectModuleDocs,g_specialBlock);
+                          if (g_doubleQuote==(yytext[0]=='"'))
+                          {
+                            if (g_specialBlock) // expecting a docstring
+                            {
+                              QCString actualDoc=docBlock;
+                              if (!docBlockSpecial) // legacy unformatted docstring
+                              {
+                                actualDoc.prepend("\\verbatim ");
+                                actualDoc.append("\\endverbatim ");
+                              }
+                              //printf("-------> current=%p bodyEntry=%p\n",current,bodyEntry);
+                              handleCommentBlock(actualDoc, FALSE);
+                            }
+                            else if (g_packageCommentAllowed) // expecting module docs
+                            {
+                              QCString actualDoc=docBlock;
+                              if (!docBlockSpecial) // legacy unformatted docstring
+                              {
+                                actualDoc.prepend("\\verbatim ");
+                                actualDoc.append("\\endverbatim ");
+                              }
+                              actualDoc.prepend("\\namespace "+g_moduleScope+"\\_linebr ");
+                              handleCommentBlock(actualDoc, FALSE);
+                            }
+                            if ((docBlockContext==ClassBody /*&& !g_hideClassDocs*/))
+                            {
+                              current->program+=docBlock;
+                              current->program+=yytext;
+                            }
+                            //if (g_hideClassDocs)
+                            //{
+                            //  current->startLine = yyLineNr;
+                            //}
+                            //g_hideClassDocs=FALSE;
+                            BEGIN(docBlockContext);
+                          }
+                          else
+                          {
+                            docBlock += yytext;
+                          }
+                          g_packageCommentAllowed = FALSE;
+                        }
+
+
+    ^{BB}		{ // leading whitespace
+                            docBlock += yytext;
+                        }
+    [^"'\n \t]+          {
+                          docBlock += yytext;
+                        }
+    \n			{
+                          incLineNr();
+                          docBlock += yytext;
+                        }
+    .			{
+                          docBlock += yytext;
+                        }
+}
+
+<StandardComment>{
+    "*)"		{ g_inComment = 0; BEGIN(Search); }
+    \n/{B}"*)"		{ g_inComment = 0; BEGIN(Search); }
+    \n/{B}"*"		{ incLineNr(); }
+    [^*\n*)]+           { current->program+=yytext; }
+    \n			{ incLineNr(); }
+    .			{ current->program+=yytext; }
+
+}
+
+<SpecialComment>{
+    "refstruct{"        { BEGIN(LinkToStructure); }
+    "*)"		{
+                          handleCommentBlock(docBlock, docBrief);
+                          g_inComment = FALSE;
+                          BEGIN(docBlockContext);
+                        }
+    "*"                 {}
+    ^{B}"*"("*")*	{ // skip leading stars
+                        }
+    \n/{B}"*)"		{
+                          handleCommentBlock(docBlock, docBrief);
+                        g_inComment = FALSE;
+                          BEGIN(docBlockContext);
+                        }
+    \n/{B}"*"		{ // continuation of the comment on the next line
+                          docBlock+='\n';
+                          docBrief = FALSE;
+                          startCommentBlock(FALSE);
+                          incLineNr();
+                        }
+    \n			{ // new line that ends the comment
+                          //handleCommentBlock(docBlock, docBrief);
+                          incLineNr();
+                        }
+    .			{ // anything we missed
+                          docBlock+=*yytext;
+                        }
+}
+
+<LinkToStructure>{
+    {IDENTIFIER}        {
+                          docBlock += yytext;
+                          g_documentingStructure = yytext;
+                        }
+    "}"                 { BEGIN(SpecialComment); }
+}
+
+<SingleQuoteString>{
+    \\{B}\n                    { // line continuation
+                                 addToString(yytext);
+                                 incLineNr();
+                               }
+    \\.                        { // espaced char
+                                 addToString(yytext);
+                               }
+    "\"\"\""                   { // tripple double quotes
+                                 addToString(yytext);
+                               }
+    "'"                        { // end of the string
+                                 addToString(yytext);
+                                 BEGIN(g_stringContext);
+                               }
+    [^"'\n\\]+                 { // normal chars
+                                 addToString(yytext);
+                               }
+    .                          { // normal char
+                                 addToString(yytext);
+                               }
+}
+
+<DoubleQuoteString>{
+    \\{B}\n                    { // line continuation
+                                 addToString(yytext);
+                                 incLineNr();
+                               }
+    \\.                        { // espaced char
+                                 addToString(yytext);
+                               }
+    "'''"                      { // tripple single quotes
+                                 addToString(yytext);
+                               }
+    "\""                       { // end of the string
+                                 addToString(yytext);
+                                 BEGIN(g_stringContext);
+                               }
+    [^"'\n\\]+                 { // normal chars
+                                 addToString(yytext);
+                               }
+    .                          { // normal char
+                                 addToString(yytext);
+                               }
+}
+
+<SmlQuoteString>{
+    \\{B}\n                    { // line continuation
+                                 g_defVal+=*yytext;
+                                 incLineNr();
+                               }
+    \\.                        { // espaced char
+                                 g_defVal+=*yytext;
+                               }
+    "'''"                      { // tripple single quotes
+                                 g_defVal+=*yytext;
+                               }
+    "\""                       { // end of the string
+                                 g_defVal+=*yytext;
+                                 BEGIN(SmlPattern);
+                               }
+    .                          { // normal char
+                                 g_defVal+=*yytext;
+                               }
+}
+
+<TripleString>{
+    {TRIDOUBLEQUOTE}    |
+    {TRISINGLEQUOTE}    {
+                          *g_copyString += yytext;
+                          if (g_doubleQuote==(yytext[0]=='"'))
+                          {
+                            BEGIN(g_stringContext);
+                          }
+                        }
+
+
+    ({LONGSTRINGBLOCK}) {
+                          lineCount();
+                          *g_copyString += yytext;
+                        }
+    \n			{
+                          incLineNr();
+                          *g_copyString += yytext;
+                        }
+    .			{
+                          *g_copyString += *yytext;
+                        }
+}
+
+  /* ------------ End rules -------------- */
+
+  /*
+<*>({NONEMPTY}|{EXPCHAR}|{BB}) {}
+  */
+
+<*>{NEWLINE}                   { lineCount(); }
+<*>.                           {}
+%%
+
+//----------------------------------------------------------------------------
+
+static void parseCompounds(Entry *rt)
+{
+  //printf("parseCompounds(%s)\n",rt->name.data());
+  EntryListIterator eli(*rt->children());
+  Entry *ce;
+  for (;(ce=eli.current());++eli)
+  {
+    if (!ce->program.isEmpty())
+    {
+      //printf("-- %s ---------\n%s\n---------------\n",
+      //  ce->name.data(),ce->program.data());
+      // init scanner state
+      inputString = ce->program;
+      inputPosition = 0;
+      smlscannerYYrestart( smlscannerYYin ) ;
+      if (ce->section&Entry::COMPOUND_MASK)
+      {
+        current_root = ce ;
+        BEGIN( Search );
+      }
+      else if (ce->parent())
+      {
+        current_root = ce->parent();
+        //printf("Searching for member variables in %s parent=%s\n",
+        //    ce->name.data(),ce->parent->name.data());
+        BEGIN( SearchMemVars );
+      }
+      yyFileName = ce->fileName;
+      yyLineNr   = ce->bodyLine ;
+      if (current) delete current;
+      current = new Entry;
+      initEntry();
+
+      groupEnterCompound(yyFileName,yyLineNr,ce->name);
+
+      smlscannerYYlex() ;
+      g_lexInit=TRUE;
+      delete current; current=0;
+      ce->program.resize(0);
+
+      groupLeaveCompound(yyFileName,yyLineNr,ce->name);
+
+    }
+    parseCompounds(ce);
+  }
+}
+
+//----------------------------------------------------------------------------
+
+
+static void parseMain(const char *fileName,const char *fileBuf,Entry *rt)
+{
+  initParser();
+  myStack.top = -1;
+
+  inputString = fileBuf;
+  inputPosition = 0;
+
+  protection    = Public;
+  mtype         = Method;
+  gstat         = FALSE;
+  virt          = Normal;
+  current_root  = rt;
+  g_specialBlock = FALSE;
+
+
+  inputFile.setName(fileName);
+  if (inputFile.open(IO_ReadOnly))
+  {
+    yyLineNr= 1 ;
+    yyFileName = fileName;
+    //setContext();
+    msg("Parsing file %s...\n",yyFileName.data());
+
+    QFileInfo fi(fileName);
+    g_moduleScope = findPackageScope(fileName);
+    QCString baseName=fi.baseName().utf8();
+    if (baseName!="__init__") // package initializer file is not a package itself
+    {
+      if (!g_moduleScope.isEmpty())
+      {
+        g_moduleScope+="::";
+      }
+      g_moduleScope+=baseName;
+    }
+
+    current            = new Entry;
+    initEntry();
+    current->name      = g_moduleScope;
+    current->section   = Entry::NAMESPACE_SEC;
+    current->type      = "namespace";
+    current->fileName  = yyFileName;
+    current->startLine = yyLineNr;
+    current->bodyLine  = yyLineNr;
+
+    rt->addSubEntry(current);
+
+    current_root  = current ;
+    initParser();
+    current       = new Entry;
+
+    groupEnterFile(yyFileName,yyLineNr);
+
+    current->reset();
+    initEntry();
+    smlscannerYYrestart( smlscannerYYin );
+    BEGIN( Search );
+    smlscannerYYlex();
+    g_lexInit=TRUE;
+
+    groupLeaveFile(yyFileName,yyLineNr);
+
+    current_root->program.resize(0);
+    delete current; current=0;
+
+    parseCompounds(current_root);
+
+    inputFile.close();
+  }
+
+}
+
+//----------------------------------------------------------------------------
+
+static void parsePrototype(const QCString &text)
+{
+  //printf("**** parsePrototype(%s) begin\n",text.data());
+  if (text.isEmpty())
+  {
+    warn(yyFileName,yyLineNr,"Empty prototype found!");
+    return;
+  }
+
+  g_specialBlock = FALSE;
+  g_packageCommentAllowed = FALSE;
+
+  const char *orgInputString;
+  int orgInputPosition;
+  YY_BUFFER_STATE orgState;
+
+  // save scanner state
+  orgState = YY_CURRENT_BUFFER;
+  yy_switch_to_buffer(yy_create_buffer(smlscannerYYin, YY_BUF_SIZE));
+  orgInputString = inputString;
+  orgInputPosition = inputPosition;
+
+  // set new string
+  inputString = text;
+  inputPosition = 0;
+  smlscannerYYrestart( smlscannerYYin );
+
+  BEGIN( FunctionDec );
+
+  smlscannerYYlex();
+  g_lexInit=TRUE;
+
+  current->name = current->name.stripWhiteSpace();
+  if (current->section == Entry::MEMBERDOC_SEC && current->args.isEmpty())
+    current->section = Entry::VARIABLEDOC_SEC;
+
+  // restore original scanner state
+
+  YY_BUFFER_STATE tmpBuf = YY_CURRENT_BUFFER;
+  yy_switch_to_buffer(orgState);
+  yy_delete_buffer(tmpBuf);
+
+  inputString = orgInputString;
+  inputPosition = orgInputPosition;
+
+  //printf("**** parsePrototype end\n");
+}
+
+void smlscanFreeScanner()
+{
+#if defined(YY_FLEX_SUBMINOR_VERSION)
+  if (g_lexInit)
+  {
+    smlscannerYYlex_destroy();
+  }
+#endif
+}
+
+//----------------------------------------------------------------------------
+
+void SmlLanguageScanner::parseInput(const char *fileName,
+                                       const char *fileBuf,
+                                       Entry *root,
+                                       bool /*sameTranslationUnit*/,
+                                       QStrList & /*filesInSameTranslationUnit*/)
+{
+  g_thisParser = this;
+  ::parseMain(fileName,fileBuf,root);
+
+  // May print the AST for debugging purposes
+  // printAST(global_root);
+}
+
+bool SmlLanguageScanner::needsPreprocessing(const QCString &)
+{
+  return FALSE;
+}
+
+void SmlLanguageScanner::parseCode(CodeOutputInterface &codeOutIntf,
+    const char *scopeName,
+    const QCString &input,
+    SrcLangExt /*lang*/,
+    bool isExampleBlock,
+    const char *exampleName,
+    FileDef *fileDef,
+    int startLine,
+    int endLine,
+    bool inlineFragment,
+    MemberDef *memberDef,
+    bool showLineNumbers,
+    Definition *searchCtx,
+    bool collectXRefs
+    )
+{
+  ::parseSmlCode(codeOutIntf,scopeName,input,isExampleBlock,exampleName,
+                    fileDef,startLine,endLine,inlineFragment,memberDef,
+                    showLineNumbers,searchCtx,collectXRefs);
+}
+
+void SmlLanguageScanner::parsePrototype(const char *text)
+{
+  ::parsePrototype(text);
+
+}
+
+void SmlLanguageScanner::resetCodeParserState()
+{
+  ::resetSmlCodeParserState();
+}
+
+//----------------------------------------------------------------------------
+
+#if !defined(YY_FLEX_SUBMINOR_VERSION)
+//----------------------------------------------------------------------------
+extern "C" { // some bogus code to keep the compiler happy
+  void smlscannerYYdummy() { yy_flex_realloc(0,0); }
+}
+#endif
diff --git a/src/types.h b/src/types.h
index 0c269be..f9d1b72 100644
--- a/src/types.h
+++ b/src/types.h
@@ -54,7 +54,8 @@ enum SrcLangExt
   SrcLangExt_VHDL     = 0x02000,
   SrcLangExt_XML      = 0x04000,
   SrcLangExt_Tcl      = 0x08000,
-  SrcLangExt_Markdown = 0x10000
+  SrcLangExt_Markdown = 0x10000,
+  SrcLangExt_Sml      = 0x20000
 };
 
 /** Grouping info */
diff --git a/src/util.cpp b/src/util.cpp
index c127362..6f68600 100644
--- a/src/util.cpp
+++ b/src/util.cpp
@@ -6730,6 +6730,7 @@ g_lang2extMap[] =
   { "c",           "c",       SrcLangExt_Cpp      },
   { "c++",         "c",       SrcLangExt_Cpp      },
   { "python",      "python",  SrcLangExt_Python   },
+  { "sml",          "sml",    SrcLangExt_Sml      },
   { "fortran",     "fortran", SrcLangExt_Fortran  },
   { "vhdl",        "vhdl",    SrcLangExt_VHDL     },
   { "dbusxml",     "dbusxml", SrcLangExt_XML      },
@@ -6794,6 +6795,8 @@ void initDefaultExtensionMapping()
   updateLanguageMapping(".M",        "objective-c");
   updateLanguageMapping(".mm",       "objective-c");
   updateLanguageMapping(".py",       "python");
+  updateLanguageMapping(".sml",       "sml");
+  updateLanguageMapping(".sig",       "sml");
   updateLanguageMapping(".f",        "fortran");
   updateLanguageMapping(".for",      "fortran");
   updateLanguageMapping(".f90",      "fortran");
@@ -7770,6 +7773,7 @@ QCString langToString(SrcLangExt lang)
     case SrcLangExt_Cpp:      return "C++";
     case SrcLangExt_JS:       return "Javascript";
     case SrcLangExt_Python:   return "Python";
+    case SrcLangExt_Sml:      return "Sml";
     case SrcLangExt_Fortran:  return "Fortran";
     case SrcLangExt_VHDL:     return "VHDL";
     case SrcLangExt_XML:      return "XML";
@@ -7782,7 +7786,7 @@ QCString langToString(SrcLangExt lang)
 /** Returns the scope separator to use given the programming language \a lang */
 QCString getLanguageSpecificSeparator(SrcLangExt lang,bool classScope)
 {
-  if (lang==SrcLangExt_Java || lang==SrcLangExt_CSharp || lang==SrcLangExt_VHDL || lang==SrcLangExt_Python)
+  if (lang==SrcLangExt_Java || lang==SrcLangExt_CSharp || lang==SrcLangExt_VHDL || lang==SrcLangExt_Python || lang==SrcLangExt_Sml)
   {
     return ".";
   }
-- 
1.8.4

